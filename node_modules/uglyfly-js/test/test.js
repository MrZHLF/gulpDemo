(function () {
    'use strict';
    var Promise = require('bluebird'),
        path = require('path'),
        fs = require('fs'),
        mkdirp = require('mkdirp'),
        glob = require('glob'),
        vinylFS = require('vinyl-fs'),
        mapStream = require('map-stream'),
        uglyfly = require('../index.js'),
        util = require('util'),
        testDir = path.dirname(module.filename),
        outDir = path.join(testDir, './out/'),
        baseDir = path.join(testDir, '..'),
        globpaths = {
            lib: path.join(baseDir, 'lib' + path.sep) + '*.js'
        };

    function stringHashCode(str) {
        var hash = 0,
            i,
            ch,
            n = (str || '').length;
        for (i = 0; i < n; ++i) {
            ch = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + ch;
            hash |= 0; // Convert to 32bit integer
        }
        return hash;
    }

    function logResults(err, data, runningLog, callback) {
        var action,
            actionComment,
            taskHeader,
            inFile,
            inFilename,
            hashes = {},
            fileContents = {},
            lenFileContents = {},
            results,
            outSubdir,
            outFileType,
            outFiles = {},
            extPrefix,
            logItem;

        action = data.action;
        actionComment = ((data.actionComment || '').length ? '(' + data.actionComment + ')' : '');
        inFile = data.input.file;

        if (typeof inFile === 'string') {
            inFilename = path.basename(inFile);
            hashes.inFilepath = stringHashCode(inFile);
            fileContents.inCode = fs.readFileSync(inFile, 'utf8');
        } else if (inFile) {
            if (inFile.path) {
                inFilename = path.basename(inFile.path);
                hashes.inFilepath = stringHashCode(inFile.path);
            }
            if (inFile.contents) {
                fileContents.inCode = String(inFile.contents);
            }
        }

        taskHeader = action + ' ' + actionComment + ' ' + inFilename;

        lenFileContents.inCode = fileContents.inCode.length;
        hashes.inCode = stringHashCode(fileContents.inCode);

        if (err) {
            util.error('[FAILED] ' + taskHeader);
            util.error(err);
            runningLog.fail = runningLog.fail || [];
            runningLog.fail.push({
                task: taskHeader,
                lengths: lenFileContents,
                hashes: hashes,
                error: err
            });
            return callback(null, runningLog);
        }

        try {
            results = data.output;

            hashes.outCode = stringHashCode(results.code);
            hashes.map = stringHashCode(results.map);

            fileContents.outCode = results.code;
            lenFileContents.outCode = fileContents.outCode.length;

            fileContents.map = results.map;
            lenFileContents.map = fileContents.map.length;

            if (!data.supressOutputs) {
                outSubdir = path.join(outDir, data.timestamps.testStart, action, inFilename + '_' +  hashes.inFilepath + path.sep);

                mkdirp.sync(outSubdir);
                extPrefix = '';
                switch (action) {
                case 'minify':
                    extPrefix = '.min';
                    break;
                }
                outFiles.inCode = path.join(outSubdir, hashes.inCode + '.js');
                outFiles.outCode = path.join(outSubdir, hashes.inCode + '_' + hashes.outCode + extPrefix + '.js');
                outFiles.map = path.join(outSubdir, hashes.inCode + '_' + hashes.outCode + '_' + hashes.map + extPrefix + '.js.map');

                for (outFileType in outFiles) {
                    if (outFiles.hasOwnProperty(outFileType) && fileContents.hasOwnProperty(outFileType)) {
                        fs.writeFileSync(outFiles[outFileType], fileContents[outFileType]);
                    }
                }
            }

            logItem = {
                task: taskHeader,
                lengths: lenFileContents,
                hashes: hashes
            };

            if (logItem.lengths.inCode && logItem.lengths.outCode) {
                logItem.compressionPercentage = Math.round(1000 * (logItem.lengths.inCode - logItem.lengths.outCode) / logItem.lengths.inCode) / 10;
            }

            runningLog.std = runningLog.std || [];
            runningLog.std.push(logItem);
        } catch (ex) {
            runningLog.ex = runningLog.ex || [];
            runningLog.ex.push(ex);
            util.error(ex);
        }
        return callback(null, runningLog);
    }

    function runAndLog(action, file, options, testStartTimestamp, actionComment, runningLog, loggingOptions, callback) {
        var startTimestamp = (new Date()).toISOString(),
            process = uglyfly[action],
            input = {
                file: file,
                options: options
            },
            data = {
                action: action,
                actionComment: actionComment,
                input: input,
                supressOutputs: loggingOptions && loggingOptions.supressOutputs,
                timestamps: {
                    testStart: testStartTimestamp,
                    start: startTimestamp
                }
            },
            cb = function (err, output) {
                data.timestamps.end = (new Date()).toISOString();
                data.output = output;
                return logResults(err, data, runningLog, callback);
            };
        if (typeof process === 'function') {
            return process(file, options, cb);
        }
        return callback(null, runningLog);
    }

    function defaultActionOptions(filepath, action) {
        var options = {};
        switch (action) {
        case 'minify':
            options.outSourceMap = true;
            options.sourceMapURL = filepath + '.map';
            break;
        case 'beautify':
            options.outSourceMap = true;
            options.sourceMapURL = filepath + '.map';
            break;
        }
        return options;
    }

    function testVinylFileStream(filestream, action, runningLog, loggingOptions, getActionOptions, callback) {
        var actionComment = 'from vinyl file',
            testStartTimestamp = (new Date()).toISOString();
        loggingOptions = loggingOptions || {
            supressOutputs: false
        };
        getActionOptions = (typeof getActionOptions === 'function') ? getActionOptions : defaultActionOptions;
        filestream
            .pipe(mapStream(function (vinylFile, cb) {
                var file = { //just to be explicit about what uglyfly actually looks at
                        path: vinylFile.path,
                        contents: vinylFile.contents
                    },
                    options = getActionOptions(file.path, action);
                runAndLog(action, file, options, testStartTimestamp, actionComment, runningLog, loggingOptions, cb);
            })).on('end', function (err) {
                callback(err, runningLog)
            });
    }

    function testFilepaths(filepathsArr, action, runningLog, loggingOptions, getActionOptions, callback) {
        var actionComment = 'from filepath',
            testStartTimestamp = (new Date()).toISOString(),
            n;
        function cb(err, data) {
            n--;
            if (n < 1) {
                return callback(null, runningLog);
            }
        }
        loggingOptions = loggingOptions || {
            supressOutputs: false
        };
        getActionOptions = (typeof getActionOptions === 'function') ? getActionOptions : defaultActionOptions;
        filepathsArr = filepathsArr || [];
        n = filepathsArr.length;
        if(n === 0) {
            callback(null, runningLog);
        } else {
            filepathsArr.forEach(function (filepath) {
                var file = filepath,
                    options = getActionOptions(filepath, action);
                runAndLog(action, file, options, testStartTimestamp, actionComment, runningLog, loggingOptions, cb);
            });
        }
    }

    util.log("TESTING " + globpaths.lib);
    var runningLog = {};
    testVinylFileStream(vinylFS.src(globpaths.lib), 'minify', runningLog, null, null, function (e1, d1) {
        testFilepaths(glob.sync(globpaths.lib), 'minify', runningLog, null, null, function (e2, d2 ) {
            util.log(JSON.stringify(runningLog, null, 2));
        });
    });
}());