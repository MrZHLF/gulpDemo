/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "get_warn",
    [
    ],
    function () {
        
        function get_warn(warn_callback) {
            function warn(txt, props) {
                /*jslint unparam: true, regexp: true*/
                /*jshint unused: true*/
                if (warn_callback === "function") {
                    warn_callback(txt.replace(/\{(.+?)\}/g, function (str, p) {
                        return props[p];
                    }));
                }
            }
            return warn;
        }
        return get_warn;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "merge",
    [
        //no dependencies
    ],
    function () {
        
        function merge(obj, ext) {
            var i;
            for (i in ext) {
                if (ext.hasOwnProperty(i)) {
                    obj[i] = ext[i];
                }
            }
            return obj;
        }
        return merge;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "AST",
    [
        //no dependencies
    ],
    function () {
        
        /*jslint plusplus: true, nomen: true */
        var AST = {},
            UNDEF = (function () {
                return;
            }()),
            NAN = (function () {
                var num = 0,
                    denom = 0;
                return num / denom;
            }()),
            INFINITY = (function () {
                var num = 1,
                    denom = 0;
                return num / denom;
            }());

        function def_node(type, props, methods, BaseType) {
            var self_props,
                proto,
                NodeType,
                method;
            if (arguments.length < 4) {
                BaseType = AST.Node;
            }
            props = props ? props.split(/\s+/) : [];
            self_props = props;
            if (BaseType && BaseType.PROPS) {
                props = props.concat(BaseType.PROPS);
            }
            proto = BaseType && new BaseType();
            NodeType = (function (props, shouldInit) {
                return function (arg) {
                    /*jslint plusplus: true */
                    var i, prop;
                    for (i = props.length - 1; i >= 0; --i) {
                        prop = props[i];
                        if (arg) {
                            this[prop] = arg[prop];
                        }
                    }
                    if (shouldInit && (typeof this.initialize === "function")) {
                        this.initialize();
                    }
                };
            }(props.slice(), (proto && proto.initialize) || (methods && methods.initialize)));

            if (proto) {
                NodeType.prototype = proto;
                NodeType.BASE = BaseType;
            }
            if (BaseType) {
                BaseType.SUBCLASSES.push(NodeType);
            }
            NodeType.prototype.CTOR = NodeType;
            NodeType.PROPS = props || null;
            NodeType.SELF_PROPS = self_props;
            NodeType.SUBCLASSES = [];
            if (type) {
                NodeType.prototype.TYPE = NodeType.TYPE = type;
            }
            if (methods) {
                for (method in methods) {
                    if (methods.hasOwnProperty(method)) {
                        if (method.charAt(0) === "$") {
                            NodeType[method.substr(1)] = methods[method];
                        } else {
                            NodeType.prototype[method] = methods[method];
                        }
                    }
                }
            }
            NodeType.prototype["instanceof_" + type] = true;
            NodeType.DEFMETHOD = function (name, method) {
                this.prototype[name] = method;
            };
            return NodeType;
        }

        function walk_body(node, visitor) {
            if (node.body instanceof AST.Statement) {
                node.body._walk(visitor);
            } else {
                node.body.forEach(function (stat) {
                    stat._walk(visitor);
                });
            }
        }

        AST.def_node = def_node;

        AST.Token = def_node("Token", "type value line col pos endline endcol endpos nlb comments_before file", {
        }, null);

        AST.Node = def_node("Node", "start end", {
            clone: function () {
                return new this.CTOR(this);
            },
            $documentation: "Base class of all AST nodes",
            $propdoc: {
                start: "[AST.Token] The first token of this node",
                end: "[AST.Token] The last token of this node"
            },
            _walk: function (visitor) {
                return visitor._visit(this);
            },
            walk: function (visitor) {
                return this._walk(visitor); // not sure the indirection will be any help
            }
        }, null);


        /* -----[ statements ]----- */

        AST.Statement = def_node("Statement", null, {
            $documentation: "Base class of all statements"
        });

        AST.Debugger = def_node("Debugger", null, {
            $documentation: "Represents a debugger statement"
        }, AST.Statement);

        AST.Directive = def_node("Directive", "value scope quote", {
            $documentation: "Represents a directive, like \"use strict\";",
            $propdoc: {
                value: "[string] The value of this directive as a plain string (it's not an AST.String!)",
                scope: "[AST.Scope/S] The scope that this directive affects",
                quote: "[string] the original quote character"
            }
        }, AST.Statement);

        AST.SimpleStatement = def_node("SimpleStatement", "body", {
            $documentation: "A statement consisting of an expression, i.e. a = 1 + 2",
            $propdoc: {
                body: "[AST.Node] an expression node (should not be instanceof AST.Statement)"
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.body._walk(visitor);
                });
            }
        }, AST.Statement);

        AST.Block = def_node("Block", "body", {
            $documentation: "A body of statements (usually bracketed)",
            $propdoc: {
                body: "[AST.Statement*] an array of statements"
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    walk_body(this, visitor);
                });
            }
        }, AST.Statement);

        AST.BlockStatement = def_node("BlockStatement", null, {
            $documentation: "A block statement"
        }, AST.Block);

        AST.EmptyStatement = def_node("EmptyStatement", null, {
            $documentation: "The empty statement (empty block or simply a semicolon)",
            _walk: function (visitor) {
                return visitor._visit(this);
            }
        }, AST.Statement);

        AST.StatementWithBody = def_node("StatementWithBody", "body", {
            $documentation: "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",
            $propdoc: {
                body: "[AST.Statement] the body; this should always be present, even if it's an AST.EmptyStatement"
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.body._walk(visitor);
                });
            }
        }, AST.Statement);

        AST.LabeledStatement = def_node("LabeledStatement", "label", {
            $documentation: "Statement with a label",
            $propdoc: {
                label: "[AST.Label] a label definition"
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.label._walk(visitor);
                    this.body._walk(visitor);
                });
            }
        }, AST.StatementWithBody);

        AST.IterationStatement = def_node("IterationStatement", null, {
            $documentation: "Internal class.  All loops inherit from it."
        }, AST.StatementWithBody);

        AST.DWLoop = def_node("DWLoop", "condition", {
            $documentation: "Base class for do/while statements",
            $propdoc: {
                condition: "[AST.Node] the loop condition.  Should not be instanceof AST.Statement"
            }
        }, AST.IterationStatement);

        AST.Do = def_node("Do", null, {
            $documentation: "A `do` statement",
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.body._walk(visitor);
                    this.condition._walk(visitor);
                });
            }
        }, AST.DWLoop);

        AST.While = def_node("While", null, {
            $documentation: "A `while` statement",
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.condition._walk(visitor);
                    this.body._walk(visitor);
                });
            }
        }, AST.DWLoop);

        AST.For = def_node("For", "init condition step", {
            $documentation: "A `for` statement",
            $propdoc: {
                init: "[AST.Node?] the `for` initialization code, or null if empty",
                condition: "[AST.Node?] the `for` termination clause, or null if empty",
                step: "[AST.Node?] the `for` update clause, or null if empty"
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    if (this.init) {
                        this.init._walk(visitor);
                    }
                    if (this.condition) {
                        this.condition._walk(visitor);
                    }
                    if (this.step) {
                        this.step._walk(visitor);
                    }
                    this.body._walk(visitor);
                });
            }
        }, AST.IterationStatement);

        AST.ForIn = def_node("ForIn", "init name object", {
            $documentation: "A `for ... in` statement",
            $propdoc: {
                init: "[AST.Node] the `for/in` initialization code",
                name: "[AST.SymbolRef?] the loop variable, only if `init` is AST.Var",
                object: "[AST.Node] the object that we're looping through"
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.init._walk(visitor);
                    this.object._walk(visitor);
                    this.body._walk(visitor);
                });
            }
        }, AST.IterationStatement);

        AST.With = def_node("With", "expression", {
            $documentation: "A `with` statement",
            $propdoc: {
                expression: "[AST.Node] the `with` expression"
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.expression._walk(visitor);
                    this.body._walk(visitor);
                });
            }
        }, AST.StatementWithBody);

        /* -----[ scope and functions ]----- */

        AST.Scope = def_node("Scope", "directives variables functions uses_with uses_eval parent_scope enclosed cname", {
            $documentation: "Base class for all statements introducing a lexical scope",
            $propdoc: {
                directives: "[string*/S] an array of directives declared in this scope",
                variables: "[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope",
                functions: "[Object/S] like `variables`, but only lists function declarations",
                uses_with: "[boolean/S] tells whether this scope uses the `with` statement",
                uses_eval: "[boolean/S] tells whether this scope contains a direct call to the global `eval`",
                parent_scope: "[AST.Scope?/S] link to the parent scope",
                enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",
                cname: "[integer/S] current index for mangling variables (used internally by the mangler)"
            }
        }, AST.Block);

        AST.Toplevel = def_node("Toplevel", "globals", {
            $documentation: "The toplevel scope",
            $propdoc: {
                globals: "[Object/S] a map of name -> SymbolDef for all undeclared names"
            }
        }, AST.Scope);

        AST.Lambda = def_node("Lambda", "name argnames uses_arguments", {
            $documentation: "Base class for functions",
            $propdoc: {
                name: "[AST.SymbolDeclaration?] the name of this function",
                argnames: "[AST.SymbolFunarg*] array of function arguments",
                uses_arguments: "[boolean/S] tells whether this function accesses the arguments array"
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    if (this.name) {
                        this.name._walk(visitor);
                    }
                    this.argnames.forEach(function (arg) {
                        arg._walk(visitor);
                    });
                    walk_body(this, visitor);
                });
            }
        }, AST.Scope);

        AST.Accessor = def_node("Accessor", null, {
            $documentation: "A setter/getter function.  The `name` property is always null."
        }, AST.Lambda);

        AST.Function = def_node("Function", null, {
            $documentation: "A function expression"
        }, AST.Lambda);

        AST.Defun = def_node("Defun", null, {
            $documentation: "A function definition"
        }, AST.Lambda);

        /* -----[ JUMPS ]----- */

        AST.Jump = def_node("Jump", null, {
            $documentation: "Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)"
        }, AST.Statement);

        AST.Exit = def_node("Exit", "value", {
            $documentation: "Base class for “exits” (`return` and `throw`)",
            $propdoc: {
                value: "[AST.Node?] the value returned or thrown by this statement; could be null for AST.Return"
            },
            _walk: function (visitor) {
                return visitor._visit(this, this.value && function () {
                    this.value._walk(visitor);
                });
            }
        }, AST.Jump);

        AST.Return = def_node("Return", null, {
            $documentation: "A `return` statement"
        }, AST.Exit);

        AST.Throw = def_node("Throw", null, {
            $documentation: "A `throw` statement"
        }, AST.Exit);

        AST.LoopControl = def_node("LoopControl", "label", {
            $documentation: "Base class for loop control statements (`break` and `continue`)",
            $propdoc: {
                label: "[AST.LabelRef?] the label, or null if none"
            },
            _walk: function (visitor) {
                return visitor._visit(this, this.label && function () {
                    this.label._walk(visitor);
                });
            }
        }, AST.Jump);

        AST.Break = def_node("Break", null, {
            $documentation: "A `break` statement"
        }, AST.LoopControl);

        AST.Continue = def_node("Continue", null, {
            $documentation: "A `continue` statement"
        }, AST.LoopControl);

        /* -----[ IF ]----- */
        AST.If = def_node("If", "condition alternative", {
            $documentation: "A `if` statement",
            $propdoc: {
                condition: "[AST.Node] the `if` condition",
                alternative: "[AST.Statement?] the `else` part, or null if not present"
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.condition._walk(visitor);
                    this.body._walk(visitor);
                    if (this.alternative) {
                        this.alternative._walk(visitor);
                    }
                });
            }
        }, AST.StatementWithBody);

        /* -----[ SWITCH ]----- */

        AST.Switch = def_node("Switch", "expression", {
            $documentation: "A `switch` statement",
            $propdoc: {
                expression: "[AST.Node] the `switch` “discriminant”"
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.expression._walk(visitor);
                    walk_body(this, visitor);
                });
            }
        }, AST.Block);

        AST.SwitchBranch = def_node("SwitchBranch", null, {
            $documentation: "Base class for `switch` branches"
        }, AST.Block);

        AST.Default = def_node("Default", null, {
            $documentation: "A `default` switch branch"
        }, AST.SwitchBranch);

        AST.Case = def_node("Case", "expression", {
            $documentation: "A `case` switch branch",
            $propdoc: {
                expression: "[AST.Node] the `case` expression"
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.expression._walk(visitor);
                    walk_body(this, visitor);
                });
            }
        }, AST.SwitchBranch);

        /* -----[ EXCEPTIONS ]----- */

        AST.Try = def_node("Try", "bcatch bfinally", {
            $documentation: "A `try` statement",
            $propdoc: {
                bcatch: "[AST.Catch?] the catch block, or null if not present",
                bfinally: "[AST.Finally?] the finally block, or null if not present"
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    walk_body(this, visitor);
                    if (this.bcatch) {
                        this.bcatch._walk(visitor);
                    }
                    if (this.bfinally) {
                        this.bfinally._walk(visitor);
                    }
                });
            }
        }, AST.Block);

        AST.Catch = def_node("Catch", "argname", {
            $documentation: "A `catch` node; only makes sense as part of a `try` statement",
            $propdoc: {
                argname: "[AST.SymbolCatch] symbol for the exception"
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.argname._walk(visitor);
                    walk_body(this, visitor);
                });
            }
        }, AST.Block);

        AST.Finally = def_node("Finally", null, {
            $documentation: "A `finally` node; only makes sense as part of a `try` statement"
        }, AST.Block);

        /* -----[ VAR/CONST ]----- */

        AST.Definitions = def_node("Definitions", "definitions", {
            $documentation: "Base class for `var` or `const` nodes (variable declarations/initializations)",
            $propdoc: {
                definitions: "[AST.VarDef*] array of variable definitions"
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.definitions.forEach(function (def) {
                        def._walk(visitor);
                    });
                });
            }
        }, AST.Statement);

        AST.Var = def_node("Var", null, {
            $documentation: "A `var` statement"
        }, AST.Definitions);

        AST.Const = def_node("Const", null, {
            $documentation: "A `const` statement"
        }, AST.Definitions);

        AST.VarDef = def_node("VarDef", "name value", {
            $documentation: "A variable declaration; only appears in a AST.Definitions node",
            $propdoc: {
                name: "[AST.SymbolVar|AST.SymbolConst] name of the variable",
                value: "[AST.Node?] initializer, or null of there's no initializer"
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.name._walk(visitor);
                    if (this.value) {
                        this.value._walk(visitor);
                    }
                });
            }
        });

        /* -----[ OTHER ]----- */

        AST.Call = def_node("Call", "expression args", {
            $documentation: "A function call expression",
            $propdoc: {
                expression: "[AST.Node] expression to invoke as function",
                args: "[AST.Node*] array of arguments"
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.expression._walk(visitor);
                    this.args.forEach(function (arg) {
                        arg._walk(visitor);
                    });
                });
            }
        });

        AST.New = def_node("New", null, {
            $documentation: "An object instantiation.  Derives from a function call since it has exactly the same properties"
        }, AST.Call);

        AST.Seq = def_node("Seq", "car cdr", {
            $documentation: "A sequence expression (two comma-separated expressions)",
            $propdoc: {
                car: "[AST.Node] first element in sequence",
                cdr: "[AST.Node] second element in sequence"
            },
            $cons: function (x, y) {
                var seq = new AST.Seq(x);
                seq.car = x;
                seq.cdr = y;
                return seq;
            },
            $from_array: function (array) {
                var list = null,
                    i,
                    p;
                if (array.length === 0) {
                    return null;
                }
                if (array.length === 1) {
                    return array[0].clone();
                }
                for (i = array.length - 1; i >= 0; --i) {
                    list = AST.Seq.cons(array[i], list);
                }
                p = list;
                while (p) {
                    if (p.cdr && !p.cdr.cdr) {
                        p.cdr = p.cdr.car;
                        break;
                    }
                    p = p.cdr;
                }
                return list;
            },
            to_array: function () {
                var p = this,
                    a = [];
                while (p) {
                    a.push(p.car);
                    if (p.cdr && !(p.cdr instanceof AST.Seq)) {
                        a.push(p.cdr);
                        break;
                    }
                    p = p.cdr;
                }
                return a;
            },
            add: function (node) {
                var p = this,
                    cell;
                while (p) {
                    if (!(p.cdr instanceof AST.Seq)) {
                        cell = AST.Seq.cons(p.cdr, node);
                        p.cdr = cell;
                        return cell;
                    }
                    p = p.cdr;
                }
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.car._walk(visitor);
                    if (this.cdr) {
                        this.cdr._walk(visitor);
                    }
                });
            }
        });

        AST.PropAccess = def_node("PropAccess", "expression property", {
            $documentation: "Base class for property access expressions, i.e. `a.foo` or `a[\"foo\"]`",
            $propdoc: {
                expression: "[AST.Node] the “container” expression",
                property: "[AST.Node|string] the property to access.  For AST.Dot this is always a plain string, while for AST.Sub it's an arbitrary AST.Node"
            }
        });

        AST.Dot = def_node("Dot", null, {
            $documentation: "A dotted property access expression",
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.expression._walk(visitor);
                });
            }
        }, AST.PropAccess);

        AST.Sub = def_node("Sub", null, {
            $documentation: "Index-style property access, i.e. `a[\"foo\"]`",
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.expression._walk(visitor);
                    this.property._walk(visitor);
                });
            }
        }, AST.PropAccess);

        AST.Unary = def_node("Unary", "operator expression", {
            $documentation: "Base class for unary expressions",
            $propdoc: {
                operator: "[string] the operator",
                expression: "[AST.Node] expression that this unary operator applies to"
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.expression._walk(visitor);
                });
            }
        });

        AST.UnaryPrefix = def_node("UnaryPrefix", null, {
            $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`"
        }, AST.Unary);

        AST.UnaryPostfix = def_node("UnaryPostfix", null, {
            $documentation: "Unary postfix expression, i.e. `i++`"
        }, AST.Unary);

        AST.Binary = def_node("Binary", "left operator right", {
            $documentation: "Binary expression, i.e. `a + b`",
            $propdoc: {
                left: "[AST.Node] left-hand side expression",
                operator: "[string] the operator",
                right: "[AST.Node] right-hand side expression"
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.left._walk(visitor);
                    this.right._walk(visitor);
                });
            }
        });

        AST.Conditional = def_node("Conditional", "condition consequent alternative", {
            $documentation: "Conditional expression using the ternary operator, i.e. `a ? b : c`",
            $propdoc: {
                condition: "[AST.Node]",
                consequent: "[AST.Node]",
                alternative: "[AST.Node]"
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.condition._walk(visitor);
                    this.consequent._walk(visitor);
                    this.alternative._walk(visitor);
                });
            }
        });

        AST.Assign = def_node("Assign", null, {
            $documentation: "An assignment expression — `a = b + 5`"
        }, AST.Binary);

        /* -----[ LITERALS ]----- */

        AST.Array = def_node("Array", "elements", {
            $documentation: "An array literal",
            $propdoc: {
                elements: "[AST.Node*] array of elements"
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.elements.forEach(function (el) {
                        el._walk(visitor);
                    });
                });
            }
        });

        AST.Object = def_node("Object", "properties", {
            $documentation: "An object literal",
            $propdoc: {
                properties: "[AST.ObjectProperty*] array of properties"
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.properties.forEach(function (prop) {
                        prop._walk(visitor);
                    });
                });
            }
        });

        AST.ObjectProperty = def_node("ObjectProperty", "key value", {
            $documentation: "Base class for literal object properties",
            $propdoc: {
                key: "[string] the property name converted to a string for ObjectKeyVal.  For setters and getters this is an arbitrary AST.Node.",
                value: "[AST.Node] property value.  For setters and getters this is an AST.Function."
            },
            _walk: function (visitor) {
                return visitor._visit(this, function () {
                    this.value._walk(visitor);
                });
            }
        });

        AST.ObjectKeyVal = def_node("ObjectKeyVal", "quote", {
            $documentation: "A key: value object property",
            $propdoc: {
                quote: "[string] the original quote character"
            }
        }, AST.ObjectProperty);

        AST.ObjectSetter = def_node("ObjectSetter", null, {
            $documentation: "An object setter property"
        }, AST.ObjectProperty);

        AST.ObjectGetter = def_node("ObjectGetter", null, {
            $documentation: "An object getter property"
        }, AST.ObjectProperty);

        AST.Symbol = def_node("Symbol", "scope name thedef", {
            $propdoc: {
                name: "[string] name of this symbol",
                scope: "[AST.Scope/S] the current scope (not necessarily the definition scope)",
                thedef: "[SymbolDef/S] the definition of this symbol"
            },
            $documentation: "Base class for all symbols"
        });

        AST.SymbolAccessor = def_node("SymbolAccessor", null, {
            $documentation: "The name of a property accessor (setter/getter function)"
        }, AST.Symbol);

        AST.SymbolDeclaration = def_node("SymbolDeclaration", "init", {
            $documentation: "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)",
            $propdoc: {
                init: "[AST.Node*/S] array of initializers for this declaration."
            }
        }, AST.Symbol);

        AST.SymbolVar = def_node("SymbolVar", null, {
            $documentation: "Symbol defining a variable"
        }, AST.SymbolDeclaration);

        AST.SymbolConst = def_node("SymbolConst", null, {
            $documentation: "A constant declaration"
        }, AST.SymbolDeclaration);

        AST.SymbolFunarg = def_node("SymbolFunarg", null, {
            $documentation: "Symbol naming a function argument"
        }, AST.SymbolVar);

        AST.SymbolDefun = def_node("SymbolDefun", null, {
            $documentation: "Symbol defining a function"
        }, AST.SymbolDeclaration);

        AST.SymbolLambda = def_node("SymbolLambda", null, {
            $documentation: "Symbol naming a function expression"
        }, AST.SymbolDeclaration);

        AST.SymbolCatch = def_node("SymbolCatch", null, {
            $documentation: "Symbol naming the exception in catch"
        }, AST.SymbolDeclaration);

        AST.Label = def_node("Label", "references", {
            $documentation: "Symbol naming a label (declaration)",
            $propdoc: {
                references: "[AST.LoopControl*] a list of nodes referring to this label"
            },
            initialize: function () {
                this.references = [];
                this.thedef = this;
            }
        }, AST.Symbol);

        AST.SymbolRef = def_node("SymbolRef", null, {
            $documentation: "Reference to some symbol (not definition/declaration)"
        }, AST.Symbol);

        AST.LabelRef = def_node("LabelRef", null, {
            $documentation: "Reference to a label symbol"
        }, AST.Symbol);

        AST.This = def_node("This", null, {
            $documentation: "The `this` symbol"
        }, AST.Symbol);

        AST.Constant = def_node("Constant", null, {
            $documentation: "Base class for all constants",
            getValue: function () {
                return this.value;
            }
        });

        AST.String = def_node("String", "value quote", {
            $documentation: "A string literal",
            $propdoc: {
                value: "[string] the contents of this string",
                quote: "[string] the original quote character"
            }
        }, AST.Constant);

        AST.Number = def_node("Number", "value", {
            $documentation: "A number literal",
            $propdoc: {
                value: "[number] the numeric value"
            }
        }, AST.Constant);

        AST.RegExp = def_node("RegExp", "value", {
            $documentation: "A regexp literal",
            $propdoc: {
                value: "[RegExp] the actual regexp"
            }
        }, AST.Constant);

        AST.Atom = def_node("Atom", null, {
            $documentation: "Base class for atoms"
        }, AST.Constant);

        AST.Null = def_node("Null", null, {
            $documentation: "The `null` atom",
            value: null
        }, AST.Atom);

        AST.NaN = def_node("NaN", null, {
            $documentation: "The impossible value",
            value: NAN
        }, AST.Atom);

        AST.Undefined = def_node("Undefined", null, {
            $documentation: "The `undefined` value",
            value: UNDEF
        }, AST.Atom);

        AST.Hole = def_node("Hole", null, {
            $documentation: "A hole in an array",
            value: UNDEF
        }, AST.Atom);

        AST.Infinity = def_node("Infinity", null, {
            $documentation: "The `Infinity` value",
            value: INFINITY
        }, AST.Atom);

        AST.Boolean = def_node("Boolean", null, {
            $documentation: "Base class for booleans"
        }, AST.Atom);

        AST.False = def_node("False", null, {
            $documentation: "The `false` atom",
            value: false
        }, AST.Boolean);

        AST.True = def_node("True", null, {
            $documentation: "The `true` atom",
            value: true
        }, AST.Boolean);

        return AST;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "TreeWalker",
    [
        //no dependencies
    ],
    function () {
        
        /*jslint nomen: true, plusplus: true */
        /* -----[ TreeWalker ]----- */
        function TreeWalker(callback) {
            this.visit = callback;
            this.stack = [];
        }

        TreeWalker.prototype = {
            _visit: function (node, descend) {
                var ret;
                this.stack.push(node);
                ret = this.visit(node, descend ? function () {
                    descend.call(node);
                } : function () {
                    return;
                });
                if (!ret && descend) {
                    descend.call(node);
                }
                this.stack.pop();
                return ret;
            },
            parent: function (n) {
                return this.stack[this.stack.length - 2 - (n || 0)];
            },
            push: function (node) {
                this.stack.push(node);
            },
            pop: function () {
                return this.stack.pop();
            },
            self: function () {
                return this.stack[this.stack.length - 1];
            },
            find_parent: function (type) {
                var stack = this.stack,
                    i,
                    x;
                for (i = stack.length - 1; i >= 0; --i) {
                    x = stack[i];
                    if (x["instanceof_" + type]) {
                        return x;
                    }
                }
            },
            has_directive: function (type) {
                return this.find_parent("Scope").has_directive(type);
            },
            in_boolean_context: function () {
                var stack = this.stack,
                    i = stack.length,
                    self = stack[--i],
                    p;
                while (i > 0) {
                    p = stack[--i];
                    if ((((p.instanceof_If) ||
                            (p.instanceof_Conditional) ||
                            (p.instanceof_DWLoop) ||
                            (p.instanceof_For)) &&
                                (p.condition === self)) ||
                            ((p.instanceof_UnaryPrefix) &&
                                (p.operator === "!") &&
                                (p.expression === self))) {
                        return true;
                    }
                    if (!(p.instanceof_Binary) ||
                            ((p.operator !== "&&") && (p.operator !== "||"))) {
                        return false;
                    }
                    self = p;
                }
            },
            loopcontrol_target: function (label) {
                var stack = this.stack,
                    i,
                    x;
                if (label) {
                    for (i = stack.length - 1; i >= 0; --i) {
                        x = stack[i];
                        if ((x.instanceof_LabeledStatement) && (x.label.name === label.name)) {
                            return x.body;
                        }
                    }
                } else {
                    for (i = stack.length - 1; i >= 0; --i) {
                        x = stack[i];
                        if ((x.instanceof_Switch) || (x.instanceof_IterationStatement)) {
                            return x;
                        }
                    }
                }
            }
        };

        return TreeWalker;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "TreeTransformer",
    [
        "TreeWalker"
    ],
    function (TreeWalker) {
        function TreeTransformer(before, after) {
            TreeWalker.call(this);
            this.before = before;
            this.after = after;
        }
        TreeTransformer.prototype = new TreeWalker();
        return TreeTransformer;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "DefaultsError",
    [
        //no dependencies
    ],
    function () {
        
        function DefaultsError(msg, defs) {
            Error.call(this, msg);
            this.msg = msg;
            this.defs = defs;
        }
        DefaultsError.prototype = Object.create(Error.prototype);
        DefaultsError.prototype.constructor = DefaultsError;
        DefaultsError.croak = function (msg, defs) {
            throw new DefaultsError(msg, defs);
        };
        return DefaultsError;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "defaults",
    [
        "DefaultsError"
    ],
    function (DefaultsError) {
        
        function defaults(args, defs, croak) {
            var i,
                ret;
            if (args === true) {
                args = {};
            }
            ret = args || {};
            if (croak) {
                if (typeof croak !== "function") {
                    croak = DefaultsError.croak;
                } else if (croak !== DefaultsError.croak){
                    croak = (function (croak_callback) {
                        return function croak(msg, defs) {
                            croak_callback.apply(null, arguments);
                            throw new DefaultsError(msg, defs);
                        };
                    } (croak));
                }
                for (i in ret) {
                    if (ret.hasOwnProperty(i) && !defs.hasOwnProperty(i)) {
                        croak("`" + i + "` is not a supported option", defs);
                    }
                }
            }
            for (i in defs) {
                if (defs.hasOwnProperty(i)) {
                    ret[i] = (args && args.hasOwnProperty(i)) ? args[i] : defs[i];
                }
            }
            return ret;
        }
        return defaults;
    }
);
/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

/*globals define, module, require */

define(
    "Compressor",
    [
        "TreeTransformer",
        "defaults",
        "merge"
    ],
    function (TreeTransformer, defaults, merge) {
        
        /*jslint nomen: true, unparam: true*/
        function Compressor(options, false_by_default, warn, croak_callback) {
            if (!(this instanceof Compressor)) {
                return new Compressor(options, false_by_default, warn, croak_callback);
            }
            TreeTransformer.call(this, this.before, this.after);
            this.options = defaults(options, {
                sequences: !false_by_default,
                properties: !false_by_default,
                dead_code: !false_by_default,
                drop_debugger: !false_by_default,
                unsafe: false,
                unsafe_comps: false,
                conditionals: !false_by_default,
                comparisons: !false_by_default,
                evaluate: !false_by_default,
                booleans: !false_by_default,
                loops: !false_by_default,
                unused: !false_by_default,
                hoist_funs: !false_by_default,
                keep_fargs: false,
                keep_fnames: false,
                hoist_vars: false,
                if_return: !false_by_default,
                join_vars: !false_by_default,
                cascade: !false_by_default,
                side_effects: !false_by_default,
                pure_getters: false,
                pure_funcs: null,
                negate_iife: !false_by_default,
                screw_ie8: false,
                drop_console: false,
                angular: false,

                warnings: true,
                global_defs: {}
            }, (croak_callback || true));
            this.warn = function () {
                if (this.options.warnings && warn) {
                    warn.apply(null, arguments);
                }
            };
        }

        Compressor.prototype = new TreeTransformer();
        merge(Compressor.prototype, {
            option: function (key) {
                return this.options[key];
            },
            before: function (node, descend) {
                var was_scope = false;
                if (node._squeezed) {
                    return node;
                }
                if (node.instanceof_Scope) {
                    node = node.hoist_declarations(this);
                    was_scope = true;
                }
                descend(node, this);
                node = node.optimize(this);
                if (was_scope && (node.instanceof_Scope)) {
                    node.drop_unused(this);
                    descend(node, this);
                }
                node._squeezed = true;
                return node;
            }
        });

        return Compressor;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "SourceMap",
    [
        "defaults"
    ],
    function (defaults) {
        

        // a small wrapper around fitzgen's source-map library
        function SourceMap(MOZ_SourceMap, options) {
            var orig_map,
                generator;
            options = defaults(options, {
                file: null,
                root: null,
                orig: null,
                orig_line_diff: 0,
                dest_line_diff: 0
            });
            orig_map = options.orig && new MOZ_SourceMap.SourceMapConsumer(options.orig);
            if (orig_map) {
                generator = MOZ_SourceMap.SourceMapGenerator.fromSourceMap(orig_map);
            } else {
                generator = new MOZ_SourceMap.SourceMapGenerator({
                    file: options.file,
                    sourceRoot: options.root
                });
            }
            function add(source, gen_line, gen_col, orig_line, orig_col, name) {
                var info;
                if (orig_map) {
                    info = orig_map.originalPositionFor({
                        line: orig_line,
                        column: orig_col
                    });
                    if (info.source === null) {
                        return;
                    }
                    source = info.source;
                    orig_line = info.line;
                    orig_col = info.column;
                    name = info.name || name;
                }
                generator.addMapping({
                    generated: {
                        line: gen_line + options.dest_line_diff,
                        column: gen_col
                    },
                    original: {
                        line: orig_line + options.orig_line_diff,
                        column: orig_col
                    },
                    source: source,
                    name: name
                });
            }
            return {
                add: add,
                get: function () {
                    return generator;
                },
                toString: function () {
                    return JSON.stringify(generator.toJSON());
                }
            };
        }

        return SourceMap;
    }
);


/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/
//Note:
//  This achieves the same effect as predicates.js but with slightly slower
//    but significantly more compact code (suitable for bundling)
//  The code for the functions in predicates.js are effectively generated
//    with this file

/*globals define, module, require */

define(
    "predicates",
    [
        //no dependencies
    ],
    function () {
        
        var predicates = {},
            WORDS = {};
        WORDS.KEYWORDS = ["break", "case", "catch", "const", "continue", "debugger", "default", "delete", "do", "else", "finally", "for", "function", "if", "in", "instanceof", "new", "return", "switch", "throw", "try", "typeof", "var", "void", "while", "with"];
        WORDS.KEYWORDS_ATOM = ["false", "null", "true"];
        WORDS.RESERVED_WORDS = WORDS.KEYWORDS.concat(WORDS.KEYWORDS_ATOM).concat(["abstract", "boolean", "byte", "char", "class", "double", "enum", "export", "extends", "final", "float", "goto", "implements", "import", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "super", "synchronized", "this", "throws", "transient", "volatile", "yield"]);
        WORDS.KEYWORDS_BEFORE_EXPRESSION = ["case", "delete", "else", "new", "return", "throw"];
        WORDS.OPERATORS = ["delete", "in", "instanceof", "new", "typeof", "void"].concat(["!", "!=", "!==", "%", "%=", "&", "&&", "&=", "*", "*=", "+", "++", "+=", "-", "--", "-=", "/", "/=", "<", "<<", "<<=", "<=", "=", "==", "===", ">", ">=", ">>", ">>=", ">>>", ">>>=", "?", "^", "^=", "|", "|=", "||", "~"]);
        WORDS.OPERATOR_CHARS = ["!", "%", "&", "*", "+", "-", "<", "=", ">", "?", "^", "|", "~"];
        WORDS.WHITESPACE_CHARS = ["\u0009", "\u000a", "\u000b", "\u000c", "\u000d", " ", "\u00a0", "\u180e", "\u2000", "\u2001", "\u2002", "\u2003", "\u2004", "\u2005", "\u2006", "\u2007", "\u2008", "\u2009", "\u200a", "\u200b", "\u202f", "\u205f", "\u3000"];
        WORDS.PUNC_BEFORE_EXPRESSION = ["(", ",", ".", ":", ";", "[", "{"];
        WORDS.PUNC_CHARS = ["(", ")", ",", ":", ";", "[", "]", "{", "}"];
        WORDS.UNARY_PREFIX = ["delete", "typeof", "void"].concat(["!", "+", "++", "-", "--", "~"]);
        WORDS.UNARY_POSTFIX = ["++", "--"];
        WORDS.ASSIGNMENT = ["%=", "&=", "*=", "+=", "-=", "/=", "<<=", "=", ">>=", ">>>=", "^=", "|="];
        WORDS.REGEXP_MODIFIERS = ["g", "i", "m", "s", "y"];

        (function () {
            var name;

            // this makePredicate function is based on code from Acorn [1], written by Marijn Haverbeke
            // [1] https://github.com/marijnh/acorn
            function makePredicate(words, name, byFirstCharCode) {
                /*jslint plusplus: true, evil: true, unparam: true*/
                /*jshint unused: true*/
                var f = "\n",
                    cats = [],
                    i,
                    j,
                    cat,
                    skipPush,
                    tab = "    ";
                if (!(words instanceof Array)) {
                    words = words.split(" ");
                }
                if (!byFirstCharCode) {
                    for (i = 0; i < words.length; ++i) {
                        skipPush = false;
                        for (j = 0; j < cats.length; ++j) {
                            if (cats[j][0].length === words[i].length) {
                                cats[j].push(words[i]);
                                skipPush = true;
                                break;
                            }
                        }
                        if (!skipPush) {
                            cats.push([words[i]]);
                        }
                    }
                }
                function compareTo(arr, tabbing, byFirstCharCode) {
                    tabbing = tabbing || "";
                    if (arr.length === 1) {
                        f += tabbing + "return str === " + JSON.stringify(arr[0]) + ";\n";
                        return f;
                    }
                    f += tabbing + "switch (str" + (byFirstCharCode ? ".charCodeAt(0)" : "") + ") {\n";
                    for (j = 0; j < arr.length; ++j) {
                        f += tabbing + "case " + (byFirstCharCode ? arr[j].charCodeAt(0) : JSON.stringify(arr[j])) + ":\n";
                    }
                    f += tabbing + "    return true;\n" + tabbing + "}\n" + tabbing + "return false;\n";
                }
                // When there are more than three length categories, an outer
                // switch first dispatches on the length,s to save on comparisons.
                if (cats.length > 3) {
                    cats.sort(function (a, b) {
                        return b.length - a.length;
                    });
                    f += tab + "switch (str.length) {\n";
                    for (i = 0; i < cats.length; ++i) {
                        cat = cats[i];
                        f += tab + "case " + cat[0].length + ":\n";
                        compareTo(cat, tab + tab);
                    }
                    f += tab + "}\n";
                    // Otherwise, simply generate a flat `switch` statement.
                } else {
                    compareTo(words, tab, byFirstCharCode);
                }

                return new Function("str", f);
            }

            for (name in WORDS) {
                if (WORDS.hasOwnProperty(name)) {
                    predicates[name] = makePredicate(WORDS[name], name, (name === "WHITESPACE_CHARS"));
                }
            }
        }());

        return predicates;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "is",
    [
        "predicates"
    ],
    function (predicates) {
        

        var is = {},
            re = { // regexps adapted from http://xregexp.com/plugins/#unicode
                letter: new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
                digit: new RegExp("[\\u0030-\\u0039\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0DE6-\\u0DEF\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uA9F0-\\uA9F9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]"),
                non_spacing_mark: new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065E\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0900-\\u0902\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F90-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFD-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),
                space_combining_mark: new RegExp("[\\u0903\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]"),
                connector_punctuation: new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]"),
                identifier_string: (/^[a-z_$][a-z0-9_$]*$/i)
            };

        /* -----[ Tokenizer ]----- */
        is = {};

        is.letter = function is_letter(code) {
            return (code >= 97 && code <= 122) ||
                (code >= 65 && code <= 90) ||
                (code >= 0xaa && re.letter.test(String.fromCharCode(code)));
        };

        is.is_unicode_digit = function is_unicode_digit(code) {
            return re.digit.test(String.fromCharCode(code));
        };

        is.digit = function is_digit(code) {
            return (code >= 48) && (code <= 57);
        };

        is.alphanumeric_char = function is_alphanumeric_char(code) {
            return is.digit(code) || is.letter(code);
        };

        is.unicode_combining_mark = function is_unicode_combining_mark(ch) {
            return re.non_spacing_mark.test(ch) || re.space_combining_mark.test(ch);
        };

        is.unicode_connector_punctuation = function is_unicode_connector_punctuation(ch) {
            return re.connector_punctuation.test(ch);
        };

        is.identifier_string = function is_identifier_string(str) {
            return re.identifier_string.test(str);
        };

        is.identifier = function is_identifier(name) {
            return !predicates.RESERVED_WORDS(name) && re.identifier_string.test(name);
        };

        is.identifier_start = function is_identifier_start(code) {
            return (code === 36) || (code === 95) || is.letter(code);
        };

        is.identifier_char = function is_identifier_char(ch) {
            var code = ch.charCodeAt(0);
            return is.identifier_start(code) ||
                is.digit(code) ||
                (code === 8204) || // \u200c: zero-width non-joiner <ZWNJ>
                (code === 8205) || // \u200d: zero-width joiner <ZWJ> (in my ECMA-262 PDF, this is also 200c)
                is.unicode_combining_mark(ch) ||
                is.unicode_connector_punctuation(ch);
        };

        is.token = function is_token(token, type, val) {
            return (token.type === type) && ((val === undefined) || (val === null) || (token.value === val));
        };

        return is;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "OutputStream",
    [
        "defaults",
        "is"
    ],
    function (defaults, is) {
        
        /*jslint plusplus: true*/

        function OutputStream(options, warn, croak) {

            var indentation = 0,
                current_col = 0,
                current_line = 1,
                current_pos = 0,
                OUTPUT = "",
                might_need_space = false,
                might_need_semicolon = false,
                last = null,
                stack = [],
                maybe_newline,
                space,
                indent,
                with_indent,
                newline,
                semicolon,
                add_mapping;

            options = defaults(options, {
                indent_start     : 0,
                indent_level     : 4,
                quote_keys       : false,
                space_colon      : true,
                ascii_only       : false,
                unescape_regexps : false,
                inline_script    : false,
                width            : 80,
                max_line_len     : 32000,
                beautify         : false,
                source_map       : null,
                bracketize       : false,
                semicolons       : true,
                comments         : false,
                preserve_line    : false,
                screw_ie8        : false,
                preamble         : null,
                quote_style      : 0
            }, croak || true);

            function noop() {
                return;
            }

            function to_ascii(str, identifier) {
                return str.replace(/[\u0080-\uffff]/g, function (ch) {
                    var code = ch.charCodeAt(0).toString(16);
                    if (code.length <= 2 && !identifier) {
                        while (code.length < 2) {
                            code = "0" + code;
                        }
                        return "\\x" + code;
                    }
                    while (code.length < 4) {
                        code = "0" + code;
                    }
                    return "\\u" + code;
                });
            }

            function make_string(str, quote) {
                var sqPreference = 0,
                    use_sq;
                str = str.replace(/[\\\b\f\n\r\t\x22\x27\u2028\u2029\0\ufeff]/g,
                    function (s) {
                        switch (s) {
                        case "\\":
                            return "\\\\";
                        case "\b":
                            return "\\b";
                        case "\f":
                            return "\\f";
                        case "\n":
                            return "\\n";
                        case "\r":
                            return "\\r";
                        case "\u2028":
                            return "\\u2028";
                        case "\u2029":
                            return "\\u2029";
                        case '"':
                            ++sqPreference;
                            return '"';
                        case "'":
                            --sqPreference;
                            return "'";
                        case String.fromCharCode(0):
                            return "\\x00";
                        case "\ufeff":
                            return "\\ufeff";
                        }
                        return s;
                    });
                if (options.ascii_only) {
                    str = to_ascii(str);
                }
                switch (options.quote_style) {
                case 1:
                    use_sq = true;
                    break;
                case 2:
                    use_sq = false;
                    break;
                case 3:
                    use_sq = (quote === "'");
                    break;
                default:
                    use_sq = (sqPreference > 0);
                    break;
                }
                str = use_sq ? "'" + str.replace(/\x27/g, "\\'") + "'" : '"' + str.replace(/\x22/g, '\\"') + '"';
                return str;
            }

            function encode_string(str, quote) {
                var ret = make_string(str, quote);
                if (options.inline_script) {
                    ret = ret.replace(/<\x2fscript([>\/\t\n\f\r ])/gi, "<\\/script$1");
                }
                return ret;
            }

            function make_name(name) {
                name = name.toString();
                if (options.ascii_only) {
                    name = to_ascii(name, true);
                }
                return name;
            }

            function repeat_string(str, count) {
                /*jslint bitwise: true */
                var str2 = "";
                if (count < 1) {
                    return "";
                }
                if (count === 1) {
                    return str;
                }
                while (count > 1) {
                    if (count & 1) {
                        str2 += str;
                    }
                    count >>= 1;
                    str += str;
                }
                return str2 + str;
            }

            function make_indent(back) {
                return repeat_string(" ", options.indent_start + indentation - back * options.indent_level);
            }

            /* -----[ beautification/minification ]----- */

            function last_char() {
                return last.charAt(last.length - 1);
            }

            function requireSemicolonChars(str) {
                switch (str) {
                case "(":
                case "*":
                case "+":
                case ",":
                case "-":
                case ".":
                case "/":
                case "[":
                    return true;
                }
                return false;
            }

            function print(str) {
                var ch,
                    target_line,
                    prev,
                    a,
                    n;
                str = String(str);
                ch = str.charAt(0);
                if (might_need_semicolon) {
                    if ((!ch || ";}".indexOf(ch) < 0) && !/[;]$/.test(last)) {
                        if (options.semicolons || requireSemicolonChars(ch)) {
                            OUTPUT += ";";
                            current_col++;
                            current_pos++;
                        } else {
                            OUTPUT += "\n";
                            current_pos++;
                            current_line++;
                            current_col = 0;
                        }
                        if (!options.beautify) {
                            might_need_space = false;
                        }
                    }
                    might_need_semicolon = false;
                    maybe_newline();
                }

                if (!options.beautify && options.preserve_line && stack[stack.length - 1]) {
                    target_line = stack[stack.length - 1].start.line;
                    while (current_line < target_line) {
                        OUTPUT += "\n";
                        current_pos++;
                        current_line++;
                        current_col = 0;
                        might_need_space = false;
                    }
                }

                if (might_need_space) {
                    prev = last_char();
                    if ((is.identifier_char(prev) && (is.identifier_char(ch) || ch === "\\")) ||
                            (/^[\+\-\/]$/.test(ch) && ch === prev)) {
                        OUTPUT += " ";
                        current_col++;
                        current_pos++;
                    }
                    might_need_space = false;
                }
                a = str.split(/\r?\n/);
                n = a.length - 1;
                current_line += n;
                if (n === 0) {
                    current_col += a[n].length;
                } else {
                    current_col = a[n].length;
                }
                current_pos += str.length;
                last = str;
                OUTPUT += str;
            }

            maybe_newline = function () {
                if (options.max_line_len && current_col > options.max_line_len) {
                    print("\n");
                }
            };

            space = options.beautify ? function () {
                print(" ");
            } : function () {
                might_need_space = true;
            };

            indent = options.beautify ? function (half) {
                if (options.beautify) {
                    print(make_indent(half ? 0.5 : 0));
                }
            } : noop;

            function next_indent() {
                return indentation + options.indent_level;
            }

            with_indent = options.beautify ? function (col, cont) {
                var save_indentation,
                    ret;
                if (col === true) {
                    col = next_indent();
                }
                save_indentation = indentation;
                indentation = col;
                ret = cont();
                indentation = save_indentation;
                return ret;
            } : function (col, cont) {
                /*jslint unparam: true */
                /*jshint unused: true*/
                return cont();
            };

            newline = options.beautify ? function () {
                print("\n");
            } : maybe_newline;

            semicolon = options.beautify ? function () {
                print(";");
            } : function () {
                might_need_semicolon = true;
            };

            add_mapping = options.source_map ? function (token, name) {
                try {
                    if (token) {
                        options.source_map.add(
                            token.file || "?",
                            current_line,
                            current_col,
                            token.line,
                            token.col,
                            (!name && token.type === "name") ? token.value : name
                        );
                    }
                } catch (ex) {
                    warn("Couldn't figure out mapping for {file}:{line},{col} → {cline},{ccol} [{name}]", {
                        file: token.file,
                        line: token.line,
                        col: token.col,
                        cline: current_line,
                        ccol: current_col,
                        name: name || ""
                    });
                }
            } : noop;

            if (options.preamble) {
                print(options.preamble.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g, "\n"));
            }

            function force_semicolon() {
                might_need_semicolon = false;
                print(";");
            }
            function with_block(cont) {
                var ret;
                print("{");
                newline();
                with_indent(next_indent(), function () {
                    ret = cont();
                });
                indent();
                print("}");
                return ret;
            }
            function with_parens(cont) {
                var ret;
                print("(");
                //XXX: still nice to have that for argument lists
                //ret = with_indent(current_col, cont);
                ret = cont();
                print(")");
                return ret;
            }
            function with_square(cont) {
                var ret;
                print("[");
                //ret = with_indent(current_col, cont);
                ret = cont();
                print("]");
                return ret;
            }
            function comma() {
                print(",");
                space();
            }
            function colon() {
                print(":");
                if (options.space_colon) {
                    space();
                }
            }
            function get() {
                return OUTPUT;
            }
            function current_width() {
                return current_col - indentation;
            }
            function should_break() {
                return options.width && (current_width() >= options.width);
            }
            function print_name(name) {
                print(make_name(name));
            }
            function print_string(str, quote) {
                print(encode_string(str, quote));
            }
            function option(opt) {
                return options[opt];
            }
            function line() {
                return current_line;
            }
            function col() {
                return current_col;
            }
            function pos() {
                return current_pos;
            }
            function push_node(node) {
                stack.push(node);
            }
            function pop_node() {
                return stack.pop();
            }
            function parent(n) {
                return stack[stack.length - 2 - (n || 0)];
            }

            return {
                get: get,
                toString: get,
                indent: indent,
                indentation: function () {
                    return indentation;
                },
                current_width: current_width,
                should_break: should_break,
                newline: newline,
                print: print,
                space: space,
                comma: comma,
                colon: colon,
                last: function () {
                    return last;
                },
                semicolon: semicolon,
                force_semicolon: force_semicolon,
                to_ascii: to_ascii,
                print_name: print_name,
                print_string: print_string,
                next_indent: next_indent,
                with_indent: with_indent,
                with_block: with_block,
                with_parens: with_parens,
                with_square: with_square,
                add_mapping: add_mapping,
                option: option,
                line: line,
                col: col,
                pos: pos,
                push_node: push_node,
                pop_node: pop_node,
                stack: function () {
                    return stack;
                },
                parent: parent
            };

        }
        return OutputStream;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "find_if",
    [
        //no dependencies
    ],
    function () {
        
        function find_if(fn, array) {
            /*jslint plusplus: true*/
            var i,
                n = array.length;
            for (i = 0; i < n; ++i) {
                if (fn(array[i])) {
                    return array[i];
                }
            }
        }
        return find_if;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "JS_Parse_Error",
    [
        //no dependencies
    ],
    function () {
        
        function JS_Parse_Error(message, filename, line, col, pos) {
            this.message = message;
            this.filename = filename;
            this.line = line;
            this.col = col;
            this.pos = pos;
            this.stack = new Error().stack;
        }

        JS_Parse_Error.prototype.toString = function () {
            return this.message + " (filename: \"" + this.filename + "\", line: " + this.line + ", col: " + this.col + ", pos: " + this.pos + ")" + "\n\n" + this.stack;
        };

        return JS_Parse_Error;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "js_error",
    [
        "JS_Parse_Error"
    ],
    function (JS_Parse_Error) {
        
        function js_error(message, filename, line, col, pos) {
            throw new JS_Parse_Error(message, filename, line, col, pos);
        }
        return js_error;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "precedence",
    [
        //no dependencies
    ],
    function () {
        
        function precedence(op) {
            switch (op) {
            case "||":
                return 1;
            case "&&":
                return 2;
            case "|":
                return 3;
            case "^":
                return 4;
            case "&":
                return 5;
            case "==":
            case "===":
            case "!=":
            case "!==":
                return 6;
            case "<":
            case ">":
            case "<=":
            case ">=":
            case "in":
            case "instanceof":
                return 7;
            case ">>":
            case "<<":
            case ">>>":
                return 8;
            case "+":
            case "-":
                return 9;
            case "*":
            case "/":
            case "%":
                return 10;
            default:
                return null;
            }
        }
        return precedence;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "parse",
    [
        "defaults",
        "find_if",
        "js_error",
        "precedence",
        "predicates",
        "is"
    ],
    function (defaults, find_if, js_error, precedence, predicates, is) {
        
        /*jslint nomen: true, plusplus: true */

        function tokenizer(AST, $TEXT, filename, html5_comments) {

            var S = {
                text: $TEXT.replace(/\uFEFF/g, ''),
                filename: filename,
                pos: 0,
                tokpos: 0,
                line: 1,
                tokline: 0,
                col: 0,
                tokcol: 0,
                newline_before: false,
                regex_allowed: false,
                comments_before: []
            },
                prev_was_dot = false,
                next_token,
                read_string,
                skip_multiline_comment,
                read_regexp,
                EX_EOF = {};

            function peek() {
                return S.text.charAt(S.pos);
            }

            function next(signal_eof, in_string) {
                var ch = S.text.charAt(S.pos);
                ++S.pos;
                if (signal_eof && !ch) {
                    throw EX_EOF;
                }
                switch (ch) {
                case "\r":
                case "\n":
                case "\u2028":
                case "\u2029":
                    S.newline_before = S.newline_before || !in_string;
                    ++S.line;
                    S.col = 0;
                    if (!in_string && (ch === "\r") && (peek() === "\n")) {
                        // treat a \r\n sequence as a single \n
                        ++S.pos;
                        ch = "\n";
                    }
                    break;
                default:
                    ++S.col;
                    break;
                }
                return ch;
            }

            function forward(i) {
                while (i > 0) {
                    next();
                    --i;
                }
            }

            function looking_at(str) {
                return S.text.substr(S.pos, str.length) === str;
            }

            function find(what, signal_eof) {
                var pos = S.text.indexOf(what, S.pos);
                if (signal_eof && pos === -1) {
                    throw EX_EOF;
                }
                return pos;
            }

            function start_token() {
                S.tokline = S.line;
                S.tokcol = S.col;
                S.tokpos = S.pos;
            }

            function token(type, value, is_comment) {
                var ret,
                    i,
                    len;
                S.regex_allowed = ((type === "operator" && !predicates.UNARY_POSTFIX(value)) ||
                                   (type === "keyword" && predicates.KEYWORDS_BEFORE_EXPRESSION(value)) ||
                                   (type === "punc" && predicates.PUNC_BEFORE_EXPRESSION(value)));
                prev_was_dot = (type === "punc" && value === ".");
                ret = {
                    type: type,
                    value: value,
                    line: S.tokline,
                    col: S.tokcol,
                    pos: S.tokpos,
                    endline: S.line,
                    endcol: S.col,
                    endpos: S.pos,
                    nlb: S.newline_before,
                    file: filename
                };
                if (!is_comment) {
                    ret.comments_before = S.comments_before;
                    S.comments_before = [];
                    // make note of any newlines in the comments that came before
                    for (i = 0, len = ret.comments_before.length; i < len; ++i) {
                        ret.nlb = ret.nlb || ret.comments_before[i].nlb;
                    }
                }
                S.newline_before = false;
                return new AST.Token(ret);
            }

            function skip_whitespace() {
                while (predicates.WHITESPACE_CHARS(peek())) {
                    next();
                }
            }

            function read_while(pred) {
                var ret = "",
                    ch = peek(),
                    i = 0;
                while (ch && pred(ch, i)) {
                    ret += next();
                    ch = peek();
                    ++i;
                }
                return ret;
            }

            function parse_error(err) {
                js_error(err, filename, S.tokline, S.tokcol, S.tokpos);
            }

            function parse_js_number(num) {
                if (/^0x[0-9a-f]+$/i.test(num)) { //hex
                    return parseInt(num.substr(2), 16);
                }
                if (/^0[0-7]+$/.test(num)) { //oct
                    return parseInt(num.substr(1), 8);
                }
                if (/^\d*\.?\d*(?:e[+\-]?\d*(?:\d\.?|\.?\d)\d*)?$/i.test(num)) { //dec
                    return parseFloat(num);
                }
            }

            function read_num(prefix) {
                var has_e = false,
                    after_e = false,
                    has_x = false,
                    has_dot = (prefix === "."),
                    valid,
                    num = read_while(function (ch, i) {
                        var code = ch.charCodeAt(0);
                        switch (code) {
                        case 120:
                        case 88: // xX
                            if (has_x) {
                                return false;
                            }
                            has_x = true;
                            return true;
                        case 101:
                        case 69: // eE
                            if (has_x) {
                                return true;
                            }
                            if (has_e) {
                                return false;
                            }
                            has_e = after_e = true;
                            return true;
                        case 45: // -
                            return after_e || (i === 0 && !prefix);
                        case 43: // +
                            return after_e;
                        case 46: // .
                            after_e = false;
                            if (!has_dot && !has_x && !has_e) {
                                has_dot = true;
                                return true;
                            }
                            return false;
                        default:
                            after_e = false;
                            return is.alphanumeric_char(code);
                        }
                    });
                if (prefix) {
                    num = prefix + num;
                }
                valid = parse_js_number(num);
                if (!isNaN(valid)) {
                    return token("num", valid);
                }
                parse_error("Invalid syntax: " + num);
            }

            function hex_bytes(n) {
                /*jslint bitwise: true */
                var num = 0,
                    digit;
                while (n > 0) {
                    digit = parseInt(next(true), 16);
                    if (isNaN(digit)) {
                        parse_error("Invalid hex-character pattern in string");
                    }
                    num = (num << 4) | digit;
                    --n;
                }
                return num;
            }

            function read_escaped_char(in_string) {
                var ch = next(true, in_string);
                switch (ch.charCodeAt(0)) {
                case 110:
                    return "\n";
                case 114:
                    return "\r";
                case 116:
                    return "\t";
                case 98:
                    return "\b";
                case 118:
                    return "\u000b"; // \v
                case 102:
                    return "\f";
                case 48:
                    return String.fromCharCode(0);
                case 120:
                    return String.fromCharCode(hex_bytes(2)); // \x
                case 117:
                    return String.fromCharCode(hex_bytes(4)); // \u
                case 10:
                    return ""; // newline
                default:
                    return ch;
                }
            }

            function with_eof_error(eof_error, cont) {
                return function (x) {
                    try {
                        return cont(x);
                    } catch (ex) {
                        if (ex === EX_EOF) {
                            parse_error(eof_error);
                        } else {
                            throw ex;
                        }
                    }
                };
            }


            function read_escaped_string(signal_eof) {
                // read OctalEscapeSequence (XXX: deprecated if "strict mode")
                // https://github.com/mishoo/UglifyJS/issues/178
                var octal_str = "",
                    reading_octal,
                    ch;

                do {
                    ch = peek();
                    reading_octal = (ch &&
                        (ch >= "0") &&
                        (ch <= "7") &&
                        ((octal_str.length < 2) ||
                            ((octal_str.length === 2) &&
                                (octal_str[0] < "4"))));
                    if (reading_octal) {
                        octal_str += ch;
                        next(signal_eof);
                    }
                } while (reading_octal);
                return octal_str.length ? String.fromCharCode(parseInt(octal_str, 8)) : read_escaped_char(true);
            }

            read_string = with_eof_error("Unterminated string constant", function (quote_char) {
                var quote = next(),
                    str_val = "",
                    str,
                    end_of_string = false,
                    tok;
                do {
                    str = next(true);
                    if (str === "\\") {
                        str_val += read_escaped_string(true);
                    } else if (str !== quote) {
                        str_val += str;
                    } else {
                        end_of_string = true;
                    }
                } while (!end_of_string);
                tok = token("string", str_val);
                tok.quote = quote_char;
                return tok;
            });

            function skip_line_comment(type) {
                var regex_allowed = S.regex_allowed,
                    i = find("\n"),
                    ret;
                if (i === -1) {
                    ret = S.text.substr(S.pos);
                    S.pos = S.text.length;
                } else {
                    ret = S.text.substring(S.pos, i);
                    S.pos = i;
                }
                S.col = S.tokcol + (S.pos - S.tokpos);
                S.comments_before.push(token(type, ret, true));
                S.regex_allowed = regex_allowed;
                return next_token();
            }

            skip_multiline_comment = with_eof_error("Unterminated multiline comment", function () {
                var regex_allowed = S.regex_allowed,
                    i = find("*/", true),
                    text = S.text.substring(S.pos, i),
                    a = text.split("\n"),
                    n = a.length,
                    nlb;
                // update stream position
                S.pos = i + 2;
                S.line += n - 1;
                if (n > 1) {
                    S.col = a[n - 1].length;
                } else {
                    S.col += a[n - 1].length;
                }
                S.col += 2;
                nlb = S.newline_before = S.newline_before || text.indexOf("\n") >= 0;
                S.comments_before.push(token("comment2", text, true));
                S.regex_allowed = regex_allowed;
                S.newline_before = nlb;
                return next_token();
            });

            function read_name() {
                var backslash = false,
                    name = "",
                    ch = peek(),
                    escaped = false,
                    hex;
                while (ch) {
                    if (!backslash) {
                        if (ch === "\\") {
                            escaped = backslash = true;
                            next();
                        } else if (is.identifier_char(ch)) {
                            name += next();
                        } else {
                            break;
                        }
                    } else {
                        if (ch !== "u") {
                            parse_error("Expecting UnicodeEscapeSequence -- uXXXX");
                        }
                        ch = read_escaped_char();
                        if (!is.identifier_char(ch)) {
                            parse_error("Unicode char: " + ch.charCodeAt(0) + " is not valid in identifier");
                        }
                        name += ch;
                        backslash = false;
                    }
                    ch = peek();
                }
                if (predicates.KEYWORDS(name) && escaped) {
                    hex = name.charCodeAt(0).toString(16).toUpperCase();
                    name = "\\u" + "0000".substr(hex.length) + hex + name.slice(1);
                }
                return name;
            }

            read_regexp = with_eof_error("Unterminated regular expression", function (regexp) {
                var prev_backslash = false,
                    in_class = false,
                    mods,
                    ch = next(true);
                while (ch) {
                    if (prev_backslash) {
                        regexp += "\\" + ch;
                        prev_backslash = false;
                    } else if (ch === "\\") {
                        prev_backslash = true;
                    } else if (ch === "[") {
                        in_class = true;
                        regexp += ch;
                    } else if (in_class) {
                        if (ch === "]") {
                            in_class = false;
                        }
                        regexp += ch;
                    } else if (ch !== "/") {
                        regexp += ch;
                    } else {
                        break;
                    }
                    ch = next(true);
                }
                mods = read_name();
                return token("regexp", new RegExp(regexp, mods));
            });

            function read_operator(prefix) {
                function grow(op) {
                    var bigger;
                    if (!peek()) {
                        return op;
                    }
                    bigger = op + peek();
                    if (predicates.OPERATORS(bigger)) {
                        next();
                        return grow(bigger);
                    }
                    return op;
                }
                return token("operator", grow(prefix || next()));
            }

            function handle_slash() {
                next();
                switch (peek()) {
                case "/":
                    next();
                    return skip_line_comment("comment1");
                case "*":
                    next();
                    return skip_multiline_comment();
                }
                if (S.regex_allowed) {
                    return read_regexp("");
                }
                return read_operator("/");
            }

            function handle_dot() {
                next();
                if (is.digit(peek().charCodeAt(0))) {
                    return read_num(".");
                }
                return token("punc", ".");
            }

            function read_word() {
                var word = read_name();
                if (prev_was_dot) {
                    return token("name", word);
                }
                if (predicates.KEYWORDS_ATOM(word)) {
                    return token("atom", word);
                }
                if (!predicates.KEYWORDS(word)) {
                    return token("name", word);
                }
                if (predicates.OPERATORS(word)) {
                    return token("operator", word);
                }
                return token("keyword", word);
            }

            next_token = function (force_regexp) {
                var ch,
                    code;
                if (force_regexp) {
                    return read_regexp(force_regexp);
                }
                skip_whitespace();
                start_token();
                if (html5_comments) {
                    if (looking_at("<!--")) {
                        forward(4);
                        return skip_line_comment("comment3");
                    }
                    if (looking_at("-->") && S.newline_before) {
                        forward(3);
                        return skip_line_comment("comment4");
                    }
                }
                ch = peek();
                if (!ch) {
                    return token("eof");
                }
                code = ch.charCodeAt(0);
                switch (code) {
                case 34:
                case 39:
                    return read_string(ch);
                case 46:
                    return handle_dot();
                case 47:
                    return handle_slash();
                }
                if (is.digit(code)) {
                    return read_num();
                }
                if (predicates.PUNC_CHARS(ch)) {
                    return token("punc", next());
                }
                if (predicates.OPERATOR_CHARS(ch)) {
                    return read_operator();
                }
                if (code === 92 || is.identifier_start(code)) {
                    return read_word();
                }
                parse_error("Unexpected character '" + ch + "'");
            };

            next_token.context = function (nc) {
                if (nc) {
                    S = nc;
                }
                return S;
            };

            return next_token;

        }

        /* -----[ Parser ]----- */

        function parse(AST, $TEXT, options) {
            var S,
                statement,
                function_,
                var_,
                const_,
                new_,
                expr_atom,
                array_,
                object_,
                subscripts,
                maybe_unary,
                expr_op,
                maybe_conditional,
                maybe_assign,
                expression;

            options = defaults(options, {
                strict: false,
                filename: null,
                toplevel: null,
                expression: false,
                html5_comments: true,
                bare_returns: false
            });

            S = {
                input: (typeof $TEXT === "string" ? tokenizer(AST, $TEXT, options.filename, options.html5_comments) : $TEXT),
                token: null,
                prev: null,
                peeked: null,
                in_function: 0,
                in_directives: true,
                in_loop: 0,
                labels: []
            };


            function token_is(type, value) {
                return is.token(S.token, type, value);
            }

            function peek() {
                if (!S.peeked) {
                    S.peeked = S.input();
                }
                return S.peeked;
            }

            function next() {
                S.prev = S.token;
                if (S.peeked) {
                    S.token = S.peeked;
                    S.peeked = null;
                } else {
                    S.token = S.input();
                }
                S.in_directives = S.in_directives && (
                    S.token.type === "string" || token_is("punc", ";")
                );
                return S.token;
            }
            S.token = next();

            function prev() {
                return S.prev;
            }

            function croak(msg, line, col, pos) {
                var ctx = S.input.context();
                line = (line === 0) ? 0 : line || ctx.tokline;
                col = (col === 0) ? 0 : col || ctx.tokcol;
                pos = (pos === 0) ? 0 : pos || ctx.tokpos;

                js_error(msg, ctx.filename, line, col, pos);
            }

            function token_error(token, msg) {
                croak(msg, token.line, token.col);
            }

            function unexpected() {
                var token = S.token;
                token_error(token, "Unexpected token: " + token.type + " (" + token.value + ")");
            }

            function expect_token(type, val) {
                var token = S.token;
                if (token_is(type, val)) {
                    return next();
                }
                token_error(token, "Unexpected token " + token.type + " «" + token.value + "»" + ", expected " + type + " «" + val + "»");
            }

            function expect(punc) {
                return expect_token("punc", punc);
            }

            function can_insert_semicolon() {
                return !options.strict && (
                    S.token.nlb || token_is("eof") || token_is("punc", "}")
                );
            }

            function semicolon() {
                if (token_is("punc", ";")) {
                    next();
                } else if (!can_insert_semicolon()) {
                    unexpected();
                }
            }

            function parenthesised() {
                var exp;
                expect("(");
                exp = expression(true);
                expect(")");
                return exp;
            }

            function embed_tokens(parser) {
                return function () {
                    var start = S.token,
                        expr = parser(),
                        end = prev();
                    expr.start = start;
                    expr.end = end;
                    return expr;
                };
            }

            function handle_regexp() {
                if (token_is("operator", "/") || token_is("operator", "/=")) {
                    S.peeked = null;
                    S.token = S.input(S.token.value.substr(1)); // force regexp
                }
            }

            function simple_statement(tmp) {
                tmp = expression(true);
                semicolon();
                return new AST.SimpleStatement({
                    body: tmp
                });
            }

            function _make_symbol(SymbolType) {
                var token = S.token,
                    name = token.value,
                    obj = {
                        name: String(name),
                        start: token,
                        end: token
                    };
                if (name === "this") {
                    SymbolType = AST.This;
                }
                return new SymbolType(obj);
            }

            function as_symbol(type, noerror) {
                var sym;
                if (!token_is("name")) {
                    if (!noerror) {
                        croak("Name expected");
                    }
                    return null;
                }
                sym = _make_symbol(type);
                next();
                return sym;
            }


            function break_cont(SymbolType) {
                var label = null,
                    ldef,
                    stat;
                if (!can_insert_semicolon()) {
                    label = as_symbol(AST.LabelRef, true);
                }
                if (label) {
                    ldef = find_if(function (l) {
                        return (l.name === label.name);
                    }, S.labels);
                    if (!ldef) {
                        croak("Undefined label " + label.name);
                    }
                    label.thedef = ldef;
                } else if (!S.in_loop) {
                    croak(SymbolType.TYPE + " not inside a loop or switch");
                }
                semicolon();
                stat = new SymbolType({
                    label: label
                });
                if (ldef) {
                    ldef.references.push(stat);
                }
                return stat;
            }

            function in_loop(cont) {
                var ret;
                ++S.in_loop;
                ret = cont();
                --S.in_loop;
                return ret;
            }

            function regular_for(init) {
                var test,
                    step;
                expect(";");
                test = token_is("punc", ";") ? null : expression(true);
                expect(";");
                step = token_is("punc", ")") ? null : expression(true);
                expect(")");
                return new AST.For({
                    init: init,
                    condition: test,
                    step: step,
                    body: in_loop(statement)
                });
            }

            function for_in(init) {
                var lhs = (init instanceof AST.Var) ? init.definitions[0].name : null,
                    obj = expression(true);
                expect(")");
                return new AST.ForIn({
                    init: init,
                    name: lhs,
                    object: obj,
                    body: in_loop(statement)
                });
            }

            function for_() {
                var init = null;
                expect("(");
                if (!token_is("punc", ";")) {
                    if (token_is("keyword", "var")) {
                        next();
                        init = var_(true);
                    } else {
                        init = expression(true, true);
                    }
                    if (token_is("operator", "in")) {
                        if ((init instanceof AST.Var) && (init.definitions.length > 1)) {
                            croak("Only one variable declaration allowed in for..in loop");
                        }
                        next();
                        return for_in(init);
                    }
                }
                return regular_for(init);
            }

            function labeled_statement() {
                var label = as_symbol(AST.Label),
                    stat;
                if (find_if(function (l) {
                        return l.name === label.name;
                    },
                        S.labels)) {
                    // ECMA-262, 12.12: An ECMAScript program is considered
                    // syntactically incorrect if it contains a
                    // LabelledStatement that is enclosed by a
                    // LabelledStatement with the same Identifier as label.
                    croak("Label " + label.name + " defined twice");
                }
                expect(":");
                S.labels.push(label);
                stat = statement();
                S.labels.pop();
                if (!(stat instanceof AST.IterationStatement)) {
                    // check for `continue` that refers to this label.
                    // those should be reported as syntax errors.
                    // https://github.com/mishoo/UglifyJS2/issues/287
                    label.references.forEach(function (ref) {
                        if (ref instanceof AST.Continue) {
                            ref = ref.label.start;
                            croak("Continue label `" + label.name + "` refers to non-IterationStatement.",
                                  ref.line, ref.col, ref.pos);
                        }
                    });
                }
                return new AST.LabeledStatement({
                    body: stat,
                    label: label
                });
            }

            function if_() {
                var cond = parenthesised(),
                    body = statement(),
                    belse = null;
                if (token_is("keyword", "else")) {
                    next();
                    belse = statement();
                }
                return new AST.If({
                    condition: cond,
                    body: body,
                    alternative: belse
                });
            }

            function block_() {
                var a = [];
                expect("{");
                while (!token_is("punc", "}")) {
                    if (token_is("eof")) {
                        unexpected();
                    }
                    a.push(statement());
                }
                next();
                return a;
            }

            function try_() {
                var body = block_(),
                    bcatch = null,
                    bfinally = null,
                    start,
                    name;
                if (token_is("keyword", "catch")) {
                    start = S.token;
                    next();
                    expect("(");
                    name = as_symbol(AST.SymbolCatch);
                    expect(")");
                    bcatch = new AST.Catch({
                        start: start,
                        argname: name,
                        body: block_(),
                        end: prev()
                    });
                }
                if (token_is("keyword", "finally")) {
                    start = S.token;
                    next();
                    bfinally = new AST.Finally({
                        start: start,
                        body: block_(),
                        end: prev()
                    });
                }
                if (!bcatch && !bfinally) {
                    croak("Missing catch/finally blocks");
                }
                return new AST.Try({
                    body: body,
                    bcatch: bcatch,
                    bfinally: bfinally
                });
            }

            function switch_body_() {
                var a = [],
                    cur = null,
                    branch = null,
                    tmp;
                expect("{");
                while (!token_is("punc", "}")) {
                    if (token_is("eof")) {
                        unexpected();
                    }
                    if (token_is("keyword", "case")) {
                        if (branch) {
                            branch.end = prev();
                        }
                        cur = [];
                        tmp = S.token;
                        next();
                        branch = new AST.Case({
                            start: tmp,
                            expression: expression(true),
                            body: cur
                        });
                        a.push(branch);
                        expect(":");
                    } else if (token_is("keyword", "default")) {
                        if (branch) {
                            branch.end = prev();
                        }
                        cur = [];
                        tmp = S.token;
                        next();
                        expect(":");
                        branch = new AST.Default({
                            start: tmp,
                            body: cur
                        });
                        a.push(branch);
                    } else {
                        if (!cur) {
                            unexpected();
                        }
                        cur.push(statement());
                    }
                }
                if (branch) {
                    branch.end = prev();
                }
                next();
                return a;
            }

            statement = embed_tokens(function () {
                var tmp,
                    dir,
                    stat,
                    body;
                handle_regexp();
                switch (S.token.type) {
                case "string":
                    dir = S.in_directives;
                    stat = simple_statement();
                    // XXXv2: decide how to fix directives
                    if (dir && (stat.body instanceof AST.String) && !token_is("punc", ",")) {
                        return new AST.Directive({
                            start: stat.body.start,
                            end: stat.body.end,
                            quote: stat.body.quote,
                            value: stat.body.value
                        });
                    }
                    return stat;
                case "num":
                case "regexp":
                case "operator":
                case "atom":
                    return simple_statement();

                case "name":
                    return is.token(peek(), "punc", ":") ? labeled_statement() : simple_statement();

                case "punc":
                    switch (S.token.value) {
                    case "{":
                        return new AST.BlockStatement({
                            start: S.token,
                            body: block_(),
                            end: prev()
                        });
                    case "[":
                    case "(":
                        return simple_statement();
                    case ";":
                        next();
                        return new AST.EmptyStatement();
                    default:
                        unexpected();
                        break;
                    }
                    break;

                case "keyword":
                    tmp = S.token.value;
                    next();
                    switch (tmp) {
                    case "break":
                        return break_cont(AST.Break);

                    case "continue":
                        return break_cont(AST.Continue);

                    case "debugger":
                        semicolon();
                        return new AST.Debugger();

                    case "do":
                        body = in_loop(statement);
                        expect_token("keyword", "while");
                        tmp = parenthesised();
                        semicolon();
                        return new AST.Do({
                            body: body,
                            condition: tmp
                        });

                    case "while":
                        return new AST.While({
                            condition: parenthesised(),
                            body: in_loop(statement)
                        });

                    case "for":
                        return for_();

                    case "function":
                        return function_(AST.Defun);

                    case "if":
                        return if_();

                    case "return":
                        tmp = null;
                        if (!S.in_function && !options.bare_returns) {
                            croak("'return' outside of function");
                        }
                        if (token_is("punc", ";")) {
                            next();
                        } else if (!can_insert_semicolon()) {
                            tmp = expression(true);
                            semicolon();
                        }

                        return new AST.Return({
                            value: tmp
                        });

                    case "switch":
                        return new AST.Switch({
                            expression: parenthesised(),
                            body: in_loop(switch_body_)
                        });

                    case "throw":
                        if (S.token.nlb) {
                            croak("Illegal newline after 'throw'");
                        }
                        tmp = expression(true);
                        semicolon();
                        return new AST.Throw({
                            value: tmp
                        });

                    case "try":
                        return try_();

                    case "var":
                        tmp = var_();
                        semicolon();
                        return tmp;

                    case "const":
                        tmp = const_();
                        semicolon();
                        return tmp;

                    case "with":
                        return new AST.With({
                            expression: parenthesised(),
                            body: statement()
                        });

                    default:
                        unexpected();
                        break;
                    }
                    break;
                }
            });

            function_ = function (FunctionType) {
                var in_statement = (FunctionType === AST.Defun),
                    name = null;
                if (token_is("name")) {
                    name = as_symbol(in_statement ? AST.SymbolDefun : AST.SymbolLambda);
                }
                if (in_statement && !name) {
                    unexpected();
                }
                expect("(");
                return new FunctionType({
                    name: name,
                    argnames: (function (first, a) {
                        while (!token_is("punc", ")")) {
                            if (first) {
                                first = false;
                            } else {
                                expect(",");
                            }
                            a.push(as_symbol(AST.SymbolFunarg));
                        }
                        next();
                        return a;
                    }(true, [])),
                    body: (function (loop, labels) {
                        var a;
                        ++S.in_function;
                        S.in_directives = true;
                        S.in_loop = 0;
                        S.labels = [];
                        a = block_();
                        --S.in_function;
                        S.in_loop = loop;
                        S.labels = labels;
                        return a;
                    }(S.in_loop, S.labels))
                });
            };

            function vardefs(no_in, in_const) {
                var a = [],
                    name,
                    val;
                while (true) {
                    val = null;
                    name = as_symbol(in_const ? AST.SymbolConst : AST.SymbolVar);
                    if (token_is("operator", "=")) {
                        next();
                        val = expression(false, no_in);
                    }
                    a.push(new AST.VarDef({
                        start: S.token,
                        name: name,
                        value: val,
                        end: prev()
                    }));
                    if (!token_is("punc", ",")) {
                        break;
                    }
                    next();
                }
                return a;
            }


            var_ = function (no_in) {
                return new AST.Var({
                    start: prev(),
                    definitions: vardefs(no_in, false),
                    end: prev()
                });
            };

            const_ = function () {
                return new AST.Const({
                    start: prev(),
                    definitions: vardefs(false, true),
                    end: prev()
                });
            };

            function expr_list(closing, allow_trailing_comma, allow_empty) {
                var first = true,
                    a = [];
                while (!token_is("punc", closing)) {
                    if (first) {
                        first = false;
                    } else {
                        expect(",");
                    }
                    if (allow_trailing_comma && token_is("punc", closing)) {
                        break;
                    }
                    if (token_is("punc", ",") && allow_empty) {
                        a.push(new AST.Hole({
                            start: S.token,
                            end: S.token
                        }));
                    } else {
                        a.push(expression(false));
                    }
                }
                next();
                return a;
            }

            new_ = function () {
                var start = S.token,
                    newexp,
                    args;
                expect_token("operator", "new");
                newexp = expr_atom(false);
                if (token_is("punc", "(")) {
                    next();
                    args = expr_list(")");
                } else {
                    args = [];
                }
                return subscripts(new AST.New({
                    start: start,
                    expression: newexp,
                    args: args,
                    end: prev()
                }), true);
            };

            function as_atom_node() {
                var token = S.token,
                    ret;
                switch (token.type) {
                case "name":
                case "keyword":
                    ret = _make_symbol(AST.SymbolRef);
                    break;
                case "num":
                    ret = new AST.Number({
                        start: token,
                        end: token,
                        value: token.value
                    });
                    break;
                case "string":
                    ret = new AST.String({
                        start: token,
                        end: token,
                        value: token.value,
                        quote: token.quote
                    });
                    break;
                case "regexp":
                    ret = new AST.RegExp({
                        start: token,
                        end: token,
                        value: token.value
                    });
                    break;
                case "atom":
                    switch (token.value) {
                    case "false":
                        ret = new AST.False({
                            start: token,
                            end: token
                        });
                        break;
                    case "true":
                        ret = new AST.True({
                            start: token,
                            end: token
                        });
                        break;
                    case "null":
                        ret = new AST.Null({
                            start: token,
                            end: token
                        });
                        break;
                    }
                    break;
                }
                next();
                return ret;
            }

            expr_atom = function (allow_calls) {
                var start,
                    func,
                    ex;
                if (token_is("operator", "new")) {
                    return new_();
                }
                start = S.token;
                if (token_is("punc")) {
                    switch (start.value) {
                    case "(":
                        next();
                        ex = expression(true);
                        ex.start = start;
                        ex.end = S.token;
                        expect(")");
                        return subscripts(ex, allow_calls);
                    case "[":
                        return subscripts(array_(), allow_calls);
                    case "{":
                        return subscripts(object_(), allow_calls);
                    }
                    unexpected();
                }
                if (token_is("keyword", "function")) {
                    next();
                    func = function_(AST.Function);
                    func.start = start;
                    func.end = prev();
                    return subscripts(func, allow_calls);
                }
                switch (S.token.type) {
                case "atom":
                case "num":
                case "string":
                case "regexp":
                case "name":
                    return subscripts(as_atom_node(), allow_calls);
                }
                unexpected();
            };

            function as_property_name() {
                var tmp = S.token;
                next();
                switch (tmp.type) {
                case "num":
                case "string":
                case "name":
                case "operator":
                case "keyword":
                case "atom":
                    return tmp.value;
                default:
                    unexpected();
                    break;
                }
            }

            array_ = embed_tokens(function () {
                expect("[");
                return new AST.Array({
                    elements: expr_list("]", !options.strict, true)
                });
            });

            object_ = embed_tokens(function () {
                var first = true,
                    a = [],
                    start,
                    type,
                    name,
                    wasPushed;
                expect("{");
                while (!token_is("punc", "}")) {
                    if (first) {
                        first = false;
                    } else {
                        expect(",");
                    }
                    if (!options.strict && token_is("punc", "}")) {
                        // allow trailing comma
                        break;
                    }
                    start = S.token;
                    type = start.type;
                    name = as_property_name();
                    wasPushed = false;
                    if (type === "name" && !token_is("punc", ":")) {
                        if (name === "get") {
                            a.push(new AST.ObjectGetter({
                                start: start,
                                key: as_atom_node(),
                                value: function_(AST.Accessor),
                                end: prev()
                            }));
                            wasPushed = true;
                        } else if (name === "set") {
                            a.push(new AST.ObjectSetter({
                                start: start,
                                key: as_atom_node(),
                                value: function_(AST.Accessor),
                                end: prev()
                            }));
                            wasPushed = true;
                        }
                    }
                    if (!wasPushed) {
                        expect(":");
                        a.push(new AST.ObjectKeyVal({
                            start: start,
                            quote : start.quote,
                            key: name,
                            value: expression(false),
                            end: prev()
                        }));
                    }
                }
                next();
                return new AST.Object({ properties: a });
            });

            function as_name() {
                var tmp = S.token;
                next();
                switch (tmp.type) {
                case "name":
                case "operator":
                case "keyword":
                case "atom":
                    return tmp.value;
                default:
                    unexpected();
                    break;
                }
            }


            subscripts = function (expr, allow_calls) {
                var start = expr.start,
                    prop;
                if (token_is("punc", ".")) {
                    next();
                    return subscripts(new AST.Dot({
                        start: start,
                        expression: expr,
                        property: as_name(),
                        end: prev()
                    }), allow_calls);
                }
                if (token_is("punc", "[")) {
                    next();
                    prop = expression(true);
                    expect("]");
                    return subscripts(new AST.Sub({
                        start: start,
                        expression: expr,
                        property: prop,
                        end: prev()
                    }), allow_calls);
                }
                if (allow_calls && token_is("punc", "(")) {
                    next();
                    return subscripts(new AST.Call({
                        start: start,
                        expression: expr,
                        args: expr_list(")"),
                        end: prev()
                    }), true);
                }
                return expr;
            };


            function is_assignable(expr) {
                if (!options.strict) {
                    return true;
                }
                if (expr instanceof AST.This) {
                    return false;
                }
                return (expr instanceof AST.PropAccess || expr instanceof AST.Symbol);
            }

            function make_unary(UnaryOperatorType, op, expr) {
                if ((op === "++" || op === "--") && !is_assignable(expr)) {
                    croak("Invalid use of " + op + " operator");
                }
                return new UnaryOperatorType({
                    operator: op,
                    expression: expr
                });
            }

            maybe_unary = function (allow_calls) {
                var start = S.token,
                    ex,
                    val;
                if (token_is("operator") && predicates.UNARY_PREFIX(start.value)) {
                    next();
                    handle_regexp();
                    ex = make_unary(AST.UnaryPrefix, start.value, maybe_unary(allow_calls));
                    ex.start = start;
                    ex.end = prev();
                    return ex;
                }
                val = expr_atom(allow_calls);
                while (token_is("operator") && predicates.UNARY_POSTFIX(S.token.value) && !S.token.nlb) {
                    val = make_unary(AST.UnaryPostfix, S.token.value, val);
                    val.start = start;
                    val.end = S.token;
                    next();
                }
                return val;
            };

            expr_op = function (left, min_prec, no_in) {
                var op = token_is("operator") ? S.token.value : null,
                    prec,
                    right;
                if (op === "in" && no_in) {
                    op = null;
                }
                prec = op ? precedence(op) : null;
                if ((prec !== null) && (prec > min_prec)) {
                    next();
                    right = expr_op(maybe_unary(true), prec, no_in);
                    return expr_op(new AST.Binary({
                        start: left.start,
                        left: left,
                        operator: op,
                        right: right,
                        end: right.end
                    }), min_prec, no_in);
                }
                return left;
            };

            function expr_ops(no_in) {
                return expr_op(maybe_unary(true), 0, no_in);
            }

            maybe_conditional = function (no_in) {
                var start = S.token,
                    expr = expr_ops(no_in),
                    yes;
                if (token_is("operator", "?")) {
                    next();
                    yes = expression(false);
                    expect(":");
                    return new AST.Conditional({
                        start: start,
                        condition: expr,
                        consequent: yes,
                        alternative: expression(false, no_in),
                        end: prev()
                    });
                }
                return expr;
            };

            maybe_assign = function (no_in) {
                var start = S.token,
                    left = maybe_conditional(no_in),
                    val = S.token.value;
                if (token_is("operator") && predicates.ASSIGNMENT(val)) {
                    if (is_assignable(left)) {
                        next();
                        return new AST.Assign({
                            start: start,
                            left: left,
                            operator: val,
                            right: maybe_assign(no_in),
                            end: prev()
                        });
                    }
                    croak("Invalid assignment");
                }
                return left;
            };

            expression = function (commas, no_in) {
                var start = S.token,
                    expr = maybe_assign(no_in);
                if (commas && token_is("punc", ",")) {
                    next();
                    return new AST.Seq({
                        start: start,
                        car: expr,
                        cdr: expression(true, no_in),
                        end: peek()
                    });
                }
                return expr;
            };

            if (options.expression) {
                return expression(true);
            }

            return (function () {
                var start = S.token,
                    body = [],
                    end,
                    toplevel;
                while (!token_is("eof")) {
                    body.push(statement());
                }
                end = prev();
                toplevel = options.toplevel;
                if (toplevel) {
                    toplevel.body = toplevel.body.concat(body);
                    toplevel.end = end;
                } else {
                    toplevel = new AST.Toplevel({
                        start: start,
                        body: body,
                        end: end
                    });
                }
                return toplevel;
            }());

        }

        return parse;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "MAP",
    [
        //no dependencies
    ],
    function () {
        
        /*jslint plusplus: true*/
        var skip;

        function AtTop(val) {
            this.v = val;
        }

        function Splice(val) {
            this.v = val;
        }

        function Last(val) {
            this.v = val;
        }

        function MAP(a, f, backwards) {
            var ret = [],
                top = [],
                i;
            function doit() {
                var val = f(a[i], i),
                    is_last = val instanceof Last;
                if (is_last) {
                    val = val.v;
                }
                if (val instanceof AtTop) {
                    val = val.v;
                    if (val instanceof Splice) {
                        top.push.apply(top, backwards ? val.v.slice().reverse() : val.v);
                    } else {
                        top.push(val);
                    }
                } else if (val !== skip) {
                    if (val instanceof Splice) {
                        ret.push.apply(ret, backwards ? val.v.slice().reverse() : val.v);
                    } else {
                        ret.push(val);
                    }
                }
                return is_last;
            }
            if (a instanceof Array) {
                if (backwards) {
                    for (i = a.length - 1; i >= 0; --i) {
                        if (doit()) {
                            break;
                        }
                    }
                    ret.reverse();
                    top.reverse();
                } else {
                    for (i = 0; i < a.length; ++i) {
                        if (doit()) {
                            break;
                        }
                    }
                }
            } else {
                for (i in a) {
                    if (a.hasOwnProperty(i)) {
                        if (doit()) {
                            break;
                        }
                    }
                }
            }
            return top.concat(ret);
        }

        skip = MAP.skip = {};

        MAP.at_top = function (val) {
            return new AtTop(val);
        };

        MAP.splice = function (val) {
            return new Splice(val);
        };

        MAP.last = function (val) {
            return new Last(val);
        };

        return MAP;

    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "Dictionary",
    [
        //no dependencies
    ],
    function () {
        
        /*jslint plusplus: true, nomen: true */

        function Dictionary() {
            this._values = Object.create(null);
            this._size = 0;
        }

        Dictionary.prototype = {
            set: function (key, val) {
                if (!this.has(key)) {
                    ++this._size;
                }
                this._values["$" + key] = val;
                return this;
            },
            add: function (key, val) {
                if (this.has(key)) {
                    this.get(key).push(val);
                } else {
                    this.set(key, [ val ]);
                }
                return this;
            },
            get: function (key) { return this._values["$" + key]; },
            del: function (key) {
                if (this.has(key)) {
                    --this._size;
                    delete this._values["$" + key];
                }
                return this;
            },
            has: function (key) {
                return Object.prototype.hasOwnProperty.call(this._values, "$" + key);
            },
            each: function (f) {
                var i;
                for (i in this._values) {
                    if (Object.prototype.hasOwnProperty.call(this._values, i)) {
                        f(this._values[i], i.substr(1));
                    }
                }
            },
            size: function () {
                return this._size;
            },
            map: function (f) {
                var ret = [],
                    i;
                for (i in this._values) {
                    if (Object.prototype.hasOwnProperty.call(this._values, i)) {
                        ret.push(f(this._values[i], i.substr(1)));
                    }
                }
                return ret;
            }
        };
        return Dictionary;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "merge_sort",
    [
        //no dependencies
    ],
    function () {
        
        function merge_sort(array, cmp) {

            if (array.length < 2) {
                return array.slice();
            }

            function merge(a, b) {
                /*jslint plusplus: true*/
                var r = [],
                    ai = 0,
                    bi = 0,
                    i = 0;
                while (ai < a.length && bi < b.length) {
                    r[i++] = (cmp(a[ai], b[bi]) <= 0) ? a[ai++] : b[bi++];
                }
                if (ai < a.length) {
                    r.push.apply(r, a.slice(ai));
                }
                if (bi < b.length) {
                    r.push.apply(r, b.slice(bi));
                }
                return r;
            }

            function ms(a) {
                var m,
                    left,
                    right;
                if (a.length <= 1) {
                    return a;
                }
                m = Math.floor(a.length / 2);
                left = a.slice(0, m);
                right = a.slice(m);
                left = ms(left);
                right = ms(right);
                return merge(left, right);
            }

            return ms(array);
        }
        return merge_sort;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "add_compress_fns_to_AST",
    [
        "TreeWalker",
        "find_if",
        "get_warn",
        "JS_Parse_Error",
        "precedence",
        "predicates",
        "is",
        "parse",
        "MAP",
        "TreeTransformer",
        "Dictionary",
        "merge_sort",
        "OutputStream",
        "Compressor"
    ],
    function (TreeWalker, find_if, get_warn, JS_Parse_Error, precedence,
        predicates, is, parse, MAP, TreeTransformer, Dictionary,
        merge_sort, OutputStream, Compressor) {
        
        function add_compress_fns_to_AST(AST, warn_callback, croak_callback) {
            /*jslint nomen: true, plusplus: true, unparam: true */

            if (AST.has_compress_support) {
                return;
            }

            function OPT(node, optimizer) {
                node.DEFMETHOD("optimize", function (compressor) {
                    var self = this,
                        opt;
                    if (self._optimized) {
                        return self;
                    }
                    opt = optimizer(self, compressor);
                    opt._optimized = true;
                    if (opt === self) {
                        return opt;
                    }
                    return opt.transform(compressor);
                });
            }

            OPT(AST.Node, function (self) {
                return self;
            });

            AST.Node.DEFMETHOD("equivalent_to", function (node) {
                // XXX: this is a rather expensive way to test two node's equivalence:
                return this.print_to_string() === node.print_to_string();
            });

            function make_node(NodeType, orig, props) {
                if (!props) {
                    props = {};
                }
                if (orig) {
                    if (!props.start) {
                        props.start = orig.start;
                    }
                    if (!props.end) {
                        props.end = orig.end;
                    }
                }
                return new NodeType(props);
            }

            function make_node_from_constant(compressor, val, orig) {
                // XXX: WIP.
                // if (val instanceof AST.Node) {
                //     return val.transform(new TreeTransformer(null, function (node) {
                //         if (node instanceof AST.SymbolRef) {
                //             var scope = compressor.find_parent(AST.Scope);
                //             var def = scope.find_variable(node);
                //             node.thedef = def;
                //             return node;
                //         }
                //     })).transform(compressor);
                // }

                if (val instanceof AST.Node) {
                    return val.transform(compressor);
                }
                switch (typeof val) {
                case "string":
                    return make_node(AST.String, orig, {
                        value: val
                    }).optimize(compressor);
                case "number":
                    return make_node(isNaN(val) ? AST.NaN : AST.Number, orig, {
                        value: val
                    }).optimize(compressor);
                case "boolean":
                    return make_node(val ? AST.True : AST.False, orig).optimize(compressor);
                case "undefined":
                    return make_node(AST.Undefined, orig).optimize(compressor);
                default:
                    if (val === null) {
                        return make_node(AST.Null, orig, {
                            value: null
                        }).optimize(compressor);
                    }
                    if (val instanceof RegExp) {
                        return make_node(AST.RegExp, orig, {
                            value: val
                        }).optimize(compressor);
                    }
                    throw new Error("Can't handle constant of type: " + typeof val);
                }
            }

            function as_statement_array(thing) {
                if (thing === null) {
                    return [];
                }
                if (thing instanceof AST.BlockStatement) {
                    return thing.body;
                }
                if (thing instanceof AST.EmptyStatement) {
                    return [];
                }
                if (thing instanceof AST.Statement) {
                    return [ thing ];
                }
                throw new Error("Can't convert thing to statement array");
            }

            function is_empty(thing) {
                if (thing === null) {
                    return true;
                }
                if (thing instanceof AST.EmptyStatement) {
                    return true;
                }
                if (thing instanceof AST.BlockStatement) {
                    return thing.body.length === 0;
                }
                return false;
            }

            function loop_body(x) {
                if (x instanceof AST.Switch) {
                    return x;
                }
                if ((x instanceof AST.For) || (x instanceof AST.ForIn) || (x instanceof AST.DWLoop)) {
                    return ((x.body instanceof AST.BlockStatement) ? x.body : x);
                }
                return x;
            }

            // tell me if a statement aborts
            function aborts(thing) {
                return thing && thing.aborts();
            }

            function extract_declarations_from_unreachable_code(compressor, stat, target) {
                compressor.warn("Dropping unreachable code [{file}:{line},{col}]", stat.start);
                stat.walk(new TreeWalker(function (node) {
                    if (node instanceof AST.Definitions) {
                        compressor.warn("Declarations in unreachable code! [{file}:{line},{col}]", node.start);
                        node.remove_initializers();
                        target.push(node);
                        return true;
                    }
                    if (node instanceof AST.Defun) {
                        target.push(node);
                        return true;
                    }
                    if (node instanceof AST.Scope) {
                        return true;
                    }
                }));
            }

            function remove(array, el) {
                var i;
                for (i = array.length - 1; i >= 0; --i) {
                    if (array[i] === el) {
                        array.splice(i, 1);
                    }
                }
            }

            function tighten_body(statements, compressor) {
                var CHANGED;

                function process_for_angular(statements) {

                    function has_inject(comment) {
                        return (/@ngInject/).test(comment.value);
                    }

                    function make_arguments_names_list(func) {
                        return func.argnames.map(function (sym) {
                            return make_node(AST.String, sym, {
                                value: sym.name
                            });
                        });
                    }

                    function make_array(orig, elements) {
                        return make_node(AST.Array, orig, {
                            elements: elements
                        });
                    }

                    function make_injector(func, name) {
                        return make_node(AST.SimpleStatement, func, {
                            body: make_node(AST.Assign, func, {
                                operator: "=",
                                left: make_node(AST.Dot, name, {
                                    expression: make_node(AST.SymbolRef, name, name),
                                    property: "$inject"
                                }),
                                right: make_array(func, make_arguments_names_list(func))
                            })
                        });
                    }

                    function check_expression(body) {
                        if (body && body.args) {
                            // if this is a function call check all of arguments passed
                            body.args.forEach(function (argument, index, array) {
                                var comments = argument.start.comments_before;
                                // if the argument is function preceded by @ngInject
                                if ((argument instanceof AST.Lambda) && comments.length && has_inject(comments[0])) {
                                    // replace the function with an array of names of its parameters and function at the end
                                    array[index] = make_array(argument, make_arguments_names_list(argument).concat(argument));
                                }
                            });
                            // if this is chained call check previous one recursively
                            if (body.expression && body.expression.expression) {
                                check_expression(body.expression.expression);
                            }
                        }
                    }

                    return statements.reduce(function (a, stat) {
                        var token,
                            comments,
                            last;
                        a.push(stat);

                        if (stat.body && stat.body.args) {
                            check_expression(stat.body);
                        } else {
                            token = stat.start;
                            comments = token.comments_before;
                            if (comments && comments.length > 0) {
                                last = comments.pop();
                                if (has_inject(last)) {
                                    // case 1: defun
                                    if (stat instanceof AST.Defun) {
                                        a.push(make_injector(stat, stat.name));
                                    } else if (stat instanceof AST.Definitions) {
                                        stat.definitions.forEach(function (def) {
                                            if (def.value && def.value instanceof AST.Lambda) {
                                                a.push(make_injector(def.value, def.name));
                                            }
                                        });
                                    } else {
                                        compressor.warn("Unknown statement marked with @ngInject [{file}:{line},{col}]", token);
                                    }
                                }
                            }
                        }

                        return a;
                    }, []);
                }

                function eliminate_spurious_blocks(statements) {
                    var seen_dirs = [];
                    return statements.reduce(function (a, stat) {
                        if (stat instanceof AST.BlockStatement) {
                            CHANGED = true;
                            a.push.apply(a, eliminate_spurious_blocks(stat.body));
                        } else if (stat instanceof AST.EmptyStatement) {
                            CHANGED = true;
                        } else if (stat instanceof AST.Directive) {
                            if (seen_dirs.indexOf(stat.value) < 0) {
                                a.push(stat);
                                seen_dirs.push(stat.value);
                            } else {
                                CHANGED = true;
                            }
                        } else {
                            a.push(stat);
                        }
                        return a;
                    }, []);
                }

                function handle_if_return(statements, compressor) {
                    /*jslint continue:true*/
                    var self = compressor.self(),
                        in_lambda = (self instanceof AST.Lambda),
                        ret = [],
                        i,
                        stat,
                        cond,
                        ab,
                        lct,
                        body;
                    for (i = statements.length - 1; i >= 0; --i) {
                        stat = statements[i];
                        if (in_lambda && (stat instanceof AST.Return) && !stat.value && (ret.length === 0)) {
                            CHANGED = true;
                            // note, ret.length is probably always zero
                            // because we drop unreachable code before this
                            // step.  nevertheless, it's good to check.
                            continue;
                        }
                        if (stat instanceof AST.If) {
                            if (stat.body instanceof AST.Return) {
                                if (((in_lambda && (ret.length === 0)) ||
                                        ((ret[0] instanceof AST.Return) && !ret[0].value)) &&
                                            (!stat.body.value) &&
                                            (!stat.alternative)) {
                                    CHANGED = true;
                                    cond = make_node(AST.SimpleStatement, stat.condition, {
                                        body: stat.condition
                                    });
                                    ret.unshift(cond);
                                    continue;
                                }
                                if ((ret[0] instanceof AST.Return) && stat.body.value && ret[0].value && !stat.alternative) {
                                    CHANGED = true;
                                    stat = stat.clone();
                                    stat.alternative = ret[0];
                                    ret[0] = stat.transform(compressor);
                                    continue;
                                }
                                if ((ret.length === 0 || (ret[0] instanceof AST.Return)) && stat.body.value && !stat.alternative && in_lambda) {
                                    CHANGED = true;
                                    stat = stat.clone();
                                    stat.alternative = ret[0] || make_node(AST.Return, stat, {
                                        value: make_node(AST.Undefined, stat)
                                    });
                                    ret[0] = stat.transform(compressor);
                                    continue;
                                }
                                if (!stat.body.value && in_lambda) {
                                    CHANGED = true;
                                    stat = stat.clone();
                                    stat.condition = stat.condition.negate(compressor);
                                    stat.body = make_node(AST.BlockStatement, stat, {
                                        body: as_statement_array(stat.alternative).concat(ret)
                                    });
                                    stat.alternative = null;
                                    ret = [ stat.transform(compressor) ];
                                    continue;
                                }
                                if ((ret.length === 1) &&
                                        in_lambda &&
                                        (ret[0] instanceof AST.SimpleStatement) &&
                                        (!stat.alternative ||
                                            (stat.alternative instanceof AST.SimpleStatement))) {
                                    CHANGED = true;
                                    ret.push(make_node(AST.Return, ret[0], {
                                        value: make_node(AST.Undefined, ret[0])
                                    }).transform(compressor));
                                    ret = as_statement_array(stat.alternative).concat(ret);
                                    ret.unshift(stat);
                                    continue;
                                }
                            }

                            ab = aborts(stat.body);
                            lct = ab instanceof AST.LoopControl ? compressor.loopcontrol_target(ab.label) : null;
                            if (ab &&
                                    ((ab instanceof AST.Return && !ab.value && in_lambda) ||
                                        (ab instanceof AST.Continue && self === loop_body(lct)) ||
                                        (ab instanceof AST.Break && lct instanceof AST.BlockStatement && self === lct))) {
                                if (ab.label) {
                                    remove(ab.label.thedef.references, ab);
                                }
                                CHANGED = true;
                                body = as_statement_array(stat.body).slice(0, -1);
                                stat = stat.clone();
                                stat.condition = stat.condition.negate(compressor);
                                stat.body = make_node(AST.BlockStatement, stat, {
                                    body: as_statement_array(stat.alternative).concat(ret)
                                });
                                stat.alternative = make_node(AST.BlockStatement, stat, {
                                    body: body
                                });
                                ret = [ stat.transform(compressor) ];
                                continue;
                            }

                            ab = aborts(stat.alternative);
                            lct = ab instanceof AST.LoopControl ? compressor.loopcontrol_target(ab.label) : null;
                            if (ab &&
                                    ((ab instanceof AST.Return && !ab.value && in_lambda) ||
                                        (ab instanceof AST.Continue && self === loop_body(lct)) ||
                                        (ab instanceof AST.Break && lct instanceof AST.BlockStatement && self === lct))) {
                                if (ab.label) {
                                    remove(ab.label.thedef.references, ab);
                                }
                                CHANGED = true;
                                stat = stat.clone();
                                stat.body = make_node(AST.BlockStatement, stat.body, {
                                    body: as_statement_array(stat.body).concat(ret)
                                });
                                stat.alternative = make_node(AST.BlockStatement, stat.alternative, {
                                    body: as_statement_array(stat.alternative).slice(0, -1)
                                });
                                ret = [ stat.transform(compressor) ];
                                continue;
                            }

                            ret.unshift(stat);
                        } else {
                            ret.unshift(stat);
                        }
                    }
                    return ret;
                }

                function eliminate_dead_code(statements, compressor) {
                    var has_quit = false,
                        orig = statements.length,
                        self = compressor.self();
                    statements = statements.reduce(function (a, stat) {
                        var lct;
                        if (has_quit) {
                            extract_declarations_from_unreachable_code(compressor, stat, a);
                        } else {
                            if (stat instanceof AST.LoopControl) {
                                lct = compressor.loopcontrol_target(stat.label);
                                if (((stat instanceof AST.Break) &&
                                     (lct instanceof AST.BlockStatement) &&
                                     (loop_body(lct) === self)) ||
                                        ((stat instanceof AST.Continue) &&
                                            (loop_body(lct) === self))) {
                                    if (stat.label) {
                                        remove(stat.label.thedef.references, stat);
                                    }
                                } else {
                                    a.push(stat);
                                }
                            } else {
                                a.push(stat);
                            }
                            if (aborts(stat)) {
                                has_quit = true;
                            }
                        }
                        return a;
                    }, []);
                    CHANGED = statements.length !== orig;
                    return statements;
                }

                function sequencesize_2(statements, compressor) {
                    var ret = [],
                        prev = null;
                    function cons_seq(right) {
                        ret.pop();
                        var left = prev.body;
                        if (left instanceof AST.Seq) {
                            left.add(right);
                        } else {
                            left = AST.Seq.cons(left, right);
                        }
                        return left.transform(compressor);
                    }
                    statements.forEach(function (stat) {
                        var opera;
                        if (prev) {
                            if (stat instanceof AST.For) {
                                opera = {};
                                try {
                                    prev.body.walk(new TreeWalker(function (node) {
                                        if ((node instanceof AST.Binary) && (node.operator === "in")) {
                                            throw opera;
                                        }
                                    }));
                                    if (stat.init && !(stat.init instanceof AST.Definitions)) {
                                        stat.init = cons_seq(stat.init);
                                    } else if (!stat.init) {
                                        stat.init = prev.body;
                                        ret.pop();
                                    }
                                } catch (ex) {
                                    if (ex !== opera) {
                                        throw ex;
                                    }
                                }
                            } else if (stat instanceof AST.If) {
                                stat.condition = cons_seq(stat.condition);
                            } else if (stat instanceof AST.With) {
                                stat.expression = cons_seq(stat.expression);
                            } else if (stat instanceof AST.Exit && stat.value) {
                                stat.value = cons_seq(stat.value);
                            } else if (stat instanceof AST.Exit) {
                                stat.value = cons_seq(make_node(AST.Undefined, stat));
                            } else if (stat instanceof AST.Switch) {
                                stat.expression = cons_seq(stat.expression);
                            }
                        }
                        ret.push(stat);
                        prev = (stat instanceof AST.SimpleStatement) ? stat : null;
                    });
                    return ret;
                }

                function sequencesize(statements, compressor) {
                    var seq,
                        ret;
                    if (statements.length < 2) {
                        return statements;
                    }
                    seq = [];
                    ret = [];
                    function push_seq() {
                        seq = AST.Seq.from_array(seq);
                        if (seq) {
                            ret.push(make_node(AST.SimpleStatement, seq, {
                                body: seq
                            }));
                        }
                        seq = [];
                    }
                    statements.forEach(function (stat) {
                        if (stat instanceof AST.SimpleStatement) {
                            seq.push(stat.body);
                        } else {
                            push_seq();
                            ret.push(stat);
                        }
                    });
                    push_seq();
                    ret = sequencesize_2(ret, compressor);
                    CHANGED = (ret.length !== statements.length);
                    return ret;
                }

                function join_consecutive_vars(statements) {
                    var prev = null;
                    return statements.reduce(function (a, stat) {
                        if ((stat instanceof AST.Definitions) && prev && (prev.TYPE === stat.TYPE)) {
                            prev.definitions = prev.definitions.concat(stat.definitions);
                            CHANGED = true;
                        } else if ((stat instanceof AST.For) &&
                                (prev instanceof AST.Definitions) &&
                                (!stat.init || stat.init.TYPE === prev.TYPE)) {
                            CHANGED = true;
                            a.pop();
                            if (stat.init) {
                                stat.init.definitions = prev.definitions.concat(stat.init.definitions);
                            } else {
                                stat.init = prev;
                            }
                            a.push(stat);
                            prev = stat;
                        } else {
                            prev = stat;
                            a.push(stat);
                        }
                        return a;
                    }, []);
                }

                function negate_iifes(statements) {
                    statements.forEach(function (stat) {
                        if (stat instanceof AST.SimpleStatement) {
                            stat.body = (function transform(thing) {
                                return thing.transform(new TreeTransformer(function (node) {
                                    if ((node instanceof AST.Call) && (node.expression instanceof AST.Function)) {
                                        return make_node(AST.UnaryPrefix, node, {
                                            operator: "!",
                                            expression: node
                                        });
                                    }
                                    if (node instanceof AST.Call) {
                                        node.expression = transform(node.expression);
                                    } else if (node instanceof AST.Seq) {
                                        node.car = transform(node.car);
                                    } else if (node instanceof AST.Conditional) {
                                        var expr = transform(node.condition),
                                            tmp;
                                        if (expr !== node.condition) {
                                            // it has been negated, reverse
                                            node.condition = expr;
                                            tmp = node.consequent;
                                            node.consequent = node.alternative;
                                            node.alternative = tmp;
                                        }
                                    }
                                    return node;
                                }));
                            }(stat.body));
                        }
                    });
                }


                do {
                    CHANGED = false;
                    if (compressor.option("angular")) {
                        statements = process_for_angular(statements);
                    }
                    statements = eliminate_spurious_blocks(statements);
                    if (compressor.option("dead_code")) {
                        statements = eliminate_dead_code(statements, compressor);
                    }
                    if (compressor.option("if_return")) {
                        statements = handle_if_return(statements, compressor);
                    }
                    if (compressor.option("sequences")) {
                        statements = sequencesize(statements, compressor);
                    }
                    if (compressor.option("join_vars")) {
                        statements = join_consecutive_vars(statements, compressor);
                    }
                } while (CHANGED);

                if (compressor.option("negate_iife")) {
                    negate_iifes(statements, compressor);
                }

                return statements;

            }

            /* -----[ boolean/negation helpers ]----- */

            // methods to determine whether an expression has a boolean result type
            (function (def) {
                def(AST.Node, function () {
                    return false;
                });
                def(AST.UnaryPrefix, function () {
                    switch (this.operator) {
                    case "!":
                    case "delete":
                        return true;
                    default:
                        return false;
                    }
                });
                def(AST.Binary, function () {
                    switch (this.operator) {
                    case "in":
                    case "instanceof":
                    case "==":
                    case "!=":
                    case "===":
                    case "!==":
                    case "<":
                    case "<=":
                    case ">=":
                    case ">":
                        return true;
                    case "&&":
                    case "||":
                        return this.left.is_boolean() && this.right.is_boolean();
                    default:
                        return false;
                    }
                });
                def(AST.Conditional, function () {
                    return this.consequent.is_boolean() && this.alternative.is_boolean();
                });
                def(AST.Assign, function () {
                    return (this.operator === "=") && this.right.is_boolean();
                });
                def(AST.Seq, function () {
                    return this.cdr.is_boolean();
                });
                def(AST.True, function () {
                    return true;
                });
                def(AST.False, function () {
                    return true;
                });
            }(function (node, func) {
                node.DEFMETHOD("is_boolean", func);
            }));

            // methods to determine if an expression has a string result type
            (function (def) {
                def(AST.Node, function () {
                    return false;
                });
                def(AST.String, function () {
                    return true;
                });
                def(AST.UnaryPrefix, function () {
                    return (this.operator === "typeof");
                });
                def(AST.Binary, function (compressor) {
                    return (this.operator === "+") &&
                        (this.left.is_string(compressor) || this.right.is_string(compressor));
                });
                def(AST.Assign, function (compressor) {
                    return ((this.operator === "=") || (this.operator === "+=")) &&
                        this.right.is_string(compressor);
                });
                def(AST.Seq, function (compressor) {
                    return this.cdr.is_string(compressor);
                });
                def(AST.Conditional, function (compressor) {
                    return (this.consequent.is_string(compressor) &&
                        this.alternative.is_string(compressor));
                });
                def(AST.Call, function (compressor) {
                    return (compressor.option("unsafe") &&
                        (this.expression instanceof AST.SymbolRef) &&
                        (this.expression.name === "String") &&
                        this.expression.undeclared());
                });
            }(function (node, func) {
                node.DEFMETHOD("is_string", func);
            }));

            function best_of(ast1, ast2) {
                return (ast1.print_to_string().length > ast2.print_to_string().length) ? ast2 : ast1;
            }

            // methods to evaluate a constant expression
            (function (def) {
                // The evaluate method returns an array with one or two
                // elements.  If the node has been successfully reduced to a
                // constant, then the second element tells us the value;
                // otherwise the second element is missing.  The first element
                // of the array is always an AST.Node descendant; if
                // evaluation was successful it's a node that represents the
                // constant; otherwise it's the original or a replacement node.
                AST.Node.DEFMETHOD("evaluate", function (compressor) {
                    var val;
                    if (!compressor.option("evaluate")) {
                        return [ this ];
                    }
                    try {
                        val = this._eval(compressor);
                        return [ best_of(make_node_from_constant(compressor, val, this), this), val ];
                    } catch (ex) {
                        if (ex !== def) {
                            throw ex;
                        }
                        return [ this ];
                    }
                });
                def(AST.Statement, function () {
                    throw new Error("Cannot evaluate a statement [" + this.start.file + ":" + this.start.line + "," + this.start.col + "]");
                });
                def(AST.Function, function () {
                    // XXX: AST.Function inherits from AST.Scope, which itself
                    // inherits from AST.Statement; however, an AST.Function
                    // isn't really a statement.  This could bite in other
                    // places too. :-( Wish JS had multiple inheritance.
                    throw def;
                });
                function ev(node, compressor) {
                    if (!compressor) {
                        throw new Error("Compressor must be passed");
                    }

                    return node._eval(compressor);
                }
                def(AST.Node, function () {
                    throw def;          // not constant
                });
                def(AST.Constant, function () {
                    return this.getValue();
                });
                def(AST.UnaryPrefix, function (compressor) {
                    /*jslint bitwise: true*/
                    var e = this.expression;
                    switch (this.operator) {
                    case "!":
                        return !ev(e, compressor);
                    case "typeof":
                        // Function would be evaluated to an array and so typeof would
                        // incorrectly return 'object'. Hence making is a special case.
                        if (e instanceof AST.Function) {
                            return "function";
                        }

                        e = ev(e, compressor);

                        // typeof <RegExp> returns "object" or "function" on different platforms
                        // so cannot evaluate reliably
                        if (e instanceof RegExp) {
                            throw def;
                        }

                        return typeof e;
                    case "void":
                        return void ev(e, compressor);
                    case "~":
                        return ~ev(e, compressor);
                    case "-":
                        e = ev(e, compressor);
                        if (e === 0) {
                            throw def;
                        }
                        return -e;
                    case "+":
                        return +ev(e, compressor);
                    }
                    throw def;
                });
                def(AST.Binary, function (c) {
                    /*jslint bitwise: true, eqeq: true*/
                    var left = this.left,
                        right = this.right;
                    switch (this.operator) {
                    case "&&":
                        return ev(left, c) && ev(right, c);
                    case "||":
                        return ev(left, c) || ev(right, c);
                    case "|":
                        return ev(left, c) | ev(right, c);
                    case "&":
                        return ev(left, c) & ev(right, c);
                    case "^":
                        return ev(left, c) ^ ev(right, c);
                    case "+":
                        return ev(left, c) + ev(right, c);
                    case "*":
                        return ev(left, c) * ev(right, c);
                    case "/":
                        return ev(left, c) / ev(right, c);
                    case "%":
                        return ev(left, c) % ev(right, c);
                    case "-":
                        return ev(left, c) - ev(right, c);
                    case "<<":
                        return ev(left, c) << ev(right, c);
                    case ">>":
                        return ev(left, c) >> ev(right, c);
                    case ">>>":
                        return ev(left, c) >>> ev(right, c);
                    case "==":
                        return ev(left, c) == ev(right, c);
                    case "===":
                        return ev(left, c) === ev(right, c);
                    case "!=":
                        return ev(left, c) != ev(right, c);
                    case "!==":
                        return ev(left, c) !== ev(right, c);
                    case "<":
                        return ev(left, c) < ev(right, c);
                    case "<=":
                        return ev(left, c) <= ev(right, c);
                    case ">":
                        return ev(left, c) > ev(right, c);
                    case ">=":
                        return ev(left, c) >= ev(right, c);
                    case "in":
                        return ev(left, c) in ev(right, c);
                    case "instanceof":
                        return (ev(left, c) instanceof ev(right, c));
                    }
                    throw def;
                });
                def(AST.Conditional, function (compressor) {
                    return ev(this.condition, compressor) ?
                            ev(this.consequent, compressor) :
                            ev(this.alternative, compressor);
                });
                def(AST.SymbolRef, function (compressor) {
                    var d = this.definition();
                    if (d && d.constant && d.init) {
                        return ev(d.init, compressor);
                    }
                    throw def;
                });
                def(AST.Dot, function (compressor) {
                    var str;
                    if (compressor.option("unsafe") && (this.property === "length")) {
                        str = ev(this.expression, compressor);
                        if (typeof str === "string") {
                            return str.length;
                        }
                    }
                    throw def;
                });
            }(function (node, func) {
                node.DEFMETHOD("_eval", func);
            }));

            // method to negate an expression
            (function (def) {
                function basic_negation(exp) {
                    return make_node(AST.UnaryPrefix, exp, {
                        operator: "!",
                        expression: exp
                    });
                }
                def(AST.Node, function () {
                    return basic_negation(this);
                });
                def(AST.Statement, function () {
                    throw new Error("Cannot negate a statement");
                });
                def(AST.Function, function () {
                    return basic_negation(this);
                });
                def(AST.UnaryPrefix, function () {
                    if (this.operator === "!") {
                        return this.expression;
                    }
                    return basic_negation(this);
                });
                def(AST.Seq, function (compressor) {
                    var self = this.clone();
                    self.cdr = self.cdr.negate(compressor);
                    return self;
                });
                def(AST.Conditional, function (compressor) {
                    var self = this.clone();
                    self.consequent = self.consequent.negate(compressor);
                    self.alternative = self.alternative.negate(compressor);
                    return best_of(basic_negation(this), self);
                });
                def(AST.Binary, function (compressor) {
                    var self = this.clone(), op = this.operator;
                    if (compressor.option("unsafe_comps")) {
                        switch (op) {
                        case "<=":
                            self.operator = ">";
                            return self;
                        case "<":
                            self.operator = ">=";
                            return self;
                        case ">=":
                            self.operator = "<";
                            return self;
                        case ">":
                            self.operator = "<=";
                            return self;
                        }
                    }
                    switch (op) {
                    case "==":
                        self.operator = "!=";
                        return self;
                    case "!=":
                        self.operator = "==";
                        return self;
                    case "===":
                        self.operator = "!==";
                        return self;
                    case "!==":
                        self.operator = "===";
                        return self;
                    case "&&":
                        self.operator = "||";
                        self.left = self.left.negate(compressor);
                        self.right = self.right.negate(compressor);
                        return best_of(basic_negation(this), self);
                    case "||":
                        self.operator = "&&";
                        self.left = self.left.negate(compressor);
                        self.right = self.right.negate(compressor);
                        return best_of(basic_negation(this), self);
                    }
                    return basic_negation(this);
                });
            }(function (node, func) {
                node.DEFMETHOD("negate", function (compressor) {
                    return func.call(this, compressor);
                });
            }));

            // determine if expression has side effects
            (function (def) {
                def(AST.Node, function () {
                    return true;
                });

                def(AST.EmptyStatement, function () {
                    return false;
                });
                def(AST.Constant, function () {
                    return false;
                });
                def(AST.This, function () {
                    return false;
                });

                def(AST.Call, function (compressor) {
                    var pure = compressor.option("pure_funcs");
                    if (!pure) {
                        return true;
                    }
                    return pure.indexOf(this.expression.print_to_string()) < 0;
                });

                def(AST.Block, function (compressor) {
                    var i;
                    for (i = this.body.length - 1; i >= 0; --i) {
                        if (this.body[i].has_side_effects(compressor)) {
                            return true;
                        }
                    }
                    return false;
                });

                def(AST.SimpleStatement, function (compressor) {
                    return this.body.has_side_effects(compressor);
                });
                def(AST.Defun, function () {
                    return true;
                });
                def(AST.Function, function () {
                    return false;
                });
                def(AST.Binary, function (compressor) {
                    return this.left.has_side_effects(compressor) ||
                        this.right.has_side_effects(compressor);
                });
                def(AST.Assign, function () {
                    return true;
                });
                def(AST.Conditional, function (compressor) {
                    return this.condition.has_side_effects(compressor) ||
                        this.consequent.has_side_effects(compressor) ||
                        this.alternative.has_side_effects(compressor);
                });
                def(AST.Unary, function (compressor) {
                    switch (this.operator) {
                    case "delete":
                    case "++":
                    case "--":
                        return true;
                    }
                    return this.expression.has_side_effects(compressor);
                });
                def(AST.SymbolRef, function () {
                    return this.global() && this.undeclared();
                });
                def(AST.Object, function (compressor) {
                    var i;
                    for (i = this.properties.length - 1; i >= 0; --i) {
                        if (this.properties[i].has_side_effects(compressor)) {
                            return true;
                        }
                    }
                    return false;
                });
                def(AST.ObjectProperty, function (compressor) {
                    return this.value.has_side_effects(compressor);
                });
                def(AST.Array, function (compressor) {
                    var i;
                    for (i = this.elements.length - 1; i >= 0; --i) {
                        if (this.elements[i].has_side_effects(compressor)) {
                            return true;
                        }
                    }
                    return false;
                });
                def(AST.Dot, function (compressor) {
                    if (!compressor.option("pure_getters")) {
                        return true;
                    }
                    return this.expression.has_side_effects(compressor);
                });
                def(AST.Sub, function (compressor) {
                    if (!compressor.option("pure_getters")) {
                        return true;
                    }
                    return this.expression.has_side_effects(compressor) ||
                        this.property.has_side_effects(compressor);
                });
                def(AST.PropAccess, function (compressor) {
                    return !compressor.option("pure_getters");
                });
                def(AST.Seq, function (compressor) {
                    return this.car.has_side_effects(compressor) ||
                        this.cdr.has_side_effects(compressor);
                });
            }(function (node, func) {
                node.DEFMETHOD("has_side_effects", func);
            }));

            (function (def) {
                def(AST.Statement, function () {
                    return null;
                });
                def(AST.Jump, function () {
                    return this;
                });
                function block_aborts() {
                    /*jshint validthis: true */
                    var body = this.body,
                        n = body.length;
                    return n > 0 && aborts(body[n - 1]);
                }
                def(AST.BlockStatement, block_aborts);
                def(AST.SwitchBranch, block_aborts);
                def(AST.If, function () {
                    return this.alternative && aborts(this.body) && aborts(this.alternative) && this;
                });
            }(function (node, func) {
                node.DEFMETHOD("aborts", func);
            }));

            /* -----[ optimizers ]----- */

            OPT(AST.Directive, function (self) {
                if (self.scope.has_directive(self.value) !== self.scope) {
                    return make_node(AST.EmptyStatement, self);
                }
                return self;
            });

            OPT(AST.Debugger, function (self, compressor) {
                if (compressor.option("drop_debugger")) {
                    return make_node(AST.EmptyStatement, self);
                }
                return self;
            });

            OPT(AST.LabeledStatement, function (self, compressor) {
                if ((self.body instanceof AST.Break) &&
                        (compressor.loopcontrol_target(self.body.label) === self.body)) {
                    return make_node(AST.EmptyStatement, self);
                }
                return self.label.references.length === 0 ? self.body : self;
            });

            OPT(AST.Block, function (self, compressor) {
                self.body = tighten_body(self.body, compressor);
                return self;
            });

            OPT(AST.BlockStatement, function (self, compressor) {
                self.body = tighten_body(self.body, compressor);
                switch (self.body.length) {
                case 1:
                    return self.body[0];
                case 0:
                    return make_node(AST.EmptyStatement, self);
                }
                return self;
            });

            AST.Scope.DEFMETHOD("drop_unused", function (compressor) {
                var self = this,
                    in_use,
                    initializations,
                    scope,
                    tw,
                    tt;
                if (compressor.option("unused") &&
                        !(self instanceof AST.Toplevel) &&
                        !self.uses_eval) {
                    in_use = [];
                    initializations = new Dictionary();
                    // pass 1: find out which symbols are directly used in
                    // this scope (not in nested scopes).
                    scope = this;
                    tw = new TreeWalker(function (node, descend) {
                        var save_scope,
                            def;
                        if (node !== self) {
                            if (node instanceof AST.Defun) {
                                initializations.add(node.name.name, node);
                                return true; // don't go in nested scopes
                            }
                            if (node instanceof AST.Definitions && scope === self) {
                                node.definitions.forEach(function (def) {
                                    if (def.value) {
                                        initializations.add(def.name.name, def.value);
                                        if (def.value.has_side_effects(compressor)) {
                                            def.value.walk(tw);
                                        }
                                    }
                                });
                                return true;
                            }
                            if (node instanceof AST.SymbolRef) {
                                def = node.definition();
                                if (in_use.indexOf(def) === -1) {
                                    in_use.push(def);
                                }
                                return true;
                            }
                            if (node instanceof AST.Scope) {
                                save_scope = scope;
                                scope = node;
                                descend();
                                scope = save_scope;
                                return true;
                            }
                        }
                    });
                    self.walk(tw);

                    // pass 2: for every used symbol we need to walk its
                    // initialization code to figure out if it uses other
                    // symbols (that may not be in_use).
                    (function (in_use, initializations) {
                        var i,
                            j,
                            k,
                            orig,
                            inits,
                            init,
                            def;
                        function twfn(node) {
                            if (node instanceof AST.SymbolRef) {
                                def = node.definition();
                                if (in_use.indexOf(def) === -1) {
                                    in_use.push(def);
                                }
                            }
                        }
                        for (i = 0; i < in_use.length; ++i) {
                            orig = in_use[i].orig;
                            for (j = 0; j < orig.length; ++j) {
                                inits = initializations.get(orig[j].name) || [];
                                for (k = 0; k < inits.length; ++k) {
                                    init = inits[k];
                                    init.walk(new TreeWalker(twfn));
                                }
                            }
                        }
                    }(in_use, initializations));


                    // pass 3: we should drop declarations not in_use
                    tt = new TreeTransformer(function before(node, descend, in_list) {
                        var a,
                            sym,
                            def,
                            side_effects,
                            i,
                            x,
                            body;
                        if ((node instanceof AST.Lambda) && !(node instanceof AST.Accessor)) {
                            if (!compressor.option("keep_fargs")) {
                                a = node.argnames;
                                for (i = a.length - 1; i >= 0; --i) {
                                    sym = a[i];
                                    if (sym.unreferenced()) {
                                        a.pop();
                                        compressor.warn("Dropping unused function argument {name} [{file}:{line},{col}]", {
                                            name: sym.name,
                                            file: sym.start.file,
                                            line: sym.start.line,
                                            col: sym.start.col
                                        });
                                    } else {
                                        break;
                                    }
                                }
                            }
                        }
                        if (node instanceof AST.Defun && node !== self) {
                            if (in_use.indexOf(node.name.definition()) === -1) {
                                compressor.warn("Dropping unused function {name} [{file}:{line},{col}]", {
                                    name: node.name.name,
                                    file: node.name.start.file,
                                    line: node.name.start.line,
                                    col: node.name.start.col
                                });
                                return make_node(AST.EmptyStatement, node);
                            }
                            return node;
                        }
                        if ((node instanceof AST.Definitions) && !(tt.parent() instanceof AST.ForIn)) {
                            def = node.definitions.filter(function (def) {
                                var w;
                                if (in_use.indexOf(def.name.definition()) !== -1) {
                                    return true;
                                }
                                w = {
                                    name: def.name.name,
                                    file: def.name.start.file,
                                    line: def.name.start.line,
                                    col: def.name.start.col
                                };
                                if (def.value && def.value.has_side_effects(compressor)) {
                                    def._unused_side_effects = true;
                                    compressor.warn("Side effects in initialization of unused variable {name} [{file}:{line},{col}]", w);
                                    return true;
                                }
                                compressor.warn("Dropping unused variable {name} [{file}:{line},{col}]", w);
                                return false;
                            });
                            // place uninitialized names at the start
                            def = merge_sort(def, function (a, b) {
                                if (!a.value && b.value) {
                                    return -1;
                                }
                                if (!b.value && a.value) {
                                    return 1;
                                }
                                return 0;
                            });
                            // for unused names whose initialization has
                            // side effects, we can cascade the init. code
                            // into the next one, or next statement.
                            side_effects = [];
                            i = 0;
                            while (i < def.length) {
                                x = def[i];
                                if (x._unused_side_effects) {
                                    side_effects.push(x.value);
                                    def.splice(i, 1);
                                } else {
                                    if (side_effects.length > 0) {
                                        side_effects.push(x.value);
                                        x.value = AST.Seq.from_array(side_effects);
                                        side_effects = [];
                                    }
                                    ++i;
                                }
                            }
                            if (side_effects.length > 0) {
                                side_effects = make_node(AST.BlockStatement, node, {
                                    body: [ make_node(AST.SimpleStatement, node, {
                                        body: AST.Seq.from_array(side_effects)
                                    }) ]
                                });
                            } else {
                                side_effects = null;
                            }
                            if (def.length === 0 && !side_effects) {
                                return make_node(AST.EmptyStatement, node);
                            }
                            if (def.length === 0) {
                                return side_effects;
                            }
                            node.definitions = def;
                            if (side_effects) {
                                side_effects.body.unshift(node);
                                node = side_effects;
                            }
                            return node;
                        }
                        if (node instanceof AST.For) {
                            descend(node, this);

                            if (node.init instanceof AST.BlockStatement) {
                                // certain combination of unused name + side effect leads to:
                                //    https://github.com/mishoo/UglifyJS2/issues/44
                                // that's an invalid AST.
                                // We fix it at this stage by moving the `var` outside the `for`.

                                body = node.init.body.slice(0, -1);
                                node.init = node.init.body.slice(-1)[0].body;
                                body.push(node);

                                return in_list ? MAP.splice(body) : make_node(AST.BlockStatement, node, {
                                    body: body
                                });
                            }
                        }
                        if ((node instanceof AST.Scope) && (node !== self)) {
                            return node;
                        }
                    });
                    self.transform(tt);
                }
            });

            AST.Scope.DEFMETHOD("hoist_declarations", function (compressor) {
                /*jslint continue:true*/
                var hoist_funs = compressor.option("hoist_funs"),
                    hoist_vars = compressor.option("hoist_vars"),
                    self = this,
                    dirs,
                    hoisted,
                    vars,
                    vars_found,
                    var_decl,
                    tt,
                    def,
                    defs,
                    expr,
                    sym,
                    assign,
                    tmp;
                if (hoist_funs || hoist_vars) {
                    dirs = [];
                    hoisted = [];
                    vars = new Dictionary();
                    vars_found = 0;
                    var_decl = 0;
                    // let's count var_decl first, we seem to waste a lot of
                    // space if we hoist `var` when there's only one.
                    self.walk(new TreeWalker(function (node) {
                        if ((node instanceof AST.Scope) && (node !== self)) {
                            return true;
                        }
                        if (node instanceof AST.Var) {
                            ++var_decl;
                            return true;
                        }
                    }));
                    hoist_vars = hoist_vars && var_decl > 1;
                    tt = new TreeTransformer(
                        function before(node) {
                            var seq,
                                p;
                            if (node !== self) {
                                if (node instanceof AST.Directive) {
                                    dirs.push(node);
                                    return make_node(AST.EmptyStatement, node);
                                }
                                if (node instanceof AST.Defun && hoist_funs) {
                                    hoisted.push(node);
                                    return make_node(AST.EmptyStatement, node);
                                }
                                if (node instanceof AST.Var && hoist_vars) {
                                    node.definitions.forEach(function (def) {
                                        vars.set(def.name.name, def);
                                        ++vars_found;
                                    });
                                    seq = node.to_assignments();
                                    p = tt.parent();
                                    if ((p instanceof AST.ForIn) && (p.init === node)) {
                                        if (seq === null) {
                                            return node.definitions[0].name;
                                        }
                                        return seq;
                                    }
                                    if ((p instanceof AST.For) && (p.init === node)) {
                                        return seq;
                                    }
                                    if (!seq) {
                                        return make_node(AST.EmptyStatement, node);
                                    }
                                    return make_node(AST.SimpleStatement, node, {
                                        body: seq
                                    });
                                }
                                if (node instanceof AST.Scope) {
                                    return node; // to avoid descending in nested scopes
                                }
                            }
                        }
                    );
                    self = self.transform(tt);
                    if (vars_found > 0) {
                        // collect only vars which don't show up in self's arguments list
                        defs = [];
                        vars.each(function (def, name) {
                            if ((self instanceof AST.Lambda) &&
                                    find_if(function (x) {
                                        return (x.name === def.name.name);
                                    }, self.argnames)) {
                                vars.del(name);
                            } else {
                                def = def.clone();
                                def.value = null;
                                defs.push(def);
                                vars.set(name, def);
                            }
                        });
                        if (defs.length > 0) {
                            // try to merge in assignments
                            while (self.body.length) {
                                if (self.body[0] instanceof AST.SimpleStatement) {
                                    expr = self.body[0].body;
                                    if ((expr instanceof AST.Assign) && (expr.operator === "=")) {
                                        sym = expr.left;
                                        if ((sym instanceof AST.Symbol) && vars.has(sym.name)) {
                                            def = vars.get(sym.name);
                                            if (def.value) {
                                                break;
                                            }
                                            def.value = expr.right;
                                            remove(defs, def);
                                            defs.push(def);
                                            self.body.splice(0, 1);
                                            continue;
                                        }
                                    }
                                    if (expr instanceof AST.Seq) {
                                        assign = expr.car;
                                        if ((assign instanceof AST.Assign) && (assign.operator === "=")) {
                                            sym = assign.left;
                                            if ((sym instanceof AST.Symbol) && vars.has(sym.name)) {
                                                def = vars.get(sym.name);
                                                if (def.value) {
                                                    break;
                                                }
                                                def.value = assign.right;
                                                remove(defs, def);
                                                defs.push(def);
                                                self.body[0].body = expr.cdr;
                                                continue;
                                            }
                                        }
                                    }
                                }
                                if (self.body[0] instanceof AST.EmptyStatement) {
                                    self.body.splice(0, 1);
                                    continue;
                                }
                                if (self.body[0] instanceof AST.BlockStatement) {
                                    tmp = [0, 1].concat(self.body[0].body);
                                    self.body.splice.apply(self.body, tmp);
                                    continue;
                                }
                                break;
                            }
                            defs = make_node(AST.Var, self, {
                                definitions: defs
                            });
                            hoisted.push(defs);
                        }
                    }
                    self.body = dirs.concat(hoisted, self.body);
                }
                return self;
            });

            OPT(AST.SimpleStatement, function (self, compressor) {
                if (compressor.option("side_effects")) {
                    if (!self.body.has_side_effects(compressor)) {
                        compressor.warn("Dropping side-effect-free statement [{file}:{line},{col}]", self.start);
                        return make_node(AST.EmptyStatement, self);
                    }
                }
                return self;
            });

            OPT(AST.DWLoop, function (self, compressor) {
                var cond = self.condition.evaluate(compressor),
                    a;
                self.condition = cond[0];
                if (!compressor.option("loops")) {
                    return self;
                }
                if (cond.length > 1) {
                    if (cond[1]) {
                        return make_node(AST.For, self, {
                            body: self.body
                        });
                    }
                    if (self instanceof AST.While) {
                        if (compressor.option("dead_code")) {
                            a = [];
                            extract_declarations_from_unreachable_code(compressor, self.body, a);
                            return make_node(AST.BlockStatement, self, {
                                body: a
                            });
                        }
                    }
                }
                return self;
            });

            function if_break_in_loop(self, compressor) {
                var first;
                function drop_it(rest) {
                    rest = as_statement_array(rest);
                    if (self.body instanceof AST.BlockStatement) {
                        self.body = self.body.clone();
                        self.body.body = rest.concat(self.body.body.slice(1));
                        self.body = self.body.transform(compressor);
                    } else {
                        self.body = make_node(AST.BlockStatement, self.body, {
                            body: rest
                        }).transform(compressor);
                    }
                    if_break_in_loop(self, compressor);
                }
                first = (self.body instanceof AST.BlockStatement) ? self.body.body[0] : self.body;
                if (first instanceof AST.If) {
                    if ((first.body instanceof AST.Break) &&
                            compressor.loopcontrol_target(first.body.label) === self) {
                        if (self.condition) {
                            self.condition = make_node(AST.Binary, self.condition, {
                                left: self.condition,
                                operator: "&&",
                                right: first.condition.negate(compressor)
                            });
                        } else {
                            self.condition = first.condition.negate(compressor);
                        }
                        drop_it(first.alternative);
                    } else if ((first.alternative instanceof AST.Break) &&
                            (compressor.loopcontrol_target(first.alternative.label) === self)) {
                        if (self.condition) {
                            self.condition = make_node(AST.Binary, self.condition, {
                                left: self.condition,
                                operator: "&&",
                                right: first.condition
                            });
                        } else {
                            self.condition = first.condition;
                        }
                        drop_it(first.body);
                    }
                }
            }

            OPT(AST.While, function (self, compressor) {
                if (!compressor.option("loops")) {
                    return self;
                }
                self = AST.DWLoop.prototype.optimize.call(self, compressor);
                if (self instanceof AST.While) {
                    if_break_in_loop(self, compressor);
                    self = make_node(AST.For, self, self).transform(compressor);
                }
                return self;
            });

            OPT(AST.For, function (self, compressor) {
                var cond = self.condition,
                    a;
                if (cond) {
                    cond = cond.evaluate(compressor);
                    self.condition = cond[0];
                }
                if (!compressor.option("loops")) {
                    return self;
                }
                if (cond) {
                    if (cond.length > 1 && !cond[1]) {
                        if (compressor.option("dead_code")) {
                            a = [];
                            if (self.init instanceof AST.Statement) {
                                a.push(self.init);
                            } else if (self.init) {
                                a.push(make_node(AST.SimpleStatement, self.init, {
                                    body: self.init
                                }));
                            }
                            extract_declarations_from_unreachable_code(compressor, self.body, a);
                            return make_node(AST.BlockStatement, self, {
                                body: a
                            });
                        }
                    }
                }
                if_break_in_loop(self, compressor);
                return self;
            });

            OPT(AST.If, function (self, compressor) {
                var cond,
                    a,
                    negated,
                    negated_is_best,
                    tmp,
                    body,
                    alt;
                if (!compressor.option("conditionals")) {
                    return self;
                }
                // if condition can be statically determined, warn and drop
                // one of the blocks.  note, statically determined implies
                // “has no side effects”; also it doesn't work for cases like
                // `x && true`, though it probably should.
                cond = self.condition.evaluate(compressor);
                self.condition = cond[0];
                if (cond.length > 1) {
                    if (cond[1]) {
                        compressor.warn("Condition always true [{file}:{line},{col}]", self.condition.start);
                        if (compressor.option("dead_code")) {
                            a = [];
                            if (self.alternative) {
                                extract_declarations_from_unreachable_code(compressor, self.alternative, a);
                            }
                            a.push(self.body);
                            return make_node(AST.BlockStatement, self, {
                                body: a
                            }).transform(compressor);
                        }
                    } else {
                        compressor.warn("Condition always false [{file}:{line},{col}]", self.condition.start);
                        if (compressor.option("dead_code")) {
                            a = [];
                            extract_declarations_from_unreachable_code(compressor, self.body, a);
                            if (self.alternative) {
                                a.push(self.alternative);
                            }
                            return make_node(AST.BlockStatement, self, {
                                body: a
                            }).transform(compressor);
                        }
                    }
                }
                if (is_empty(self.alternative)) {
                    self.alternative = null;
                }
                negated = self.condition.negate(compressor);
                negated_is_best = best_of(self.condition, negated) === negated;
                if (self.alternative && negated_is_best) {
                    negated_is_best = false; // because we already do the switch here.
                    self.condition = negated;
                    tmp = self.body;
                    self.body = self.alternative || make_node(AST.EmptyStatement);
                    self.alternative = tmp;
                }
                if (is_empty(self.body) && is_empty(self.alternative)) {
                    return make_node(AST.SimpleStatement, self.condition, {
                        body: self.condition
                    }).transform(compressor);
                }
                if ((self.body instanceof AST.SimpleStatement) &&
                        (self.alternative instanceof AST.SimpleStatement)) {
                    return make_node(AST.SimpleStatement, self, {
                        body: make_node(AST.Conditional, self, {
                            condition: self.condition,
                            consequent: self.body.body,
                            alternative: self.alternative.body
                        })
                    }).transform(compressor);
                }
                if (is_empty(self.alternative) && self.body instanceof AST.SimpleStatement) {
                    if (negated_is_best) {
                        return make_node(AST.SimpleStatement, self, {
                            body: make_node(AST.Binary, self, {
                                operator: "||",
                                left: negated,
                                right: self.body.body
                            })
                        }).transform(compressor);
                    }
                    return make_node(AST.SimpleStatement, self, {
                        body: make_node(AST.Binary, self, {
                            operator: "&&",
                            left: self.condition,
                            right: self.body.body
                        })
                    }).transform(compressor);
                }
                if ((self.body instanceof AST.EmptyStatement) &&
                        self.alternative &&
                        (self.alternative instanceof AST.SimpleStatement)) {
                    return make_node(AST.SimpleStatement, self, {
                        body: make_node(AST.Binary, self, {
                            operator: "||",
                            left: self.condition,
                            right: self.alternative.body
                        })
                    }).transform(compressor);
                }
                if ((self.body instanceof AST.Exit) &&
                        (self.alternative instanceof AST.Exit) &&
                        (self.body.TYPE === self.alternative.TYPE)) {
                    return make_node(self.body.CTOR, self, {
                        value: make_node(AST.Conditional, self, {
                            condition: self.condition,
                            consequent: self.body.value || make_node(AST.Undefined, self.body).optimize(compressor),
                            alternative: self.alternative.value || make_node(AST.Undefined, self.alternative).optimize(compressor)
                        })
                    }).transform(compressor);
                }
                if ((self.body instanceof AST.If) &&
                        !self.body.alternative &&
                        !self.alternative) {
                    self.condition = make_node(AST.Binary, self.condition, {
                        operator: "&&",
                        left: self.condition,
                        right: self.body.condition
                    }).transform(compressor);
                    self.body = self.body.body;
                }
                if (aborts(self.body)) {
                    if (self.alternative) {
                        alt = self.alternative;
                        self.alternative = null;
                        return make_node(AST.BlockStatement, self, {
                            body: [ self, alt ]
                        }).transform(compressor);
                    }
                }
                if (aborts(self.alternative)) {
                    body = self.body;
                    self.body = self.alternative;
                    self.condition = negated_is_best ? negated : self.condition.negate(compressor);
                    self.alternative = null;
                    return make_node(AST.BlockStatement, self, {
                        body: [ self, body ]
                    }).transform(compressor);
                }
                return self;
            });

            OPT(AST.Switch, function (self, compressor) {
                var last_branch,
                    stat,
                    exp1,
                    value,
                    in_if,
                    in_block,
                    started,
                    stopped,
                    ruined,
                    tt,
                    done;
                if ((self.body.length === 0) && compressor.option("conditionals")) {
                    return make_node(AST.SimpleStatement, self, {
                        body: self.expression
                    }).transform(compressor);
                }
                done = false;
                while (!done) {
                    last_branch = self.body[self.body.length - 1];
                    if (last_branch) {
                        stat = last_branch.body[last_branch.body.length - 1]; // last statement
                        if ((stat instanceof AST.Break) && (loop_body(compressor.loopcontrol_target(stat.label)) === self)) {
                            last_branch.body.pop();
                        }
                        if ((last_branch instanceof AST.Default) && (last_branch.body.length === 0)) {
                            self.body.pop();
                        } else {
                            done = true;
                        }
                    } else {
                        done = true;
                    }
                }
                exp1 = self.expression.evaluate(compressor);

                if (exp1.length === 2) {
                    try {
                        // constant expression
                        self.expression = exp1[0];
                        if (compressor.option("dead_code")) {
                            value = exp1[1];
                            in_if = false;
                            in_block = false;
                            started = false;
                            stopped = false;
                            ruined = false;
                            tt = new TreeTransformer(function (node, descend, in_list) {
                                var save,
                                    exp;
                                if ((node instanceof AST.Lambda) || (node instanceof AST.SimpleStatement)) {
                                    // no need to descend these node types
                                    return node;
                                }
                                if (node instanceof AST.Switch && node === self) {
                                    node = node.clone();
                                    descend(node, this);
                                    return ruined ? node : make_node(AST.BlockStatement, node, {
                                        body: node.body.reduce(function (a, branch) {
                                            return a.concat(branch.body);
                                        }, [])
                                    }).transform(compressor);
                                }
                                if ((node instanceof AST.If) || (node instanceof AST.Try)) {
                                    save = in_if;
                                    in_if = !in_block;
                                    descend(node, this);
                                    in_if = save;
                                    return node;
                                }
                                if ((node instanceof AST.StatementWithBody) || (node instanceof AST.Switch)) {
                                    save = in_block;
                                    in_block = true;
                                    descend(node, this);
                                    in_block = save;
                                    return node;
                                }
                                if ((node instanceof AST.Break) && (this.loopcontrol_target(node.label) === self)) {
                                    if (in_if) {
                                        ruined = true;
                                        return node;
                                    }
                                    if (in_block) {
                                        return node;
                                    }
                                    stopped = true;
                                    return in_list ? MAP.skip : make_node(AST.EmptyStatement, node);
                                }
                                if ((node instanceof AST.SwitchBranch) && (this.parent() === self)) {
                                    if (stopped) {
                                        return MAP.skip;
                                    }
                                    if (node instanceof AST.Case) {
                                        exp = node.expression.evaluate(compressor);
                                        if (exp.length < 2) {
                                            // got a case with non-constant expression, baling out
                                            throw self;
                                        }
                                        if (exp[1] === value || started) {
                                            started = true;
                                            if (aborts(node)) {
                                                stopped = true;
                                            }
                                            descend(node, this);
                                            return node;
                                        }
                                        return MAP.skip;
                                    }
                                    descend(node, this);
                                    return node;
                                }
                            });
                            tt.stack = compressor.stack.slice(); // so that's able to see parent nodes
                            self = self.transform(tt);
                        }
                    } catch (ex) {
                        if (ex !== self) {
                            throw ex;
                        }
                    }
                }
                return self;
            });

            OPT(AST.Case, function (self, compressor) {
                self.body = tighten_body(self.body, compressor);
                return self;
            });

            OPT(AST.Try, function (self, compressor) {
                self.body = tighten_body(self.body, compressor);
                return self;
            });

            AST.Definitions.DEFMETHOD("remove_initializers", function () {
                this.definitions.forEach(function (def) {
                    def.value = null;
                });
            });

            AST.Definitions.DEFMETHOD("to_assignments", function () {
                var assignments = this.definitions.reduce(function (a, def) {
                    if (def.value) {
                        var name = make_node(AST.SymbolRef, def.name, def.name);
                        a.push(make_node(AST.Assign, def, {
                            operator: "=",
                            left: name,
                            right: def.value
                        }));
                    }
                    return a;
                }, []);
                if (assignments.length === 0) {
                    return null;
                }
                return AST.Seq.from_array(assignments);
            });

            OPT(AST.Definitions, function (self) {
                if (self.definitions.length === 0) {
                    return make_node(AST.EmptyStatement, self);
                }
                return self;
            });

            OPT(AST.Function, function (self, compressor) {
                self = AST.Lambda.prototype.optimize.call(self, compressor);
                if (compressor.option("unused") && !compressor.option("keep_fnames")) {
                    if (self.name && self.name.unreferenced()) {
                        self.name = null;
                    }
                }
                return self;
            });

            function all(array, predicate) {
                var i;
                for (i = array.length - 1; i >= 0; --i) {
                    if (!predicate(array[i])) {
                        return false;
                    }
                }
                return true;
            }

            OPT(AST.Call, function (self, compressor) {
                var exp,
                    code,
                    ast,
                    comp,
                    fun,
                    args,
                    separator,
                    elements,
                    first,
                    node;
                if (compressor.option("unsafe")) {
                    exp = self.expression;
                    if (exp instanceof AST.SymbolRef && exp.undeclared()) {
                        switch (exp.name) {
                        case "Array":
                            if (self.args.length !== 1) {
                                return make_node(AST.Array, self, {
                                    elements: self.args
                                }).transform(compressor);
                            }
                            break;
                        case "Object":
                            if (self.args.length === 0) {
                                return make_node(AST.Object, self, {
                                    properties: []
                                });
                            }
                            break;
                        case "String":
                            if (self.args.length === 0) {
                                return make_node(AST.String, self, {
                                    value: ""
                                });
                            }
                            if (self.args.length <= 1) {
                                return make_node(AST.Binary, self, {
                                    left: self.args[0],
                                    operator: "+",
                                    right: make_node(AST.String, self, {
                                        value: ""
                                    })
                                }).transform(compressor);
                            }
                            break;
                        case "Number":
                            if (self.args.length === 0) {
                                return make_node(AST.Number, self, {
                                    value: 0
                                });
                            }
                            if (self.args.length === 1) {
                                return make_node(AST.UnaryPrefix, self, {
                                    expression: self.args[0],
                                    operator: "+"
                                }).transform(compressor);
                            }
                            break;
                        case "Boolean":
                            if (self.args.length === 0) {
                                return make_node(AST.False, self);
                            }
                            if (self.args.length === 1) {
                                return make_node(AST.UnaryPrefix, self, {
                                    expression: make_node(AST.UnaryPrefix, null, {
                                        expression: self.args[0],
                                        operator: "!"
                                    }),
                                    operator: "!"
                                }).transform(compressor);
                            }
                            break;
                        case "Function":
                            // new Function() => function(){}
                            if (self.args.length === 0) {
                                return make_node(AST.Function, self, {
                                    argnames: [],
                                    body: []
                                });
                            }
                            if (all(self.args, function (x) {
                                    return x instanceof AST.String;
                                })) {
                                // quite a corner-case, but we can handle it:
                                //   https://github.com/mishoo/UglifyJS2/issues/203
                                // if the code argument is a constant, then we can minify it.
                                try {
                                    code = "(function (" + self.args.slice(0, -1).map(function (arg) {
                                        return arg.value;
                                    }).join(",") + ") {" + self.args[self.args.length - 1].value + "})()";
                                    ast = parse(code);
                                    ast.figure_out_scope({
                                        screw_ie8: compressor.option("screw_ie8")
                                    });
                                    comp = new Compressor(compressor.options, undefined, get_warn(warn_callback), croak_callback);
                                    ast = ast.transform(comp);
                                    ast.figure_out_scope({
                                        screw_ie8: compressor.option("screw_ie8")
                                    });
                                    ast.mangle_names();
                                    try {
                                        ast.walk(new TreeWalker(function (node) {
                                            if (node instanceof AST.Lambda) {
                                                fun = node;
                                                throw ast;
                                            }
                                        }));
                                    } catch (ex) {
                                        if (ex !== ast) {
                                            throw ex;
                                        }
                                    }
                                    if (!fun) {
                                        return self;
                                    }
                                    args = fun.argnames.map(function (arg, i) {
                                        return make_node(AST.String, self.args[i], {
                                            value: arg.print_to_string()
                                        });
                                    });
                                    code = new OutputStream();
                                    AST.BlockStatement.prototype._codegen.call(fun, fun, code);
                                    code = code.toString().replace(/^\{|\}$/g, "");
                                    args.push(make_node(AST.String, self.args[self.args.length - 1], {
                                        value: code
                                    }));
                                    self.args = args;
                                    return self;
                                } catch (ex) {
                                    if (ex instanceof JS_Parse_Error) {
                                        compressor.warn("Error parsing code passed to new Function [{file}:{line},{col}]", self.args[self.args.length - 1].start);
                                        compressor.warn(ex.toString());
                                    } else if (typeof warn_callback === "function") {
                                        warn_callback(ex);
                                        throw ex;
                                    }
                                }
                            }
                            break;
                        }
                    } else if ((exp instanceof AST.Dot) && (exp.property === "toString") && (self.args.length === 0)) {
                        return make_node(AST.Binary, self, {
                            left: make_node(AST.String, self, {
                                value: ""
                            }),
                            operator: "+",
                            right: exp.expression
                        }).transform(compressor);
                    }
                    if ((exp instanceof AST.Dot) && (exp.expression instanceof AST.Array) && (exp.property === "join")) {
                        separator = self.args.length === 0 ? "," : self.args[0].evaluate(compressor)[1];
                        if (separator) {
                            elements = exp.expression.elements.reduce(function (a, el) {
                                var last,
                                    val;
                                el = el.evaluate(compressor);
                                if (a.length === 0 || el.length === 1) {
                                    a.push(el);
                                } else {
                                    last = a[a.length - 1];
                                    if (last.length === 2) {
                                        // it's a constant
                                        val = String(last[1] + separator + el[1]);
                                        a[a.length - 1] = [ make_node_from_constant(compressor, val, last[0]), val ];
                                    } else {
                                        a.push(el);
                                    }
                                }
                                return a;
                            }, []);
                            if (elements.length === 0) {
                                return make_node(AST.String, self, {
                                    value: ""
                                });
                            }
                            if (elements.length === 1) {
                                return elements[0][0];
                            }
                            if (separator === "") {
                                if (elements[0][0] instanceof AST.String ||
                                        elements[1][0] instanceof AST.String) {
                                    first = elements.shift()[0];
                                } else {
                                    first = make_node(AST.String, self, {
                                        value: ""
                                    });
                                }
                                return elements.reduce(function (prev, el) {
                                    return make_node(AST.Binary, el[0], {
                                        operator: "+",
                                        left: prev,
                                        right: el[0]
                                    });
                                }, first).transform(compressor);
                            }
                            // need this awkward cloning to not affect original element
                            // best_of will decide which one to get through.
                            node = self.clone();
                            node.expression = node.expression.clone();
                            node.expression.expression = node.expression.expression.clone();
                            node.expression.expression.elements = elements.map(function (el) {
                                return el[0];
                            });
                            return best_of(self, node);
                        }

                    }
                }
                if (compressor.option("side_effects")) {
                    if ((self.expression instanceof AST.Function) &&
                            (self.args.length === 0) &&
                            !AST.Block.prototype.has_side_effects.call(self.expression, compressor)) {
                        return make_node(AST.Undefined, self).transform(compressor);
                    }
                }
                if (compressor.option("drop_console")) {
                    if (self.expression instanceof AST.PropAccess) {
                        exp = self.expression.expression;
                        while (exp.expression) {
                            exp = exp.expression;
                        }
                        if ((exp instanceof AST.SymbolRef) &&
                                (exp.name === "console") &&
                                exp.undeclared()) {
                            return make_node(AST.Undefined, self).transform(compressor);
                        }
                    }
                }
                return self.evaluate(compressor)[0];
            });

            OPT(AST.New, function (self, compressor) {
                var exp;
                if (compressor.option("unsafe")) {
                    exp = self.expression;
                    if (exp instanceof AST.SymbolRef && exp.undeclared()) {
                        switch (exp.name) {
                        case "Object":
                        case "RegExp":
                        case "Function":
                        case "Error":
                        case "Array":
                            return make_node(AST.Call, self, self).transform(compressor);
                        }
                    }
                }
                return self;
            });

            OPT(AST.Seq, function (self, compressor) {
                if (!compressor.option("side_effects")) {
                    return self;
                }
                if (!self.car.has_side_effects(compressor)) {
                    // we shouldn't compress (1,eval)(something) to
                    // eval(something) because that changes the meaning of
                    // eval (becomes lexical instead of global).
                    var p;
                    if (!(self.cdr instanceof AST.SymbolRef) ||
                            (self.cdr.name !== "eval") ||
                            !self.cdr.undeclared()) {
                        p = compressor.parent();
                        if ((p instanceof AST.Call) && (p.expression === self)) {
                            return self.cdr;
                        }
                    }
                }
                if (compressor.option("cascade")) {
                    if ((self.car instanceof AST.Assign) &&
                            !self.car.left.has_side_effects(compressor)) {
                        if (self.car.left.equivalent_to(self.cdr)) {
                            return self.car;
                        }
                        if ((self.cdr instanceof AST.Call) &&
                                self.cdr.expression.equivalent_to(self.car.left)) {
                            self.cdr.expression = self.car;
                            return self.cdr;
                        }
                    }
                    if (!self.car.has_side_effects(compressor) &&
                            !self.cdr.has_side_effects(compressor) &&
                            self.car.equivalent_to(self.cdr)) {
                        return self.car;
                    }
                }
                if ((self.cdr instanceof AST.UnaryPrefix) &&
                        (self.cdr.operator === "void") &&
                        !self.cdr.expression.has_side_effects(compressor)) {
                    self.cdr.expression = self.car;
                    return self.cdr;
                }
                if (self.cdr instanceof AST.Undefined) {
                    return make_node(AST.UnaryPrefix, self, {
                        operator: "void",
                        expression: self.car
                    });
                }
                return self;
            });

            AST.Unary.DEFMETHOD("lift_sequences", function (compressor) {
                var seq,
                    x;
                if (compressor.option("sequences")) {
                    if (this.expression instanceof AST.Seq) {
                        seq = this.expression;
                        x = seq.to_array();
                        this.expression = x.pop();
                        x.push(this);
                        seq = AST.Seq.from_array(x).transform(compressor);
                        return seq;
                    }
                }
                return this;
            });

            OPT(AST.UnaryPostfix, function (self, compressor) {
                return self.lift_sequences(compressor);
            });

            OPT(AST.UnaryPrefix, function (self, compressor) {
                var e;
                self = self.lift_sequences(compressor);
                e = self.expression;
                if (compressor.option("booleans") && compressor.in_boolean_context()) {
                    switch (self.operator) {
                    case "!":
                        if ((e instanceof AST.UnaryPrefix) && (e.operator === "!")) {
                            // !!foo ==> foo, if we're in boolean context
                            return e.expression;
                        }
                        break;
                    case "typeof":
                        // typeof always returns a non-empty string, thus it's
                        // always true in booleans
                        compressor.warn("Boolean expression always true [{file}:{line},{col}]", self.start);
                        return make_node(AST.True, self);
                    }
                    if ((e instanceof AST.Binary) && (self.operator === "!")) {
                        self = best_of(self, e.negate(compressor));
                    }
                }
                return self.evaluate(compressor)[0];
            });

            function has_side_effects_or_prop_access(node, compressor) {
                var save_pure_getters,
                    ret;
                save_pure_getters = compressor.option("pure_getters");
                compressor.options.pure_getters = false;
                ret = node.has_side_effects(compressor);
                compressor.options.pure_getters = save_pure_getters;
                return ret;
            }

            AST.Binary.DEFMETHOD("lift_sequences", function (compressor) {
                var seq,
                    x;
                if (compressor.option("sequences")) {
                    if (this.left instanceof AST.Seq) {
                        seq = this.left;
                        x = seq.to_array();
                        this.left = x.pop();
                        x.push(this);
                        seq = AST.Seq.from_array(x).transform(compressor);
                        return seq;
                    }
                    if ((this.right instanceof AST.Seq) &&
                            (this instanceof AST.Assign) &&
                            !has_side_effects_or_prop_access(this.left, compressor)) {
                        seq = this.right;
                        x = seq.to_array();
                        this.right = x.pop();
                        x.push(this);
                        seq = AST.Seq.from_array(x).transform(compressor);
                        return seq;
                    }
                }
                return this;
            });


            OPT(AST.Binary, function (self, compressor) {
                var reverse,
                    ll,
                    rr,
                    negated,
                    isCommutative;
                reverse = compressor.has_directive("use asm") ? function () {
                    return;
                } : function (op, force) {
                    var tmp;
                    if (force ||
                            !(self.left.has_side_effects(compressor) ||
                                self.right.has_side_effects(compressor))) {
                        if (op) {
                            self.operator = op;
                        }
                        tmp = self.left;
                        self.left = self.right;
                        self.right = tmp;
                    }
                };
                switch (self.operator) {
                case "==":
                case "!=":
                case "===":
                case "!==":
                case "*":
                case "&":
                case "|":
                case "^":
                    isCommutative = true;
                    break;
                }

                if (isCommutative) {
                    if ((self.right instanceof AST.Constant) &&
                            !(self.left instanceof AST.Constant)) {
                        // if right is a constant, whatever side effects the
                        // left side might have could not influence the
                        // result.  hence, force switch.

                        if (!((self.left instanceof AST.Binary) &&
                                (precedence(self.left.operator) >= precedence(self.operator)))) {
                            reverse(null, true);
                        }
                    }
                    if (/^[!=]==?$/.test(self.operator)) {
                        if (self.left instanceof AST.SymbolRef && self.right instanceof AST.Conditional) {
                            if ((self.right.consequent instanceof AST.SymbolRef) &&
                                    (self.right.consequent.definition() === self.left.definition())) {
                                if (/^==/.test(self.operator)) {
                                    return self.right.condition;
                                }
                                if (/^!=/.test(self.operator)) {
                                    return self.right.condition.negate(compressor);
                                }
                            }
                            if ((self.right.alternative instanceof AST.SymbolRef) &&
                                    (self.right.alternative.definition() === self.left.definition())) {
                                if (/^==/.test(self.operator)) {
                                    return self.right.condition.negate(compressor);
                                }
                                if (/^!=/.test(self.operator)) {
                                    return self.right.condition;
                                }
                            }
                        }
                        if (self.right instanceof AST.SymbolRef && self.left instanceof AST.Conditional) {
                            if ((self.left.consequent instanceof AST.SymbolRef) &&
                                    (self.left.consequent.definition() === self.right.definition())) {
                                if (/^==/.test(self.operator)) {
                                    return self.left.condition;
                                }
                                if (/^!=/.test(self.operator)) {
                                    return self.left.condition.negate(compressor);
                                }
                            }
                            if ((self.left.alternative instanceof AST.SymbolRef) &&
                                    (self.left.alternative.definition() === self.right.definition())) {
                                if (/^==/.test(self.operator)) {
                                    return self.left.condition.negate(compressor);
                                }
                                if (/^!=/.test(self.operator)) {
                                    return self.left.condition;
                                }
                            }
                        }
                    }
                }
                self = self.lift_sequences(compressor);
                if (compressor.option("comparisons")) {
                    /*jshint -W086: true */
                    switch (self.operator) {
                    case "===":
                    case "!==":
                        if ((self.left.is_string(compressor) && self.right.is_string(compressor)) ||
                                (self.left.is_boolean() && self.right.is_boolean())) {
                            self.operator = self.operator.substr(0, 2);
                        }
                    // XXX: intentionally falling down to the next case
                    /* falls through */
                    case "==":
                    case "!=":
                        if ((self.left instanceof AST.String) &&
                                (self.left.value === "undefined") &&
                                (self.right instanceof AST.UnaryPrefix) &&
                                (self.right.operator === "typeof") &&
                                compressor.option("unsafe")) {
                            if (!(self.right.expression instanceof AST.SymbolRef) ||
                                    !self.right.expression.undeclared()) {
                                self.right = self.right.expression;
                                self.left = make_node(AST.Undefined, self.left).optimize(compressor);
                                if (self.operator.length === 2) {
                                    self.operator += "=";
                                }
                            }
                        }
                        break;
                    }
                }
                if (compressor.option("booleans") && compressor.in_boolean_context()) {
                    switch (self.operator) {
                    case "&&":
                        ll = self.left.evaluate(compressor);
                        rr = self.right.evaluate(compressor);
                        if ((ll.length > 1 && !ll[1]) || (rr.length > 1 && !rr[1])) {
                            compressor.warn("Boolean && always false [{file}:{line},{col}]", self.start);
                            if (self.left.has_side_effects(compressor)) {
                                return make_node(AST.Seq, self, {
                                    car: self.left,
                                    cdr: make_node(AST.False)
                                }).optimize(compressor);
                            }
                            return make_node(AST.False, self);
                        }
                        if (ll.length > 1 && ll[1]) {
                            return rr[0];
                        }
                        if (rr.length > 1 && rr[1]) {
                            return ll[0];
                        }
                        break;
                    case "||":
                        ll = self.left.evaluate(compressor);
                        rr = self.right.evaluate(compressor);
                        if ((ll.length > 1 && ll[1]) || (rr.length > 1 && rr[1])) {
                            compressor.warn("Boolean || always true [{file}:{line},{col}]", self.start);
                            if (self.left.has_side_effects(compressor)) {
                                return make_node(AST.Seq, self, {
                                    car: self.left,
                                    cdr: make_node(AST.True)
                                }).optimize(compressor);
                            }
                            return make_node(AST.True, self);
                        }
                        if (ll.length > 1 && !ll[1]) {
                            return rr[0];
                        }
                        if (rr.length > 1 && !rr[1]) {
                            return ll[0];
                        }
                        break;
                    case "+":
                        ll = self.left.evaluate(compressor);
                        rr = self.right.evaluate(compressor);
                        if ((ll.length > 1 && ll[0] instanceof AST.String && ll[1]) ||
                                (rr.length > 1 && rr[0] instanceof AST.String && rr[1])) {
                            compressor.warn("+ in boolean context always true [{file}:{line},{col}]", self.start);
                            return make_node(AST.True, self);
                        }
                        break;
                    }
                }
                if (compressor.option("comparisons")) {
                    if (!(compressor.parent() instanceof AST.Binary) ||
                            compressor.parent() instanceof AST.Assign) {
                        negated = make_node(AST.UnaryPrefix, self, {
                            operator: "!",
                            expression: self.negate(compressor)
                        });
                        self = best_of(self, negated);
                    }
                    switch (self.operator) {
                    case "<":
                        reverse(">");
                        break;
                    case "<=":
                        reverse(">=");
                        break;
                    }
                }
                if ((self.operator === "+") &&
                        (self.right instanceof AST.String) &&
                        (self.right.getValue() === "") &&
                        (self.left instanceof AST.Binary) &&
                        (self.left.operator === "+") &&
                        self.left.is_string(compressor)) {
                    return self.left;
                }
                if (compressor.option("evaluate")) {
                    if (self.operator === "+") {
                        if ((self.left instanceof AST.Constant) &&
                                (self.right instanceof AST.Binary) &&
                                (self.right.operator === "+") &&
                                (self.right.left instanceof AST.Constant) &&
                                self.right.is_string(compressor)) {
                            self = make_node(AST.Binary, self, {
                                operator: "+",
                                left: make_node(AST.String, null, {
                                    value: String(self.left.getValue() + self.right.left.getValue()),
                                    start: self.left.start,
                                    end: self.right.left.end
                                }),
                                right: self.right.right
                            });
                        }
                        if ((self.right instanceof AST.Constant) &&
                                (self.left instanceof AST.Binary) &&
                                (self.left.operator === "+") &&
                                (self.left.right instanceof AST.Constant) &&
                                self.left.is_string(compressor)) {
                            self = make_node(AST.Binary, self, {
                                operator: "+",
                                left: self.left.left,
                                right: make_node(AST.String, null, {
                                    value: String(self.left.right.getValue() + self.right.getValue()),
                                    start: self.left.right.start,
                                    end: self.right.end
                                })
                            });
                        }
                        if ((self.left instanceof AST.Binary) &&
                                (self.left.operator === "+") &&
                                self.left.is_string(compressor) &&
                                (self.left.right instanceof AST.Constant) &&
                                (self.right instanceof AST.Binary) &&
                                (self.right.operator === "+") &&
                                (self.right.left instanceof AST.Constant) &&
                                self.right.is_string(compressor)) {
                            self = make_node(AST.Binary, self, {
                                operator: "+",
                                left: make_node(AST.Binary, self.left, {
                                    operator: "+",
                                    left: self.left.left,
                                    right: make_node(AST.String, null, {
                                        value: String(self.left.right.getValue() + self.right.left.getValue()),
                                        start: self.left.right.start,
                                        end: self.right.left.end
                                    })
                                }),
                                right: self.right.right
                            });
                        }
                    }
                }
                // x * (y * z)  ==>  x * y * z
                if ((self.right instanceof AST.Binary) &&
                        (self.right.operator === self.operator) &&
                        ((self.operator === "*") ||
                            (self.operator === "&&") ||
                            (self.operator === "||"))) {
                    self.left = make_node(AST.Binary, self.left, {
                        operator: self.operator,
                        left: self.left,
                        right: self.right.left
                    });
                    self.right = self.right.right;
                    return self.transform(compressor);
                }
                return self.evaluate(compressor)[0];
            });

            OPT(AST.SymbolRef, function (self, compressor) {
                var defines;
                if (self.undeclared()) {
                    defines = compressor.option("global_defs");
                    if (defines && defines.hasOwnProperty(self.name)) {
                        return make_node_from_constant(compressor, defines[self.name], self);
                    }
                    switch (self.name) {
                    case "undefined":
                        return make_node(AST.Undefined, self);
                    case "NaN":
                        return make_node(AST.NaN, self).transform(compressor);
                    case "Infinity":
                        return make_node(AST.Infinity, self).transform(compressor);
                    }
                }
                return self;
            });

            OPT(AST.Infinity, function (self, compressor) {
                return make_node(AST.Binary, self, {
                    operator: '/',
                    left: make_node(AST.Number, null, {
                        value: 1
                    }),
                    right: make_node(AST.Number, null, {
                        value: 0
                    })
                });
            });

            OPT(AST.NaN, function (self, compressor) {
                return make_node(AST.Binary, self, {
                    operator: '/',
                    left: make_node(AST.Number, null, {
                        value: 0
                    }),
                    right: make_node(AST.Number, null, {
                        value: 0
                    })
                });
            });

            OPT(AST.Undefined, function (self, compressor) {
                var scope,
                    undef,
                    ref;
                if (compressor.option("unsafe")) {
                    scope = compressor.find_parent(AST.Scope);
                    undef = scope.find_variable("undefined");
                    if (undef) {
                        ref = make_node(AST.SymbolRef, self, {
                            name: "undefined",
                            scope: scope,
                            thedef: undef
                        });
                        ref.reference();
                        return ref;
                    }
                }
                return self;
            });

            OPT(AST.Assign, function (self, compressor) {
                self = self.lift_sequences(compressor);
                if ((self.operator === "=") &&
                        (self.left instanceof AST.SymbolRef) &&
                        (self.right instanceof AST.Binary) &&
                        (self.right.left instanceof AST.SymbolRef) &&
                        (self.right.left.name === self.left.name)) {
                    switch (self.right.operator) {
                    case "+":
                    case "-":
                    case "/":
                    case "*":
                    case "%":
                    case ">>":
                    case "<<":
                    case ">>>":
                    case "|":
                    case "^":
                    case "&":
                        self.operator = self.right.operator + "=";
                        self.right = self.right.right;
                        break;
                    }
                }
                return self;
            });

            OPT(AST.Conditional, function (self, compressor) {
                var car,
                    cond,
                    negated,
                    consequent,
                    alternative;
                if (!compressor.option("conditionals")) {
                    return self;
                }
                if (self.condition instanceof AST.Seq) {
                    car = self.condition.car;
                    self.condition = self.condition.cdr;
                    return AST.Seq.cons(car, self);
                }
                cond = self.condition.evaluate(compressor);
                if (cond.length > 1) {
                    if (cond[1]) {
                        compressor.warn("Condition always true [{file}:{line},{col}]", self.start);
                        return self.consequent;
                    }
                    compressor.warn("Condition always false [{file}:{line},{col}]", self.start);
                    return self.alternative;
                }
                negated = cond[0].negate(compressor);
                if (best_of(cond[0], negated) === negated) {
                    self = make_node(AST.Conditional, self, {
                        condition: negated,
                        consequent: self.alternative,
                        alternative: self.consequent
                    });
                }
                consequent = self.consequent;
                alternative = self.alternative;
                if ((consequent instanceof AST.Assign) &&
                        (alternative instanceof AST.Assign) &&
                        (consequent.operator === alternative.operator) &&
                        (consequent.left.equivalent_to(alternative.left))) {
                    /*
                     * Stuff like this:
                     * if (foo) exp = something; else exp = something_else;
                     * ==>
                     * exp = foo ? something : something_else;
                     */
                    return make_node(AST.Assign, self, {
                        operator: consequent.operator,
                        left: consequent.left,
                        right: make_node(AST.Conditional, self, {
                            condition: self.condition,
                            consequent: consequent.right,
                            alternative: alternative.right
                        })
                    });
                }
                if ((consequent instanceof AST.Call) &&
                        (alternative.TYPE === consequent.TYPE) &&
                        (consequent.args.length === alternative.args.length) &&
                        consequent.expression.equivalent_to(alternative.expression)) {
                    if (consequent.args.length === 0) {
                        return make_node(AST.Seq, self, {
                            car: self.condition,
                            cdr: consequent
                        });
                    }
                    if (consequent.args.length === 1) {
                        consequent.args[0] = make_node(AST.Conditional, self, {
                            condition: self.condition,
                            consequent: consequent.args[0],
                            alternative: alternative.args[0]
                        });
                        return consequent;
                    }
                }
                // x?y?z:a:a --> x&&y?z:a
                if ((consequent instanceof AST.Conditional) &&
                        consequent.alternative.equivalent_to(alternative)) {
                    return make_node(AST.Conditional, self, {
                        condition: make_node(AST.Binary, self, {
                            left: self.condition,
                            operator: "&&",
                            right: consequent.condition
                        }),
                        consequent: consequent.consequent,
                        alternative: alternative
                    });
                }

                // x=y?1:1 --> x=1
                if ((consequent instanceof AST.Constant) &&
                        (alternative instanceof AST.Constant) &&
                        consequent.equivalent_to(alternative)) {
                    if (self.condition.has_side_effects(compressor)) {
                        return AST.Seq.from_array([
                            self.condition,
                            make_node_from_constant(compressor, consequent.value, self)
                        ]);
                    }
                    return make_node_from_constant(compressor, consequent.value, self);
                }

                // x=y?true:false --> x=!!y
                if ((consequent instanceof AST.True) && (alternative instanceof AST.False)) {
                    self.condition = self.condition.negate(compressor);
                    return make_node(AST.UnaryPrefix, self.condition, {
                        operator: "!",
                        expression: self.condition
                    });
                }

                // x=y?false:true --> x=!y
                if ((consequent instanceof AST.False) && (alternative instanceof AST.True)) {
                    return self.condition.negate(compressor);
                }

                return self;
            });

            OPT(AST.Boolean, function (self, compressor) {
                if (compressor.option("booleans")) {
                    var p = compressor.parent();
                    if ((p instanceof AST.Binary) &&
                            ((p.operator === "==") || (p.operator === "!="))) {
                        compressor.warn("Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]", {
                            operator: p.operator,
                            value: self.value,
                            file: p.start.file,
                            line: p.start.line,
                            col: p.start.col
                        });
                        return make_node(AST.Number, self, {
                            value: +self.value
                        });
                    }
                    return make_node(AST.UnaryPrefix, self, {
                        operator: "!",
                        expression: make_node(AST.Number, self, {
                            value: 1 - self.value
                        })
                    });
                }
                return self;
            });

            OPT(AST.Sub, function (self, compressor) {
                /*jslint eqeq:true */
                var prop = self.property,
                    cond,
                    v;
                if ((prop instanceof AST.String) && compressor.option("properties")) {
                    prop = prop.getValue();
                    cond = predicates.RESERVED_WORDS(prop) ? compressor.option("screw_ie8") : is.identifier_string(prop);
                    if (cond) {
                        return make_node(AST.Dot, self, {
                            expression: self.expression,
                            property: prop
                        }).optimize(compressor);
                    }
                    v = parseFloat(prop);
                    if (!isNaN(v) && (v.toString() == prop)) {
                        self.property = make_node(AST.Number, self.property, {
                            value: v
                        });
                    }
                }
                return self;
            });

            OPT(AST.Dot, function (self, compressor) {
                var prop = self.property;
                if (predicates.RESERVED_WORDS(prop) && !compressor.option("screw_ie8")) {
                    return make_node(AST.Sub, self, {
                        expression: self.expression,
                        property: make_node(AST.String, self, {
                            value: prop
                        })
                    }).optimize(compressor);
                }
                return self.evaluate(compressor)[0];
            });

            function literals_in_boolean_context(self, compressor) {
                if (compressor.option("booleans") && compressor.in_boolean_context()) {
                    return make_node(AST.True, self);
                }
                return self;
            }
            OPT(AST.Array, literals_in_boolean_context);
            OPT(AST.Object, literals_in_boolean_context);
            OPT(AST.RegExp, literals_in_boolean_context);

            AST.has_compress_support = true;
        }

        return add_compress_fns_to_AST;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "add_moz_fns_to_AST",
    [
        "is"
    ],
    function (is) {
        

        function add_moz_fns_to_AST(AST) {
            var FROM_MOZ_STACK = null,
                MOZ_TO_ME;

            if (AST.has_moz_support) {
                return;
            }

            function my_start_token(moznode) {
                var loc = moznode.loc,
                    start = loc && loc.start,
                    range = moznode.range,
                    args = {
                        file: loc && loc.source,
                        line: start && start.line,
                        col: start && start.column,
                        pos: range ? range[0] : moznode.start,
                        endline: start && start.line,
                        endcol: start && start.column,
                        endpos: range ? range[0] : moznode.start
                    };
                return new AST.Token(args);
            }

            function my_end_token(moznode) {
                var loc = moznode.loc,
                    end = loc && loc.end,
                    range = moznode.range,
                    args = {
                        file: loc && loc.source,
                        line: end && end.line,
                        col: end && end.column,
                        pos: range ? range[1] : moznode.end,
                        endline: end && end.line,
                        endcol: end && end.column,
                        endpos: range ? range[1] : moznode.end
                    };
                return new AST.Token(args);
            }

            function from_moz(node) {
                var ret;
                FROM_MOZ_STACK.push(node);
                ret = node ? MOZ_TO_ME[node.type](node) : null;
                FROM_MOZ_STACK.pop();
                return ret;
            }

            function set_moz_loc(mynode, moznode) {
                var start = mynode.start,
                    end = mynode.end;
                if ((start.pos || (start.pos === 0)) && (end.endpos || (end.endpos === 0))) {
                    moznode.range = [start.pos, end.endpos];
                }
                if (start.line) {
                    moznode.loc = {
                        start: {
                            line: start.line,
                            column: start.col
                        },
                        end: (end.endline ? {
                            line: end.endline,
                            column: end.endcol
                        } : null)
                    };
                    if (start.file) {
                        moznode.loc.source = start.file;
                    }
                }
                return moznode;
            }

            function def_to_moz(mytype, handler) {
                mytype.DEFMETHOD("to_mozilla_ast", function () {
                    return set_moz_loc(this, handler(this));
                });
            }

            function to_moz(node) {
                return node ? node.to_mozilla_ast() : null;
            }

            function to_moz_block(node) {
                return {
                    type: "BlockStatement",
                    body: node.body.map(to_moz)
                };
            }

            AST.Node.from_mozilla_ast = function (node) {
                var save_stack = FROM_MOZ_STACK,
                    ast;
                FROM_MOZ_STACK = [];
                ast = from_moz(node);
                FROM_MOZ_STACK = save_stack;
                return ast;
            };

            function map(moztype, mytype, propmap) {
                /*jslint plusplus: true, evil: true*/
                var props,
                    prop,
                    i,
                    m,
                    moz,
                    how,
                    my,
                    moz_to_me,
                    me_to_moz,
                    re = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i;

                moz_to_me = "function From_Moz_" +
                    moztype +
                    "(M) {\nreturn new " +
                    mytype.name +
                    "({\nstart: my_start_token(M),\nend: my_end_token(M)";
                me_to_moz = "function To_Moz_" +
                    moztype +
                    "(M){\nreturn {\ntype: " +
                    JSON.stringify(moztype);

                if (propmap) {
                    props = propmap.split(",");
                    for (i = 0; i < props.length; ++i) {
                        prop = props[i];
                        m = re.exec(prop.trim());
                        if (!m) {
                            throw new Error("Can't understand property map: " + prop);
                        }
                        moz = m[1];
                        how = m[2];
                        my = m[3];
                        moz_to_me += ",\n" + my + ": ";
                        me_to_moz += ",\n" + moz + ": ";
                        switch (how) {
                        case "@":
                            moz_to_me += "M." + moz + ".map(from_moz)";
                            me_to_moz += "M." +  my + ".map(to_moz)";
                            break;
                        case ">":
                            moz_to_me += "from_moz(M." + moz + ")";
                            me_to_moz += "to_moz(M." + my + ")";
                            break;
                        case "=":
                            moz_to_me += "M." + moz;
                            me_to_moz += "M." + my;
                            break;
                        case "%":
                            moz_to_me += "from_moz(M." + moz + ").body";
                            me_to_moz += "to_moz_block(M)";
                            break;
                        default:
                            throw new Error("Can't understand operator in propmap: " + prop);
                        }
                    }
                }

                moz_to_me += "\n})\n}";
                me_to_moz += "\n}\n}";

                moz_to_me = new Function("my_start_token", "my_end_token", "from_moz", "return(" + moz_to_me + ")")(
                    my_start_token,
                    my_end_token,
                    from_moz
                );
                me_to_moz = new Function("to_moz", "to_moz_block", "return(" + me_to_moz + ")")(
                    to_moz,
                    to_moz_block
                );
                MOZ_TO_ME[moztype] = moz_to_me;
                def_to_moz(mytype, me_to_moz);
            }


            MOZ_TO_ME = {
                ExpressionStatement: function (M) {
                    var expr = M.expression;
                    if ((expr.type === "Literal") && (typeof expr.value === "string")) {
                        return new AST.Directive({
                            start: my_start_token(M),
                            end: my_end_token(M),
                            value: expr.value
                        });
                    }
                    return new AST.SimpleStatement({
                        start: my_start_token(M),
                        end: my_end_token(M),
                        body: from_moz(expr)
                    });
                },
                TryStatement: function (M) {
                    var handlers = M.handlers || [M.handler],
                        args;
                    if ((handlers.length > 1) || (M.guardedHandlers && M.guardedHandlers.length)) {
                        throw new Error("Multiple catch clauses are not supported.");
                    }
                    args = {
                        start: my_start_token(M),
                        end: my_end_token(M),
                        body: from_moz(M.block).body,
                        bcatch: from_moz(handlers[0]),
                        bfinally: M.finalizer ? new AST.Finally(from_moz(M.finalizer)) : null
                    };
                    return new AST.Try(args);
                },
                Property: function (M) {
                    var key = M.key,
                        name = (key.type === "Identifier") ? key.name : key.value,
                        args = {
                            start: my_start_token(key),
                            end: my_end_token(M.value),
                            key: name,
                            value: from_moz(M.value)
                        };
                    switch (M.kind) {
                    case "init":
                        return new AST.ObjectKeyVal(args);
                    case "set":
                        args.value.name = from_moz(key);
                        return new AST.ObjectSetter(args);
                    case "get":
                        args.value.name = from_moz(key);
                        return new AST.ObjectGetter(args);
                    }
                },
                ObjectExpression: function (M) {
                    var args = {
                            start: my_start_token(M),
                            end: my_end_token(M),
                            properties: M.properties.map(function (prop) {
                                prop.type = "Property";
                                return from_moz(prop);
                            })
                        };
                    return new AST.Object(args);
                },
                SequenceExpression: function (M) {
                    return AST.Seq.from_array(M.expressions.map(from_moz));
                },
                MemberExpression: function (M) {
                    var ConstructorType = (M.computed ? AST.Sub : AST.Dot),
                        args = {
                            start: my_start_token(M),
                            end: my_end_token(M),
                            property : (M.computed ? from_moz(M.property) : M.property.name),
                            expression : from_moz(M.object)
                        };
                    return new ConstructorType(args);
                },
                SwitchCase: function (M) {
                    var ConstructorType = (M.test ? AST.Case : AST.Default),
                        args = {
                            start: my_start_token(M),
                            end: my_end_token(M),
                            expression: from_moz(M.test),
                            body: M.consequent.map(from_moz)
                        };
                    return new ConstructorType(args);
                },
                VariableDeclaration: function (M) {
                    var ConstructorType = (M.kind === "const" ? AST.Const : AST.Var),
                        args = {
                            start: my_start_token(M),
                            end: my_end_token(M),
                            definitions: M.declarations.map(from_moz)
                        };
                    return new ConstructorType(args);
                },
                Literal: function (M) {
                    var val = M.value,
                        val_type = typeof val,
                        ConstructorType = null,
                        args = {
                            start: my_start_token(M),
                            end: my_end_token(M)
                        };
                    if (val === null) {
                        ConstructorType = AST.Null;
                    } else if (val_type === "boolean") {
                        ConstructorType = val ? AST.True : AST.False;
                    } else {
                        args.value = val;
                        switch (val_type) {
                        case "string":
                            ConstructorType = AST.String;
                            break;

                        case "number":
                            ConstructorType = AST.Number;
                            break;

                        default:
                            ConstructorType = AST.RegExp;
                            break;
                        }
                    }
                    return new ConstructorType(args);
                },
                Identifier: function (M) {
                    var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2],
                        ConstructorType = null,
                        args = {
                            start : my_start_token(M),
                            end : my_end_token(M),
                            name : M.name
                        };
                    switch (p.type) {
                    case "LabeledStatement":
                        ConstructorType = AST.Label;
                        break;

                    case "VariableDeclarator":
                        if (p.id === M) {
                            ConstructorType = (p.kind === "const") ? AST.SymbolConst : AST.SymbolVar;
                        }
                        break;

                    case "FunctionExpression":
                        ConstructorType = (p.id === M) ? AST.SymbolLambda : AST.SymbolFunarg;
                        break;

                    case "FunctionDeclaration":
                        ConstructorType = (p.id === M) ? AST.SymbolDefun : AST.SymbolFunarg;
                        break;

                    case "CatchClause":
                        ConstructorType = AST.SymbolCatch;
                        break;

                    case "BreakStatement":
                    case "ContinueStatement":
                        ConstructorType = AST.LabelRef;
                        break;
                    }
                    if (!ConstructorType) {
                        ConstructorType = AST.SymbolRef;
                    }
                    return new ConstructorType(args);
                }
            };

            MOZ_TO_ME.UpdateExpression =
                MOZ_TO_ME.UnaryExpression =
                function From_Moz_Unary(M) {
                    var prefix = M.hasOwnProperty("prefix") ? M.prefix : (M.type === "UnaryExpression"),
                        ConstructorType = prefix ? AST.UnaryPrefix : AST.UnaryPostfix,
                        args = {
                            start: my_start_token(M),
                            end: my_end_token(M),
                            operator: M.operator,
                            expression: from_moz(M.argument)
                        };

                    return new ConstructorType(args);
                };

            map("Program", AST.Toplevel, "body@body");
            map("EmptyStatement", AST.EmptyStatement);
            map("BlockStatement", AST.BlockStatement, "body@body");
            map("IfStatement", AST.If, "test>condition, consequent>body, alternate>alternative");
            map("LabeledStatement", AST.LabeledStatement, "label>label, body>body");
            map("BreakStatement", AST.Break, "label>label");
            map("ContinueStatement", AST.Continue, "label>label");
            map("WithStatement", AST.With, "object>expression, body>body");
            map("SwitchStatement", AST.Switch, "discriminant>expression, cases@body");
            map("ReturnStatement", AST.Return, "argument>value");
            map("ThrowStatement", AST.Throw, "argument>value");
            map("WhileStatement", AST.While, "test>condition, body>body");
            map("DoWhileStatement", AST.Do, "test>condition, body>body");
            map("ForStatement", AST.For, "init>init, test>condition, update>step, body>body");
            map("ForInStatement", AST.ForIn, "left>init, right>object, body>body");
            map("DebuggerStatement", AST.Debugger);
            map("FunctionDeclaration", AST.Defun, "id>name, params@argnames, body%body");
            map("VariableDeclarator", AST.VarDef, "id>name, init>value");
            map("CatchClause", AST.Catch, "param>argname, body%body");

            map("ThisExpression", AST.This);
            map("ArrayExpression", AST.Array, "elements@elements");
            map("FunctionExpression", AST.Function, "id>name, params@argnames, body%body");
            map("BinaryExpression", AST.Binary, "operator=operator, left>left, right>right");
            map("LogicalExpression", AST.Binary, "operator=operator, left>left, right>right");
            map("AssignmentExpression", AST.Assign, "operator=operator, left>left, right>right");
            map("ConditionalExpression", AST.Conditional, "test>condition, consequent>consequent, alternate>alternative");
            map("NewExpression", AST.New, "callee>expression, arguments@args");
            map("CallExpression", AST.Call, "callee>expression, arguments@args");

            def_to_moz(AST.Directive, function To_Moz_Directive(M) {
                return {
                    type: "ExpressionStatement",
                    expression: {
                        type: "Literal",
                        value: M.value
                    }
                };
            });

            def_to_moz(AST.SimpleStatement, function To_Moz_ExpressionStatement(M) {
                return {
                    type: "ExpressionStatement",
                    expression: to_moz(M.body)
                };
            });

            def_to_moz(AST.SwitchBranch, function To_Moz_SwitchCase(M) {
                return {
                    type: "SwitchCase",
                    test: to_moz(M.expression),
                    consequent: M.body.map(to_moz)
                };
            });

            def_to_moz(AST.Try, function To_Moz_TryStatement(M) {
                return {
                    type: "TryStatement",
                    block: to_moz_block(M),
                    handler: to_moz(M.bcatch),
                    guardedHandlers: [],
                    finalizer: to_moz(M.bfinally)
                };
            });

            def_to_moz(AST.Catch, function To_Moz_CatchClause(M) {
                return {
                    type: "CatchClause",
                    param: to_moz(M.argname),
                    guard: null,
                    body: to_moz_block(M)
                };
            });

            def_to_moz(AST.Definitions, function To_Moz_VariableDeclaration(M) {
                return {
                    type: "VariableDeclaration",
                    kind: M instanceof AST.Const ? "const" : "var",
                    declarations: M.definitions.map(to_moz)
                };
            });

            def_to_moz(AST.Seq, function To_Moz_SequenceExpression(M) {
                return {
                    type: "SequenceExpression",
                    expressions: M.to_array().map(to_moz)
                };
            });

            def_to_moz(AST.PropAccess, function To_Moz_MemberExpression(M) {
                var isComputed = M instanceof AST.Sub;
                return {
                    type: "MemberExpression",
                    object: to_moz(M.expression),
                    computed: isComputed,
                    property: isComputed ? to_moz(M.property) : {
                        type: "Identifier",
                        name: M.property
                    }
                };
            });

            def_to_moz(AST.Unary, function To_Moz_Unary(M) {
                return {
                    type: ((M.operator === "++") || (M.operator === "--")) ? "UpdateExpression" : "UnaryExpression",
                    operator: M.operator,
                    prefix: (M instanceof AST.UnaryPrefix),
                    argument: to_moz(M.expression)
                };
            });

            def_to_moz(AST.Binary, function To_Moz_BinaryExpression(M) {
                return {
                    type: ((M.operator === "&&") || (M.operator === "||")) ? "LogicalExpression" : "BinaryExpression",
                    left: to_moz(M.left),
                    operator: M.operator,
                    right: to_moz(M.right)
                };
            });

            def_to_moz(AST.Object, function To_Moz_ObjectExpression(M) {
                return {
                    type: "ObjectExpression",
                    properties: M.properties.map(to_moz)
                };
            });

            def_to_moz(AST.ObjectProperty, function To_Moz_Property(M) {
                var key,
                    kind;
                if (is.identifier(M.key)) {
                    key = {
                        type: "Identifier",
                        name: M.key
                    };
                } else {
                    key = {
                        type: "Literal",
                        value: M.key
                    };
                }
                if (M instanceof AST.ObjectKeyVal) {
                    kind = "init";
                } else if (M instanceof AST.ObjectGetter) {
                    kind = "get";
                } else if (M instanceof AST.ObjectSetter) {
                    kind = "set";
                }
                return {
                    type: "Property",
                    kind: kind,
                    key: key,
                    value: to_moz(M.value)
                };
            });

            def_to_moz(AST.Symbol, function To_Moz_Identifier(M) {
                var def = M.definition();
                return {
                    type: "Identifier",
                    name: def ? def.mangled_name || def.name : M.name
                };
            });

            def_to_moz(AST.Constant, function To_Moz_Literal(M) {
                var value = M.value;
                if ((typeof value === 'number') && ((value < 0) || ((value === 0) && ((1 / value) < 0)))) {
                    return {
                        type: "UnaryExpression",
                        operator: "-",
                        prefix: true,
                        argument: {
                            type: "Literal",
                            value: -value
                        }
                    };
                }
                return {
                    type: "Literal",
                    value: value
                };
            });

            def_to_moz(AST.Atom, function To_Moz_Atom(M) {
                return {
                    type: "Identifier",
                    name: String(M.value)
                };
            });

            AST.Boolean.DEFMETHOD("to_mozilla_ast", AST.Constant.prototype.to_mozilla_ast);

            AST.Null.DEFMETHOD("to_mozilla_ast", AST.Constant.prototype.to_mozilla_ast);

            AST.Hole.DEFMETHOD("to_mozilla_ast", function To_Moz_ArrayHole() {
                return null;
            });

            AST.Block.DEFMETHOD("to_mozilla_ast", AST.BlockStatement.prototype.to_mozilla_ast);

            AST.Lambda.DEFMETHOD("to_mozilla_ast", AST.Function.prototype.to_mozilla_ast);

            AST.has_moz_support = true;
        }
        return add_moz_fns_to_AST;
    }
);

/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "add_output_fns_to_AST",
    [
        "TreeWalker",
        "predicates",
        "precedence",
        "is",
        "OutputStream"
    ],
    function (TreeWalker, predicates, precedence, is, OutputStream) {
        
        function add_output_fns_to_AST(AST) {
            /*jslint nomen: true, plusplus: true, unparam: true */
            /*jshint unused: true*/

            if (AST.has_output_support) {
                return;
            }

            /* -----[ utils ]----- */

            function noop() {
                return;
            }

            function DEFPRINT(nodetype, generator) {
                nodetype.DEFMETHOD("_codegen", generator);
            }

            AST.Node.DEFMETHOD("print", function (stream, force_parens) {
                var self = this, generator = self._codegen;
                function doit() {
                    self.add_comments(stream);
                    self.add_source_map(stream);
                    generator(self, stream);
                }
                stream.push_node(self);
                if (force_parens || self.needs_parens(stream)) {
                    stream.with_parens(doit);
                } else {
                    doit();
                }
                stream.pop_node();
            });

            AST.Node.DEFMETHOD("print_to_string", function (options) {
                var s = new OutputStream(options);
                this.print(s);
                return s.get();
            });

            /* -----[ comments ]----- */

            AST.Node.DEFMETHOD("add_comments", function (output) {
                var c = output.option("comments"),
                    self = this,
                    start,
                    comments;
                if (c) {
                    start = self.start;
                    if (start && !start._comments_dumped) {
                        start._comments_dumped = true;
                        comments = start.comments_before || [];

                        // XXX: ugly fix for https://github.com/mishoo/UglifyJS2/issues/112
                        //               and https://github.com/mishoo/UglifyJS2/issues/372
                        if (self instanceof AST.Exit && self.value) {
                            self.value.walk(new TreeWalker(function (node) {
                                if (node.start && node.start.comments_before) {
                                    comments = comments.concat(node.start.comments_before);
                                    node.start.comments_before = [];
                                }
                                if ((node instanceof AST.Function) || (node instanceof AST.Array) || (node instanceof AST.Object)) {
                                    return true; // don't go inside.
                                }
                            }));
                        }

                        if (c.test) {
                            comments = comments.filter(function (comment) {
                                return c.test(comment.value);
                            });
                        } else if (typeof c === "function") {
                            comments = comments.filter(function (comment) {
                                return c(self, comment);
                            });
                        }

                        // Keep single line comments after nlb, after nlb
                        if (!output.option("beautify") && comments.length &&
                                (/comment[134]/).test(comments[0].type) &&
                                (output.col() !== 0) && comments[0].nlb) {
                            output.print("\n");
                        }

                        comments.forEach(function (c) {
                            if (/comment[134]/.test(c.type)) {
                                output.print("//" + c.value + "\n");
                                output.indent();
                            } else if (c.type === "comment2") {
                                output.print("/*" + c.value + "*/");
                                if (start.nlb) {
                                    output.print("\n");
                                    output.indent();
                                } else {
                                    output.space();
                                }
                            }
                        });
                    }
                }
            });

            /* -----[ PARENTHESES ]----- */

            function PARENS(nodetype, func) {
                if (Array.isArray(nodetype)) {
                    nodetype.forEach(function (nodetype) {
                        PARENS(nodetype, func);
                    });
                } else {
                    nodetype.DEFMETHOD("needs_parens", func);
                }
            }

            PARENS(AST.Node, function () {
                return false;
            });


            // return true if the node at the top of the stack (that means the
            // innermost node in the current output) is lexically the first in
            // a statement.
            function first_in_statement(output) {
                var a = output.stack(), i = a.length, node = a[--i], p = a[--i];
                while (i > 0) {
                    if ((p instanceof AST.Statement) && (p.body === node)) {
                        return true;
                    }
                    if (((p instanceof AST.Seq) && (p.car === node)) ||
                            ((p instanceof AST.Call) && (p.expression === node) && !(p instanceof AST.New)) ||
                            ((p instanceof AST.Dot) && (p.expression === node)) ||
                            ((p instanceof AST.Sub) && (p.expression === node)) ||
                            ((p instanceof AST.Conditional) && (p.condition === node)) ||
                            ((p instanceof AST.Binary) && (p.left === node)) ||
                            ((p instanceof AST.UnaryPostfix) && (p.expression === node))) {
                        node = p;
                        p = a[--i];
                    } else {
                        return false;
                    }
                }
            }

            // a function expression needs parens around it when it's provably
            // the first token to appear in a statement.
            PARENS(AST.Function, function (output) {
                return first_in_statement(output);
            });

            // same goes for an object literal, because otherwise it would be
            // interpreted as a block of code.
            PARENS(AST.Object, function (output) {
                return first_in_statement(output);
            });

            PARENS([AST.Unary, AST.Undefined], function (output) {
                var p = output.parent();
                return p instanceof AST.PropAccess && p.expression === this;
            });

            PARENS(AST.Seq, function (output) {
                var p = output.parent();
                return ((p instanceof AST.Call) ||          // (foo, bar)() or foo(1, (2, 3), 4)
                    (p instanceof AST.Unary) ||          // !(foo, bar, baz)
                    (p instanceof AST.Binary) ||         // 1 + (2, 3) + 4 ==> 8
                    (p instanceof AST.VarDef) ||         // var a = (1, 2), b = a + a; ==> b == 4
                    (p instanceof AST.PropAccess) ||     // (1, {foo:2}).foo or (1, {foo:2})["foo"] ==> 2
                    (p instanceof AST.Array) ||          // [ 1, (2, 3), 4 ] ==> [ 1, 3, 4 ]
                    (p instanceof AST.ObjectProperty) || // { foo: (1, 2) }.foo ==> 2
                    (p instanceof AST.Conditional));     /* (false, true) ? (a = 10, b = 20) : (c = 30)
                                                             * ==> 20 (side effect, set a := 10 and b := 20) */
            });

            PARENS(AST.Binary, function (output) {
                /*jslint eqeq: true */
                var p = output.parent(),
                    po,
                    pp,
                    so,
                    sp;
                // (foo && bar)()
                if (p instanceof AST.Call && p.expression === this) {
                    return true;
                }
                // typeof (foo && bar)
                if (p instanceof AST.Unary) {
                    return true;
                }
                // (foo && bar)["prop"], (foo && bar).prop
                if (p instanceof AST.PropAccess && p.expression === this) {
                    return true;
                }
                // this deals with precedence: 3 * (2 + 1)
                if (p instanceof AST.Binary) {
                    po = p.operator;
                    pp = precedence(po);
                    so = this.operator;
                    sp = precedence(so);
                    if ((pp > sp) || ((pp == sp) && (this === p.right))) {
                        return true;
                    }
                }
            });

            PARENS(AST.PropAccess, function (output) {
                var p = output.parent();
                if (p instanceof AST.New && p.expression === this) {
                    // i.e. new (foo.bar().baz)
                    //
                    // if there's one call into this subtree, then we need
                    // parens around it too, otherwise the call will be
                    // interpreted as passing the arguments to the upper New
                    // expression.
                    try {
                        this.walk(new TreeWalker(function (node) {
                            if (node instanceof AST.Call) {
                                throw p;
                            }
                        }));
                    } catch (ex) {
                        if (ex !== p) {
                            throw ex;
                        }
                        return true;
                    }
                }
            });

            PARENS(AST.Call, function (output) {
                var p = output.parent(), p1;
                if (p instanceof AST.New && p.expression === this) {
                    return true;
                }

                // workaround for Safari bug.
                // https://bugs.webkit.org/show_bug.cgi?id=123506
                if ((this.expression instanceof AST.Function) &&
                        (p instanceof AST.PropAccess) &&
                        (p.expression === this)) {
                    p1 = output.parent(1);
                    return (p1 instanceof AST.Assign) && (p1.left === p);
                }
                return false;
            });

            // self should be AST.New.  decide if we want to show parens or not.
            function no_constructor_parens(self, output) {
                return (self.args.length === 0) && !output.option("beautify");
            }

            PARENS(AST.New, function (output) {
                var p = output.parent();
                if (no_constructor_parens(this, output) &&
                        ((p instanceof AST.PropAccess) || // (new Date).getTime(), (new Date)["getTime"]()
                            ((p instanceof AST.Call) && (p.expression === this)))) { // (new foo)(bar)
                    return true;
                }
            });

            PARENS(AST.Number, function (output) {
                var p = output.parent();
                if ((this.getValue() < 0) && (p instanceof AST.PropAccess) && (p.expression === this)) {
                    return true;
                }
            });

            PARENS([AST.Assign, AST.Conditional], function (output) {
                /*jshint validthis:true */
                var p = output.parent();
                // !(a = false) → true
                if (p instanceof AST.Unary) {
                    return true;
                }
                // 1 + (a = 2) + 3 → 6, side effect setting a = 2
                if ((p instanceof AST.Binary) && !(p instanceof AST.Assign)) {
                    return true;
                }
                // (a = func)() —or— new (a = Object)()
                if ((p instanceof AST.Call) && (p.expression === this)) {
                    return true;
                }
                // (a = foo) ? bar : baz
                if ((p instanceof AST.Conditional) && (p.condition === this)) {
                    return true;
                }
                // (a = foo)["prop"] —or— (a = foo).prop
                if ((p instanceof AST.PropAccess) && (p.expression === this)) {
                    return true;
                }
            });

            /* -----[ PRINTERS ]----- */

            DEFPRINT(AST.Directive, function (self, output) {
                output.print_string(self.value, self.quote);
                output.semicolon();
            });
            DEFPRINT(AST.Debugger, function (self, output) {
                output.print("debugger");
                output.semicolon();
            });

            /* -----[ statements ]----- */

            function display_body(body, is_toplevel, output) {
                var last = body.length - 1;
                body.forEach(function (stmt, i) {
                    if (!(stmt instanceof AST.EmptyStatement)) {
                        output.indent();
                        stmt.print(output);
                        if (!((i === last) && is_toplevel)) {
                            output.newline();
                            if (is_toplevel) {
                                output.newline();
                            }
                        }
                    }
                });
            }

            function force_statement(stat, output) {
                if (output.option("bracketize")) {
                    if (!stat || (stat instanceof AST.EmptyStatement)) {
                        output.print("{}");
                    } else if (stat instanceof AST.BlockStatement) {
                        stat.print(output);
                    } else {
                        output.with_block(function () {
                            output.indent();
                            stat.print(output);
                            output.newline();
                        });
                    }
                } else {
                    if (!stat || (stat instanceof AST.EmptyStatement)) {
                        output.force_semicolon();
                    } else {
                        stat.print(output);
                    }
                }
            }

            AST.StatementWithBody.DEFMETHOD("_do_print_body", function (output) {
                force_statement(this.body, output);
            });

            DEFPRINT(AST.Statement, function (self, output) {
                self.body.print(output);
                output.semicolon();
            });
            DEFPRINT(AST.Toplevel, function (self, output) {
                display_body(self.body, true, output);
                output.print("");
            });
            DEFPRINT(AST.LabeledStatement, function (self, output) {
                self.label.print(output);
                output.colon();
                self.body.print(output);
            });
            DEFPRINT(AST.SimpleStatement, function (self, output) {
                self.body.print(output);
                output.semicolon();
            });
            function print_bracketed(body, output) {
                if (body.length > 0) {
                    output.with_block(function () {
                        display_body(body, false, output);
                    });
                } else {
                    output.print("{}");
                }
            }
            DEFPRINT(AST.BlockStatement, function (self, output) {
                print_bracketed(self.body, output);
            });
            DEFPRINT(AST.EmptyStatement, function (self, output) {
                output.semicolon();
            });
            DEFPRINT(AST.Do, function (self, output) {
                output.print("do");
                output.space();
                self._do_print_body(output);
                output.space();
                output.print("while");
                output.space();
                output.with_parens(function () {
                    self.condition.print(output);
                });
                output.semicolon();
            });
            DEFPRINT(AST.While, function (self, output) {
                output.print("while");
                output.space();
                output.with_parens(function () {
                    self.condition.print(output);
                });
                output.space();
                self._do_print_body(output);
            });

            function parenthesize_for_noin(node, output, noin) {
                if (!noin) {
                    node.print(output);
                } else {
                    try {
                        // need to take some precautions here:
                        //    https://github.com/mishoo/UglifyJS2/issues/60
                        node.walk(new TreeWalker(function (node) {
                            if ((node instanceof AST.Binary) && (node.operator === "in")) {
                                throw output;
                            }
                        }));
                        node.print(output);
                    } catch (ex) {
                        if (ex !== output) {
                            throw ex;
                        }
                        node.print(output, true);
                    }
                }
            }

            DEFPRINT(AST.For, function (self, output) {
                output.print("for");
                output.space();
                output.with_parens(function () {
                    if (self.init && !(self.init instanceof AST.EmptyStatement)) {
                        if (self.init instanceof AST.Definitions) {
                            self.init.print(output);
                        } else {
                            parenthesize_for_noin(self.init, output, true);
                        }
                        output.print(";");
                        output.space();
                    } else {
                        output.print(";");
                    }
                    if (self.condition) {
                        self.condition.print(output);
                        output.print(";");
                        output.space();
                    } else {
                        output.print(";");
                    }
                    if (self.step) {
                        self.step.print(output);
                    }
                });
                output.space();
                self._do_print_body(output);
            });
            DEFPRINT(AST.ForIn, function (self, output) {
                output.print("for");
                output.space();
                output.with_parens(function () {
                    self.init.print(output);
                    output.space();
                    output.print("in");
                    output.space();
                    self.object.print(output);
                });
                output.space();
                self._do_print_body(output);
            });
            DEFPRINT(AST.With, function (self, output) {
                output.print("with");
                output.space();
                output.with_parens(function () {
                    self.expression.print(output);
                });
                output.space();
                self._do_print_body(output);
            });

            /* -----[ functions ]----- */
            AST.Lambda.DEFMETHOD("_do_print", function (output, nokeyword) {
                var self = this;
                if (!nokeyword) {
                    output.print("function");
                }
                if (self.name) {
                    output.space();
                    self.name.print(output);
                }
                output.with_parens(function () {
                    self.argnames.forEach(function (arg, i) {
                        if (i) {
                            output.comma();
                        }
                        arg.print(output);
                    });
                });
                output.space();
                print_bracketed(self.body, output);
            });
            DEFPRINT(AST.Lambda, function (self, output) {
                self._do_print(output);
            });

            /* -----[ exits ]----- */
            AST.Exit.DEFMETHOD("_do_print", function (output, kind) {
                output.print(kind);
                if (this.value) {
                    output.space();
                    this.value.print(output);
                }
                output.semicolon();
            });
            DEFPRINT(AST.Return, function (self, output) {
                self._do_print(output, "return");
            });
            DEFPRINT(AST.Throw, function (self, output) {
                self._do_print(output, "throw");
            });

            /* -----[ loop control ]----- */
            AST.LoopControl.DEFMETHOD("_do_print", function (output, kind) {
                output.print(kind);
                if (this.label) {
                    output.space();
                    this.label.print(output);
                }
                output.semicolon();
            });
            DEFPRINT(AST.Break, function (self, output) {
                self._do_print(output, "break");
            });
            DEFPRINT(AST.Continue, function (self, output) {
                self._do_print(output, "continue");
            });


            function make_block(stmt, output) {
                if (stmt instanceof AST.BlockStatement) {
                    stmt.print(output);
                    return;
                }
                output.with_block(function () {
                    output.indent();
                    stmt.print(output);
                    output.newline();
                });
            }

            /* -----[ if ]----- */
            function make_then(self, output) {
                if (output.option("bracketize")) {
                    make_block(self.body, output);
                    return;
                }
                // The squeezer replaces "block"-s that contain only a single
                // statement with the statement itself; technically, the AST
                // is correct, but this can create problems when we output an
                // IF having an ELSE clause where the THEN clause ends in an
                // IF *without* an ELSE block (then the outer ELSE would refer
                // to the inner IF).  This function checks for this case and
                // adds the block brackets if needed.
                if (!self.body) {
                    return output.force_semicolon();
                }
                if ((self.body instanceof AST.Do) && !output.option("screw_ie8")) {
                    // https://github.com/mishoo/UglifyJS/issues/#issue/57 IE
                    // croaks with "syntax error" on code like this: if (foo)
                    // do ... while(cond); else ...  we need block brackets
                    // around do/while
                    make_block(self.body, output);
                    return;
                }
                var b = self.body;
                while (true) {
                    if (b instanceof AST.If) {
                        if (!b.alternative) {
                            make_block(self.body, output);
                            return;
                        }
                        b = b.alternative;
                    } else if (b instanceof AST.StatementWithBody) {
                        b = b.body;
                    } else {
                        break;
                    }
                }
                force_statement(self.body, output);
            }
            DEFPRINT(AST.If, function (self, output) {
                output.print("if");
                output.space();
                output.with_parens(function () {
                    self.condition.print(output);
                });
                output.space();
                if (self.alternative) {
                    make_then(self, output);
                    output.space();
                    output.print("else");
                    output.space();
                    force_statement(self.alternative, output);
                } else {
                    self._do_print_body(output);
                }
            });

            /* -----[ switch ]----- */
            DEFPRINT(AST.Switch, function (self, output) {
                output.print("switch");
                output.space();
                output.with_parens(function () {
                    self.expression.print(output);
                });
                output.space();
                if (self.body.length > 0) {
                    output.with_block(function () {
                        self.body.forEach(function (stmt, i) {
                            if (i) {
                                output.newline();
                            }
                            output.indent(true);
                            stmt.print(output);
                        });
                    });
                } else {
                    output.print("{}");
                }
            });
            AST.SwitchBranch.DEFMETHOD("_do_print_body", function (output) {
                if (this.body.length > 0) {
                    output.newline();
                    this.body.forEach(function (stmt) {
                        output.indent();
                        stmt.print(output);
                        output.newline();
                    });
                }
            });
            DEFPRINT(AST.Default, function (self, output) {
                output.print("default:");
                self._do_print_body(output);
            });
            DEFPRINT(AST.Case, function (self, output) {
                output.print("case");
                output.space();
                self.expression.print(output);
                output.print(":");
                self._do_print_body(output);
            });

            /* -----[ exceptions ]----- */
            DEFPRINT(AST.Try, function (self, output) {
                output.print("try");
                output.space();
                print_bracketed(self.body, output);
                if (self.bcatch) {
                    output.space();
                    self.bcatch.print(output);
                }
                if (self.bfinally) {
                    output.space();
                    self.bfinally.print(output);
                }
            });
            DEFPRINT(AST.Catch, function (self, output) {
                output.print("catch");
                output.space();
                output.with_parens(function () {
                    self.argname.print(output);
                });
                output.space();
                print_bracketed(self.body, output);
            });
            DEFPRINT(AST.Finally, function (self, output) {
                output.print("finally");
                output.space();
                print_bracketed(self.body, output);
            });

            /* -----[ var/const ]----- */
            AST.Definitions.DEFMETHOD("_do_print", function (output, kind) {
                var p,
                    in_for,
                    avoid_semicolon;
                output.print(kind);
                output.space();
                this.definitions.forEach(function (def, i) {
                    if (i) {
                        output.comma();
                    }
                    def.print(output);
                });
                p = output.parent();
                in_for = (p instanceof AST.For) || (p instanceof AST.ForIn);
                avoid_semicolon = in_for && (p.init === this);
                if (!avoid_semicolon) {
                    output.semicolon();
                }
            });
            DEFPRINT(AST.Var, function (self, output) {
                self._do_print(output, "var");
            });
            DEFPRINT(AST.Const, function (self, output) {
                self._do_print(output, "const");
            });

            DEFPRINT(AST.VarDef, function (self, output) {
                var p,
                    noin;
                self.name.print(output);
                if (self.value) {
                    output.space();
                    output.print("=");
                    output.space();
                    p = output.parent(1);
                    noin = (p instanceof AST.For) || (p instanceof AST.ForIn);
                    parenthesize_for_noin(self.value, output, noin);
                }
            });

            /* -----[ other expressions ]----- */
            DEFPRINT(AST.Call, function (self, output) {
                self.expression.print(output);
                if ((self instanceof AST.New) && no_constructor_parens(self, output)) {
                    return;
                }
                output.with_parens(function () {
                    self.args.forEach(function (expr, i) {
                        if (i) {
                            output.comma();
                        }
                        expr.print(output);
                    });
                });
            });
            DEFPRINT(AST.New, function (self, output) {
                output.print("new");
                output.space();
                AST.Call.prototype._codegen(self, output);
            });

            AST.Seq.DEFMETHOD("_do_print", function (output) {
                this.car.print(output);
                if (this.cdr) {
                    output.comma();
                    if (output.should_break()) {
                        output.newline();
                        output.indent();
                    }
                    this.cdr.print(output);
                }
            });
            DEFPRINT(AST.Seq, function (self, output) {
                self._do_print(output);
                // var p = output.parent();
                // if (p instanceof AST.Statement) {
                //     output.with_indent(output.next_indent(), function () {
                //         self._do_print(output);
                //     });
                // } else {
                //     self._do_print(output);
                // }
            });
            DEFPRINT(AST.Dot, function (self, output) {
                var expr = self.expression;
                expr.print(output);
                if (expr instanceof AST.Number && expr.getValue() >= 0) {
                    if (!/[xa-f.]/i.test(output.last())) {
                        output.print(".");
                    }
                }
                output.print(".");
                // the name after dot would be mapped about here.
                output.add_mapping(self.end);
                output.print_name(self.property);
            });
            DEFPRINT(AST.Sub, function (self, output) {
                self.expression.print(output);
                output.print("[");
                self.property.print(output);
                output.print("]");
            });
            DEFPRINT(AST.UnaryPrefix, function (self, output) {
                var op = self.operator;
                output.print(op);
                if (/^[a-z]/i.test(op) ||
                        (/[+\-]$/.test(op) &&
                            (self.expression instanceof AST.UnaryPrefix) &&
                            /^[+\-]/.test(self.expression.operator))) {
                    output.space();
                }
                self.expression.print(output);
            });
            DEFPRINT(AST.UnaryPostfix, function (self, output) {
                self.expression.print(output);
                output.print(self.operator);
            });
            DEFPRINT(AST.Binary, function (self, output) {
                self.left.print(output);
                output.space();
                output.print(self.operator);
                if ((self.operator === "<") &&
                        (self.right instanceof AST.UnaryPrefix) &&
                        (self.right.operator === "!") &&
                        (self.right.expression instanceof AST.UnaryPrefix) &&
                        (self.right.expression.operator === "--")) {
                    // space is mandatory to avoid outputting <!--
                    // http://javascript.spec.whatwg.org/#comment-syntax
                    output.print(" ");
                } else {
                    // the space is optional depending on "beautify"
                    output.space();
                }
                self.right.print(output);
            });
            DEFPRINT(AST.Conditional, function (self, output) {
                self.condition.print(output);
                output.space();
                output.print("?");
                output.space();
                self.consequent.print(output);
                output.space();
                output.colon();
                self.alternative.print(output);
            });

            /* -----[ literals ]----- */
            DEFPRINT(AST.Array, function (self, output) {
                output.with_square(function () {
                    var a = self.elements, len = a.length;
                    if (len > 0) {
                        output.space();
                    }
                    a.forEach(function (exp, i) {
                        if (i) {
                            output.comma();
                        }
                        exp.print(output);
                        // If the final element is a hole, we need to make sure it
                        // doesn't look like a trailing comma, by inserting an actual
                        // trailing comma.
                        if ((i === len - 1) && (exp instanceof AST.Hole)) {
                            output.comma();
                        }
                    });
                    if (len > 0) {
                        output.space();
                    }
                });
            });
            DEFPRINT(AST.Object, function (self, output) {
                if (self.properties.length > 0) {
                    output.with_block(function () {
                        self.properties.forEach(function (prop, i) {
                            if (i) {
                                output.print(",");
                                output.newline();
                            }
                            output.indent();
                            prop.print(output);
                        });
                        output.newline();
                    });
                } else {
                    output.print("{}");
                }
            });

            function getShortest(a) {
                var shortest = a[0],
                    len = shortest.length,
                    i;
                for (i = 1; i < a.length; ++i) {
                    if (a[i].length < len) {
                        shortest = a[i];
                        len = shortest.length;
                    }
                }
                return shortest;
            }

            function make_num(num) {
                /*jslint regexp:true */
                var str = num.toString(10),
                    a = [ str.replace(/^0\./, ".").replace('e+', 'e') ],
                    m;
                if (Math.floor(num) === num) {
                    if (num >= 0) {
                        a.push("0x" + num.toString(16).toLowerCase(), // probably pointless
                               "0" + num.toString(8)); // same.
                    } else {
                        a.push("-0x" + (-num).toString(16).toLowerCase(), // probably pointless
                               "-0" + (-num).toString(8)); // same.
                    }
                    m = /^(.*?)(0+)$/.exec(num);
                    if (m) {
                        a.push(m[1] + "e" + m[2].length);
                    }
                } else {
                    m = /^0?\.(0+)(.*)$/.exec(num);
                    if (m) {
                        a.push(m[2] + "e-" + (m[1].length + m[2].length),
                               str.substr(str.indexOf(".")));
                    }
                }
                return getShortest(a);
            }

            DEFPRINT(AST.ObjectKeyVal, function (self, output) {
                /*jslint eqeq: true */
                var key = self.key,
                    quote = self.quote,
                    shouldPrintName;
                if (output.option("quote_keys")) {
                    output.print_string(String(key));
                } else if (((typeof key === "number") || (!output.option("beautify") && (String(+key) == key))) &&
                        parseFloat(key) >= 0) {
                    output.print(make_num(key));
                } else {
                    shouldPrintName = predicates.RESERVED_WORDS(key) ? output.option("screw_ie8") : is.identifier_string(key);
                    if (shouldPrintName) {
                        output.print_name(key);
                    } else {
                        output.print_string(key, quote);
                    }
                }

                output.colon();
                self.value.print(output);
            });
            DEFPRINT(AST.ObjectSetter, function (self, output) {
                output.print("set");
                output.space();
                self.key.print(output);
                self.value._do_print(output, true);
            });
            DEFPRINT(AST.ObjectGetter, function (self, output) {
                output.print("get");
                output.space();
                self.key.print(output);
                self.value._do_print(output, true);
            });
            DEFPRINT(AST.Symbol, function (self, output) {
                var def = self.definition();
                output.print_name(def ? def.mangled_name || def.name : self.name);
            });
            DEFPRINT(AST.Undefined, function (self, output) {
                output.print("void 0");
            });
            DEFPRINT(AST.Hole, noop);
            DEFPRINT(AST.Infinity, function (self, output) {
                output.print("Infinity");
            });
            DEFPRINT(AST.NaN, function (self, output) {
                output.print("NaN");
            });
            DEFPRINT(AST.This, function (self, output) {
                output.print("this");
            });
            DEFPRINT(AST.Constant, function (self, output) {
                output.print(self.getValue());
            });
            DEFPRINT(AST.String, function (self, output) {
                output.print_string(self.getValue(), self.quote);
            });
            DEFPRINT(AST.Number, function (self, output) {
                output.print(make_num(self.getValue()));
            });

            function regexp_safe_literal(code) {
                return [
                    0x5c, // \
                    0x2f, // /
                    0x2e, // .
                    0x2b, // +
                    0x2a, // *
                    0x3f, // ?
                    0x28, // (
                    0x29, // )
                    0x5b, // [
                    0x5d, // ]
                    0x7b, // {
                    0x7d, // }
                    0x24, // $
                    0x5e, // ^
                    0x3a, // :
                    0x7c, // |
                    0x21, // !
                    0x0a, // \n
                    0x0d, // \r
                    0x00, // \0
                    0xfeff, // Unicode BOM
                    0x2028, // unicode "line separator"
                    0x2029  // unicode "paragraph separator"
                ].indexOf(code) < 0;
            }

            DEFPRINT(AST.RegExp, function (self, output) {
                var str = self.getValue().toString(),
                    p;
                if (output.option("ascii_only")) {
                    str = output.to_ascii(str);
                } else if (output.option("unescape_regexps")) {
                    str = str.split("\\\\").map(function (str) {
                        return str.replace(/\\u[0-9a-fA-F]{4}|\\x[0-9a-fA-F]{2}/g, function (s) {
                            var code = parseInt(s.substr(2), 16);
                            return regexp_safe_literal(code) ? String.fromCharCode(code) : s;
                        });
                    }).join("\\\\");
                }
                output.print(str);
                p = output.parent();
                if ((p instanceof AST.Binary) && (/^in/.test(p.operator)) && (p.left === self)) {
                    output.print(" ");
                }
            });

            /* -----[ source map generators ]----- */

            function DEFMAP(nodetype, generator) {
                nodetype.DEFMETHOD("add_source_map", function (stream) {
                    generator(this, stream);
                });
            }

            // We could easily add info for ALL nodes, but it seems to me that
            // would be quite wasteful, hence this noop in the base class.
            DEFMAP(AST.Node, noop);

            function basic_sourcemap_gen(self, output) {
                output.add_mapping(self.start);
            }

            // XXX: I'm not exactly sure if we need it for all of these nodes,
            // or if we should add even more.

            DEFMAP(AST.Directive, basic_sourcemap_gen);
            DEFMAP(AST.Debugger, basic_sourcemap_gen);
            DEFMAP(AST.Symbol, basic_sourcemap_gen);
            DEFMAP(AST.Jump, basic_sourcemap_gen);
            DEFMAP(AST.StatementWithBody, basic_sourcemap_gen);
            DEFMAP(AST.LabeledStatement, noop); // since the label symbol will mark it
            DEFMAP(AST.Lambda, basic_sourcemap_gen);
            DEFMAP(AST.Switch, basic_sourcemap_gen);
            DEFMAP(AST.SwitchBranch, basic_sourcemap_gen);
            DEFMAP(AST.BlockStatement, basic_sourcemap_gen);
            DEFMAP(AST.Toplevel, noop);
            DEFMAP(AST.New, basic_sourcemap_gen);
            DEFMAP(AST.Try, basic_sourcemap_gen);
            DEFMAP(AST.Catch, basic_sourcemap_gen);
            DEFMAP(AST.Finally, basic_sourcemap_gen);
            DEFMAP(AST.Definitions, basic_sourcemap_gen);
            DEFMAP(AST.Constant, basic_sourcemap_gen);
            DEFMAP(AST.ObjectProperty, function (self, output) {
                output.add_mapping(self.start, self.key);
            });

            AST.has_output_support = true;
        }
        return add_output_fns_to_AST;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "SymbolDef",
    [
        //no dependencies
    ],
    function () {
        
        function SymbolDef(scope, index, orig) {
            this.name = orig.name;
            this.orig = [ orig ];
            this.scope = scope;
            this.references = [];
            this.global = false;
            this.mangled_name = null;
            this.undeclared = false;
            this.constant = false;
            this.index = index;
        }

        SymbolDef.prototype = {
            unmangleable: function (options) {
                /*jslint evil:true*/ //not actually *using* eval here
                options = options || {};

                return (this.global && !options.toplevel) ||
                    this.undeclared ||
                    (!options.eval && (this.scope.uses_eval || this.scope.uses_with)) ||
                    (options.keep_fnames && this.orig[0] &&
                        ((this.orig[0].instanceof_SymbolLambda) ||
                            (this.orig[0].instanceof_SymbolDefun)));
            },
            mangle: function (options) {
                var s;
                if (!this.mangled_name && !this.unmangleable(options)) {
                    s = this.scope;
                    if (!options.screw_ie8 && this.orig[0] && this.orig[0].instanceof_SymbolLambda) {
                        s = s.parent_scope;
                    }
                    this.mangled_name = s.next_mangled(options, this);
                }
            }
        };

        return SymbolDef;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "add_scope_fns_to_AST",
    [
        "TreeWalker",
        "SymbolDef",
        "defaults",
        "Dictionary",
        "is",
        "merge_sort"
    ],
    function (TreeWalker, SymbolDef, defaults, Dictionary, is, merge_sort) {
        
        function add_scope_fns_to_AST(AST, warn) {
            var FrequencyCounter, get_var_namer;

            if (AST.has_scope_support) {
                return;
            }

            (function (merge_sort) {
                /*jslint plusplus: true*/

                //varname_chars: charCodes for a-z,A-Z,$,_,0-9
                var varname_chars = [97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 36, 95, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57];


                FrequencyCounter = function FrequencyCounter(init_frequencies) {
                    this.init(init_frequencies);
                };
                FrequencyCounter.prototype = {
                    init: function (init_frequencies) {
                        var self = this, fn;
                        self.frequency = Object.create(null);
                        if (!init_frequencies) {
                            fn = function (ch) {
                                self.frequency[ch] = 0;
                            };
                        } else {
                            fn = function (ch) {
                                self.frequency[ch] = (typeof init_frequencies[ch] === "number") ? init_frequencies[ch] : 0;
                            };
                        }
                        varname_chars.forEach(fn);
                    },
                    consider: function (str) {
                        var i,
                            cc,
                            self = this;
                        for (i = str.length - 1; i >= 0; --i) {
                            cc = str.charCodeAt(i);
                            if (Object.prototype.hasOwnProperty.call(self.frequency, cc)) {
                                ++self.frequency[cc];
                            }
                        }
                    },
                    frequencies: function () {
                        return this.frequency;
                    }
                };

                get_var_namer = function get_name_var(freqs) {
                    var chars;
                    function is_digit(code) {
                        return (code >= 48) && (code <= 57);
                    }
                    chars = merge_sort(varname_chars.slice(), function (a, b) {
                        if (is_digit(a) && !is_digit(b)) {
                            return 1;
                        }
                        if (is_digit(b) && !is_digit(a)) {
                            return -1;
                        }
                        if (!freqs) {
                            return 0;
                        }
                        return (freqs[b] || 0) - (freqs[a] || 0);
                    });
                    return function name_var(num) {
                        var name = "",
                            base = 54;
                        num++;
                        do {
                            num--;
                            name += String.fromCharCode(chars[num % base]);
                            num = Math.floor(num / base);
                            base = 64;
                        } while (num > 0);
                        return name;
                    };
                };
            }(merge_sort));

            /*jslint plusplus: true*/
            AST.Toplevel.DEFMETHOD("figure_out_scope", function (options) {
                var self,
                    scope,
                    defun,
                    nesting,
                    tw,
                    func,
                    globals;
                options = defaults(options, {
                    screw_ie8: false
                });

                // pass 1: setup scope chaining and handle definitions
                self = this;
                scope = self.parent_scope = null;
                defun = null;
                nesting = 0;
                tw = new TreeWalker(function (node, descend) {
                    var save_scope,
                        save_defun,
                        s,
                        def,
                        dir,
                        val;
                    if (options.screw_ie8 && node instanceof AST.Catch) {
                        save_scope = scope;
                        scope = new AST.Scope(node);
                        scope.init_scope_vars(nesting);
                        scope.parent_scope = save_scope;
                        descend();
                        scope = save_scope;
                        return true;
                    }
                    if (node instanceof AST.Scope) {
                        node.init_scope_vars(nesting);
                        save_scope = node.parent_scope = scope;
                        save_defun = defun;
                        defun = scope = node;
                        ++nesting;
                        descend();
                        --nesting;
                        scope = save_scope;
                        defun = save_defun;
                        return true;        // don't descend again in TreeWalker
                    }
                    if (node instanceof AST.Directive) {
                        node.scope = scope;
                        dir = scope.directives;
                        val = node.value;
                        if (dir.indexOf(val) === -1) {
                            dir.push(val);
                        }
                        return true;
                    }
                    if (node instanceof AST.With) {
                        for (s = scope; s; s = s.parent_scope) {
                            s.uses_with = true;
                        }
                        return;
                    }
                    if (node instanceof AST.Symbol) {
                        node.scope = scope;
                    }
                    if (node instanceof AST.SymbolLambda) {
                        defun.def_function(node);
                    } else if (node instanceof AST.SymbolDefun) {
                        // Careful here, the scope where this should be defined is
                        // the parent scope.  The reason is that we enter a new
                        // scope when we encounter the AST.Defun node (which is
                        // instanceof AST.Scope) but we get to the symbol a bit
                        // later.
                        node.scope = defun.parent_scope;
                        node.scope.def_function(node);
                    } else if ((node instanceof AST.SymbolVar) || (node instanceof AST.SymbolConst)) {
                        def = defun.def_variable(node);
                        def.constant = node instanceof AST.SymbolConst;
                        def.init = tw.parent().value;
                    } else if (node instanceof AST.SymbolCatch) {
                        (options.screw_ie8 ? scope : defun)
                            .def_variable(node);
                    }
                });
                self.walk(tw);

                // pass 2: find back references and eval
                func = null;
                globals = self.globals = new Dictionary();
                tw = new TreeWalker(function (node, descend) {
                    var prev_func,
                        name,
                        sym,
                        g,
                        s;
                    if (node instanceof AST.Lambda) {
                        prev_func = func;
                        func = node;
                        descend();
                        func = prev_func;
                        return true;
                    }
                    if (node instanceof AST.SymbolRef) {
                        name = node.name;
                        sym = node.scope.find_variable(name);
                        if (!sym) {
                            if (globals.has(name)) {
                                g = globals.get(name);
                            } else {
                                g = new SymbolDef(self, globals.size(), node);
                                g.undeclared = true;
                                g.global = true;
                                globals.set(name, g);
                            }
                            node.thedef = g;
                            if (name === "eval" && tw.parent() instanceof AST.Call) {
                                for (s = node.scope; s && !s.uses_eval; s = s.parent_scope) {
                                    s.uses_eval = true;
                                }
                            }
                            if (func && (name === "arguments")) {
                                func.uses_arguments = true;
                            }
                        } else {
                            node.thedef = sym;
                        }
                        node.reference();
                        return true;
                    }
                });
                self.walk(tw);
            });

            AST.Scope.DEFMETHOD("init_scope_vars", function (nesting) {
                this.directives = [];     // contains the directives defined in this scope, i.e. "use strict"
                this.variables = new Dictionary(); // map name to AST.SymbolVar (variables defined in this scope; includes functions)
                this.functions = new Dictionary(); // map name to AST.SymbolDefun (functions defined in this scope)
                this.uses_with = false;   // will be set to true if this or some nested scope uses the `with` statement
                this.uses_eval = false;   // will be set to true if this or nested scope uses the global `eval`
                this.parent_scope = null; // the parent scope
                this.enclosed = [];       // a list of variables from this or outer scope(s) that are referenced from this or inner scopes
                this.cname = -1;          // the current index for mangling functions/variables
                this.nesting = nesting;   // the nesting level of this scope (0 means toplevel)
            });

            AST.Scope.DEFMETHOD("strict", function () {
                return this.has_directive("use strict");
            });

            AST.Lambda.DEFMETHOD("init_scope_vars", function () {
                AST.Scope.prototype.init_scope_vars.apply(this, arguments);
                this.uses_arguments = false;
            });

            AST.SymbolRef.DEFMETHOD("reference", function () {
                var def = this.definition(),
                    s = this.scope,
                    enc;
                def.references.push(this);
                while (s) {
                    enc = s.enclosed;
                    if (enc.indexOf(def) === -1) {
                        enc.push(def);
                    }
                    if (s === def.scope) {
                        break;
                    }
                    s = s.parent_scope;
                }
                this.frame = this.scope.nesting - def.scope.nesting;
            });

            AST.Scope.DEFMETHOD("find_variable", function (name) {
                if (name instanceof AST.Symbol) {
                    name = name.name;
                }
                return this.variables.get(name) ||
                    (this.parent_scope && this.parent_scope.find_variable(name));
            });

            AST.Scope.DEFMETHOD("has_directive", function (value) {
                return (this.parent_scope && this.parent_scope.has_directive(value)) ||
                    (this.directives.indexOf(value) >= 0 ? this : null);
            });

            AST.Scope.DEFMETHOD("def_function", function (symbol) {
                this.functions.set(symbol.name, this.def_variable(symbol));
            });

            AST.Scope.DEFMETHOD("def_variable", function (symbol) {
                var def;
                if (!this.variables.has(symbol.name)) {
                    def = new SymbolDef(this, this.variables.size(), symbol);
                    this.variables.set(symbol.name, def);
                    def.global = !this.parent_scope;
                } else {
                    def = this.variables.get(symbol.name);
                    def.orig.push(symbol);
                }
                symbol.thedef = def;
                return symbol.thedef;
            });

            AST.Scope.DEFMETHOD("next_mangled", function (options) {
                var ext = this.enclosed,
                    m,
                    i,
                    sym,
                    name,
                    notDoneYet,
                    name_var = options.name_var || get_var_namer(options.char_frequencies);
                do {
                    notDoneYet = true;
                    m = name_var(++this.cname);
                    if (is.identifier(m) && (options.except.indexOf(m) === -1)) {
                        // https://github.com/mishoo/UglifyJS2/issues/242 -- do not
                        // shadow a name excepted from mangling.

                        notDoneYet = false;
                        // we must ensure that the mangled name does not shadow a name
                        // from some parent scope that is referenced in this or in
                        // inner scopes.
                        for (i = ext.length - 1; i >= 0; --i) {
                            sym = ext[i];
                            name = (sym.mangled_name || (sym.unmangleable(options) && sym.name));
                            if (m === name) {
                                notDoneYet = true;
                                break;
                            }
                        }
                    }
                } while (notDoneYet);
                return m;
            });

            AST.Function.DEFMETHOD("next_mangled", function (options, def) {
                // #179, #326
                // in Safari strict mode, something like (function x(x){...}) is a syntax error;
                // a function expression's argument cannot shadow the function expression's name

                var tricky_def = (def.orig[0] instanceof AST.SymbolFunarg) && this.name && this.name.definition(),
                    name;
                while (true) {
                    name = AST.Lambda.prototype.next_mangled.call(this, options, def);
                    if (!(tricky_def && (tricky_def.mangled_name === name))) {
                        return name;
                    }
                }
            });

            AST.Scope.DEFMETHOD("references", function (sym) {
                if (sym instanceof AST.Symbol) {
                    sym = sym.definition();
                }
                return this.enclosed.indexOf(sym) < 0 ? null : sym;
            });

            AST.Symbol.DEFMETHOD("unmangleable", function (options) {
                return this.definition().unmangleable(options);
            });

            // property accessors are not mangleable
            AST.SymbolAccessor.DEFMETHOD("unmangleable", function () {
                return true;
            });

            // labels are always mangleable
            AST.Label.DEFMETHOD("unmangleable", function () {
                return false;
            });

            AST.Symbol.DEFMETHOD("unreferenced", function () {
                return (this.definition().references.length === 0) &&
                    !(this.scope.uses_eval || this.scope.uses_with);
            });

            AST.Symbol.DEFMETHOD("undeclared", function () {
                return this.definition().undeclared;
            });

            AST.LabelRef.DEFMETHOD("undeclared", function () {
                return false;
            });

            AST.Label.DEFMETHOD("undeclared", function () {
                return false;
            });

            AST.Symbol.DEFMETHOD("definition", function () {
                return this.thedef;
            });

            AST.Symbol.DEFMETHOD("global", function () {
                return this.definition().global;
            });

            AST.Toplevel.DEFMETHOD("_default_mangler_options", function (options) {
                return defaults(options, {
                    except: [],
                    eval: false,
                    sort: false,
                    toplevel: false,
                    screw_ie8: false,
                    init_frequencies: null,
                    char_frequencies: null,
                    name_var: null
                });
            });

            AST.Toplevel.DEFMETHOD("mangle_names", function (options) {
                /*jslint nomen: true*/
                var lname,
                    to_mangle,
                    tw,
                    name_var;
                options = this._default_mangler_options(options);
                if (typeof options.name_var !== "function") {
                    options.name_var = get_var_namer(options.char_frequencies);
                }
                name_var = options.name_var;

                // We only need to mangle declaration nodes.  Special logic wired
                // into the code generator will display the mangled name if it's
                // present (and for AST.SymbolRef-s it'll use the mangled name of
                // the AST.SymbolDeclaration that it points to).
                lname = -1;
                to_mangle = [];
                tw = new TreeWalker(function (node, descend) {
                    var save_nesting,
                        a,
                        name;
                    if (node instanceof AST.LabeledStatement) {
                        // lname is incremented when we get to the AST.Label
                        save_nesting = lname;
                        descend();
                        lname = save_nesting;
                        return true;        // don't descend again in TreeWalker
                    }
                    if (node instanceof AST.Scope) {
                        a = [];
                        node.variables.each(function (symbol) {
                            if (options.except.indexOf(symbol.name) < 0) {
                                a.push(symbol);
                            }
                        });
                        if (options.sort) {
                            a.sort(function (a, b) {
                                return b.references.length - a.references.length;
                            });
                        }
                        to_mangle.push.apply(to_mangle, a);
                        return;
                    }
                    if (node instanceof AST.Label) {
                        do {
                            name = name_var(++lname);
                        } while (!is.identifier(name));
                        node.mangled_name = name;
                        return true;
                    }
                    if (options.screw_ie8 && node instanceof AST.SymbolCatch) {
                        to_mangle.push(node.definition());
                        return;
                    }
                });
                this.walk(tw);
                to_mangle.forEach(function (def) {
                    def.mangle(options);
                });
            });

            AST.Toplevel.DEFMETHOD("compute_char_frequency", function (options) {
                /*jslint nomen: true*/
                options = this._default_mangler_options(options);
                var freq_counter = new FrequencyCounter(options.init_frequencies),
                    tw;
                tw = new TreeWalker(function (node) {
                    if (node instanceof AST.Constant) {
                        freq_counter.consider(node.print_to_string());
                    } else if (node instanceof AST.Return) {
                        freq_counter.consider("return");
                    } else if (node instanceof AST.Throw) {
                        freq_counter.consider("throw");
                    } else if (node instanceof AST.Continue) {
                        freq_counter.consider("continue");
                    } else if (node instanceof AST.Break) {
                        freq_counter.consider("break");
                    } else if (node instanceof AST.Debugger) {
                        freq_counter.consider("debugger");
                    } else if (node instanceof AST.Directive) {
                        freq_counter.consider(node.value);
                    } else if (node instanceof AST.While) {
                        freq_counter.consider("while");
                    } else if (node instanceof AST.Do) {
                        freq_counter.consider("do while");
                    } else if (node instanceof AST.If) {
                        freq_counter.consider("if");
                        if (node.alternative) {
                            freq_counter.consider("else");
                        }
                    } else if (node instanceof AST.Var) {
                        freq_counter.consider("var");
                    } else if (node instanceof AST.Const) {
                        freq_counter.consider("const");
                    } else if (node instanceof AST.Lambda) {
                        freq_counter.consider("function");
                    } else if (node instanceof AST.For) {
                        freq_counter.consider("for");
                    } else if (node instanceof AST.ForIn) {
                        freq_counter.consider("for in");
                    } else if (node instanceof AST.Switch) {
                        freq_counter.consider("switch");
                    } else if (node instanceof AST.Case) {
                        freq_counter.consider("case");
                    } else if (node instanceof AST.Default) {
                        freq_counter.consider("default");
                    } else if (node instanceof AST.With) {
                        freq_counter.consider("with");
                    } else if (node instanceof AST.ObjectSetter) {
                        freq_counter.consider("set" + node.key);
                    } else if (node instanceof AST.ObjectGetter) {
                        freq_counter.consider("get" + node.key);
                    } else if (node instanceof AST.ObjectKeyVal) {
                        freq_counter.consider(node.key);
                    } else if (node instanceof AST.New) {
                        freq_counter.consider("new");
                    } else if (node instanceof AST.This) {
                        freq_counter.consider("this");
                    } else if (node instanceof AST.Try) {
                        freq_counter.consider("try");
                    } else if (node instanceof AST.Catch) {
                        freq_counter.consider("catch");
                    } else if (node instanceof AST.Finally) {
                        freq_counter.consider("finally");
                    } else if ((node instanceof AST.Symbol) && node.unmangleable(options)) {
                        freq_counter.consider(node.name);
                    } else if ((node instanceof AST.Unary) || (node instanceof AST.Binary)) {
                        freq_counter.consider(node.operator);
                    } else if (node instanceof AST.Dot) {
                        freq_counter.consider(node.property);
                    }
                });
                this.walk(tw);
                options.char_frequencies = freq_counter.frequencies();
                return options.char_frequencies;
            });

            AST.Toplevel.DEFMETHOD("scope_warnings", function (options) {
                options = defaults(options, {
                    undeclared: false, // this makes a lot of noise
                    unreferenced: true,
                    assign_to_global: true,
                    func_arguments: true,
                    nested_defuns: true,
                    eval: true
                });
                var tw = new TreeWalker(function (node) {
                    /*jslint evil: true*/
                    if (options.undeclared &&
                            (node instanceof AST.SymbolRef) &&
                            node.undeclared()) {
                        // XXX: this also warns about JS standard names,
                        // i.e. Object, Array, parseInt etc.  Should add a list of
                        // exceptions.
                        warn("Undeclared symbol: {name} [{file}:{line},{col}]", {
                            name: node.name,
                            file: node.start.file,
                            line: node.start.line,
                            col: node.start.col
                        });
                    }
                    if (options.assign_to_global) {
                        var sym = null;
                        if ((node instanceof AST.Assign) && (node.left instanceof AST.SymbolRef)) {
                            sym = node.left;
                        } else if ((node instanceof AST.ForIn) && (node.init instanceof AST.SymbolRef)) {
                            sym = node.init;
                        }
                        if (sym && (sym.undeclared() || (sym.global() && (sym.scope !== sym.definition().scope)))) {
                            warn("{msg}: {name} [{file}:{line},{col}]", {
                                msg: sym.undeclared() ? "Accidental global?" : "Assignment to global",
                                name: sym.name,
                                file: sym.start.file,
                                line: sym.start.line,
                                col: sym.start.col
                            });
                        }
                    }
                    if (options.eval &&
                            (node instanceof AST.SymbolRef) &&
                            node.undeclared() &&
                            (node.name === "eval")) {
                        warn("Eval is used [{file}:{line},{col}]", node.start);
                    }
                    if (options.unreferenced &&
                            ((node instanceof AST.SymbolDeclaration) || (node instanceof AST.Label)) &&
                            !(node instanceof AST.SymbolCatch) &&
                            node.unreferenced()) {
                        warn("{type} {name} is declared but not referenced [{file}:{line},{col}]", {
                            type: node instanceof AST.Label ? "Label" : "Symbol",
                            name: node.name,
                            file: node.start.file,
                            line: node.start.line,
                            col: node.start.col
                        });
                    }
                    if (options.func_arguments && (node instanceof AST.Lambda) && node.uses_arguments) {
                        warn("arguments used in function {name} [{file}:{line},{col}]", {
                            name: node.name ? node.name.name : "anonymous",
                            file: node.start.file,
                            line: node.start.line,
                            col: node.start.col
                        });
                    }
                    if (options.nested_defuns && (node instanceof AST.Defun) && !(tw.parent() instanceof AST.Scope)) {
                        warn("Function {name} declared in nested statement \"{type}\" [{file}:{line},{col}]", {
                            name: node.name.name,
                            type: tw.parent().TYPE,
                            file: node.start.file,
                            line: node.start.line,
                            col: node.start.col
                        });
                    }
                });
                this.walk(tw);
            });

            AST.has_scope_support = true;
        }
        return add_scope_fns_to_AST;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "add_transform_fns_to_AST",
    [
        "MAP"
    ],
    function (MAP) {
        function add_transform_fns_to_AST(AST) {
            

            /*jslint nomen: true */
            var UNDEF = (function () {
                    return;
                }());

            if (AST.has_transform_support) {
                return;
            }

            function _(node, descend) {
                node.DEFMETHOD("transform", function (tw, in_list) {
                    var x, y;
                    tw.push(this);
                    if (tw.before) {
                        x = tw.before(this, descend, in_list);
                    }
                    if (x === UNDEF) {
                        if (!tw.after) {
                            x = this;
                            descend(x, tw);
                        } else {
                            tw.stack[tw.stack.length - 1] = x = this.clone();
                            descend(x, tw);
                            y = tw.after(x, in_list);
                            if (y !== UNDEF) {
                                x = y;
                            }
                        }
                    }
                    tw.pop();
                    return x;
                });
            }

            function do_list(list, tw) {
                return MAP(list, function (node) {
                    return node.transform(tw, true);
                });
            }

            _(AST.Node, function () {
                return;
            });

            _(AST.LabeledStatement, function (self, tw) {
                self.label = self.label.transform(tw);
                self.body = self.body.transform(tw);
            });

            _(AST.SimpleStatement, function (self, tw) {
                self.body = self.body.transform(tw);
            });

            _(AST.Block, function (self, tw) {
                self.body = do_list(self.body, tw);
            });

            _(AST.DWLoop, function (self, tw) {
                self.condition = self.condition.transform(tw);
                self.body = self.body.transform(tw);
            });

            _(AST.For, function (self, tw) {
                if (self.init) {
                    self.init = self.init.transform(tw);
                }
                if (self.condition) {
                    self.condition = self.condition.transform(tw);
                }
                if (self.step) {
                    self.step = self.step.transform(tw);
                }
                self.body = self.body.transform(tw);
            });

            _(AST.ForIn, function (self, tw) {
                self.init = self.init.transform(tw);
                self.object = self.object.transform(tw);
                self.body = self.body.transform(tw);
            });

            _(AST.With, function (self, tw) {
                self.expression = self.expression.transform(tw);
                self.body = self.body.transform(tw);
            });

            _(AST.Exit, function (self, tw) {
                if (self.value) {
                    self.value = self.value.transform(tw);
                }
            });

            _(AST.LoopControl, function (self, tw) {
                if (self.label) {
                    self.label = self.label.transform(tw);
                }
            });

            _(AST.If, function (self, tw) {
                self.condition = self.condition.transform(tw);
                self.body = self.body.transform(tw);
                if (self.alternative) {
                    self.alternative = self.alternative.transform(tw);
                }
            });

            _(AST.Switch, function (self, tw) {
                self.expression = self.expression.transform(tw);
                self.body = do_list(self.body, tw);
            });

            _(AST.Case, function (self, tw) {
                self.expression = self.expression.transform(tw);
                self.body = do_list(self.body, tw);
            });

            _(AST.Try, function (self, tw) {
                self.body = do_list(self.body, tw);
                if (self.bcatch) {
                    self.bcatch = self.bcatch.transform(tw);
                }
                if (self.bfinally) {
                    self.bfinally = self.bfinally.transform(tw);
                }
            });

            _(AST.Catch, function (self, tw) {
                self.argname = self.argname.transform(tw);
                self.body = do_list(self.body, tw);
            });

            _(AST.Definitions, function (self, tw) {
                self.definitions = do_list(self.definitions, tw);
            });

            _(AST.VarDef, function (self, tw) {
                self.name = self.name.transform(tw);
                if (self.value) {
                    self.value = self.value.transform(tw);
                }
            });

            _(AST.Lambda, function (self, tw) {
                if (self.name) {
                    self.name = self.name.transform(tw);
                }
                self.argnames = do_list(self.argnames, tw);
                self.body = do_list(self.body, tw);
            });

            _(AST.Call, function (self, tw) {
                self.expression = self.expression.transform(tw);
                self.args = do_list(self.args, tw);
            });

            _(AST.Seq, function (self, tw) {
                self.car = self.car.transform(tw);
                self.cdr = self.cdr.transform(tw);
            });

            _(AST.Dot, function (self, tw) {
                self.expression = self.expression.transform(tw);
            });

            _(AST.Sub, function (self, tw) {
                self.expression = self.expression.transform(tw);
                self.property = self.property.transform(tw);
            });

            _(AST.Unary, function (self, tw) {
                self.expression = self.expression.transform(tw);
            });

            _(AST.Binary, function (self, tw) {
                self.left = self.left.transform(tw);
                self.right = self.right.transform(tw);
            });

            _(AST.Conditional, function (self, tw) {
                self.condition = self.condition.transform(tw);
                self.consequent = self.consequent.transform(tw);
                self.alternative = self.alternative.transform(tw);
            });

            _(AST.Array, function (self, tw) {
                self.elements = do_list(self.elements, tw);
            });

            _(AST.Object, function (self, tw) {
                self.properties = do_list(self.properties, tw);
            });

            _(AST.ObjectProperty, function (self, tw) {
                self.value = self.value.transform(tw);
            });

            AST.has_transform_support = true;
        }
        return add_transform_fns_to_AST;
    }
);

/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "add_wrap_fns_to_AST",
    [
        "TreeTransformer",
        "TreeWalker",
        "parse",
        "MAP",
        "find_if"
    ],
    function (TreeTransformer, TreeWalker, parse, MAP, find_if) {
        
        function add_wrap_fns_to_AST(AST) {

            if (AST.has_wrap_support) {
                return;
            }

            function wrap_enclose(arg_parameter_pairs) {
                /*jshint validthis: true */
                var self = this,
                    args = [],
                    parameters = [],
                    wrapped_tl;

                arg_parameter_pairs.forEach(function (pair) {
                    var splitAt = pair.lastIndexOf(":");
                    args.push(pair.substr(0, splitAt));
                    parameters.push(pair.substr(splitAt + 1));
                });

                wrapped_tl = "(function(" + parameters.join(",") + "){ '$ORIG'; })(" + args.join(",") + ")";
                wrapped_tl = parse(wrapped_tl);
                wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node) {
                    if ((node instanceof AST.Directive) && (node.value === "$ORIG")) {
                        return MAP.splice(self.body);
                    }
                }));
                return wrapped_tl;
            }
            function wrap_commonjs(name, export_all) {
                /*jshint validthis: true */
                var self = this,
                    to_export = [],
                    wrapped_tl;
                if (export_all) {
                    self.figure_out_scope();
                    self.walk(new TreeWalker(function (node) {
                        if (node instanceof AST.SymbolDeclaration && node.definition().global) {
                            if (!find_if(function (n) {
                                    return n.name === node.name;
                                }, to_export)) {
                                to_export.push(node);
                            }
                        }
                    }));
                }
                wrapped_tl = "(function(exports, global){ global['" + name + "'] = exports; '$ORIG'; '$EXPORTS'; }({}, (function(){return this}())))";
                wrapped_tl = parse(wrapped_tl);
                wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node) {
                    if (node instanceof AST.SimpleStatement) {
                        node = node.body;
                        if (node instanceof AST.String) {
                            switch (node.getValue()) {
                            case "$ORIG":
                                return MAP.splice(self.body);
                            case "$EXPORTS":
                                var body = [];
                                to_export.forEach(function (sym) {
                                    body.push(new AST.SimpleStatement({
                                        body: new AST.Assign({
                                            left: new AST.Sub({
                                                expression: new AST.SymbolRef({ name: "exports" }),
                                                property: new AST.String({ value: sym.name })
                                            }),
                                            operator: "=",
                                            right: new AST.SymbolRef(sym)
                                        })
                                    }));
                                });
                                return MAP.splice(body);
                            }
                        }
                    }
                }));
                return wrapped_tl;
            }
            AST.Toplevel.DEFMETHOD("wrap_enclose", wrap_enclose);
            AST.Toplevel.DEFMETHOD("wrap_commonjs", wrap_commonjs);

            AST.has_wrap_support = true;
        }
        return add_wrap_fns_to_AST;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "describe_ast",
    [
        //no dependencies
    ],
    function () {
        
        function print_description(out, NodeType) {
            out.print("AST." + NodeType.TYPE);
            var props = NodeType.SELF_PROPS.filter(function (prop) {
                return !/^\$/.test(prop);
            });
            if (props.length > 0) {
                out.space();
                out.with_parens(function () {
                    props.forEach(function (prop, i) {
                        if (i) {
                            out.space();
                        }
                        out.print(prop);
                    });
                });
            }
            if (NodeType.documentation) {
                out.space();
                out.print_string(out, NodeType.documentation);
            }
            if (NodeType.SUBCLASSES.length > 0) {
                out.space();
                out.with_block(function () {
                    NodeType.SUBCLASSES.forEach(function (NodeType) {
                        out.indent();
                        print_description(NodeType);
                        out.newline();
                    });
                });
            }
        }

        function describe_ast(AST, out) {
            print_description(out, AST.Node);
            return String(out);
        }

        return describe_ast;
    }
);
/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "get_uglyfly",
    [
        "get_warn",
        "merge",
        "AST",
        "Compressor",
        "SourceMap",
        "OutputStream",
        "parse",
        "add_compress_fns_to_AST",
        "add_moz_fns_to_AST",
        "add_output_fns_to_AST",
        "add_scope_fns_to_AST",
        "add_transform_fns_to_AST",
        "add_wrap_fns_to_AST",
        "describe_ast"
    ],
    function (get_warn, merge, AST, Compressor, SourceMap, OutputStream, parse,
        add_compress_fns_to_AST, add_moz_fns_to_AST, add_output_fns_to_AST,
        add_scope_fns_to_AST, add_transform_fns_to_AST, add_wrap_fns_to_AST,
        describe_ast) {
        

        function get_uglyfly(MOZ_SourceMap, warn_callback, croak_callback) {
            var u = {},
                warn = get_warn(warn_callback);


            add_moz_fns_to_AST(AST);
            add_wrap_fns_to_AST(AST);
            add_transform_fns_to_AST(AST);
            add_scope_fns_to_AST(AST, warn);
            add_output_fns_to_AST(AST);
            add_compress_fns_to_AST(AST, warn_callback, croak_callback);

            u.get_compressor = function (options, false_by_default) {
                return new Compressor(options, false_by_default, warn, croak_callback);
            };

            u.get_source_map = function (options) {
                return new SourceMap(MOZ_SourceMap, options);
            };

            u.get_output_stream = function (options) {
                return new OutputStream(options, warn, croak_callback);
            };

            u.from_mozilla_ast = function (mozilla_ast) {
                return AST.Node.from_mozilla_ast(mozilla_ast);
            };

            u.parse = function ($TEXT, options) {
                return parse(AST, $TEXT, options);
            };

            u.describe_ast = function (output_stream) {
                if (!output_stream instanceof OutputStream) {
                    output_stream = new OutputStream({
                        beautify: true
                    }, warn, croak_callback);
                }
                return describe_ast(AST, output_stream);
            };

            u.compress = function (toplevel, compressOptions, warningOptions) {
                var options = {
                    warnings: warningOptions
                };
                toplevel.figure_out_scope(compressOptions);
                toplevel = toplevel.transform(u.get_compressor(merge(options, compressOptions)));
                return toplevel;
            };

            u.mangle = function (toplevel, mangleOptions) {
                mangleOptions = mangleOptions || {};
                toplevel.figure_out_scope(mangleOptions);
                if (!mangleOptions.char_frequencies) {
                    toplevel.compute_char_frequency(mangleOptions);
                }
                toplevel.mangle_names(mangleOptions);
                return toplevel;
            };

            u.process = function (toplevel, options, output) {
                var stream,
                    js,
                    source_map,
                    results;
                if (options.compress) {
                    u.compress(toplevel, options.compress, options.warnings);
                }
                if (options.mangle) {
                    u.mangle(toplevel, options.mangle);
                }
                output = output || {};
                if (options.output) {
                    merge(output, options.output);
                }

                stream = u.get_output_stream(output);
                toplevel.print(stream);

                js = stream.toString();
                source_map = output.source_map ? output.source_map.toString() : null;

                if (options.sourceMapURL) {
                    js += '\n//# sourceMappingURL=' + options.sourceMapURL;
                }

                results = {};
                results.js = js;
                results.source_map = source_map;
                return results;
            };

            return u;
        }

        return get_uglyfly;
    }
);
/***********************************************************************
 Copyright (c)
   Saair Quaderi <saair.quaderi@gmail.com> (UglyflyJS)
 ***********************************************************************/

/*globals define, module, require */

define(
    "get_promisify",
    [
    ],
    function () {
        
        function get_promisify(Promise) {
            if (typeof Promise !== 'function') {
                throw new TypeError('Promise is not a function');
            }

            /* promisify(fn, [receiver]) - Convert a function that expects a callback into a function that returns a Promise
             *  fn: A node-style asynchronus function:
             *        A node-style asynchronus function is a function which accepts a regular/irregular node-style callback function as a final argument
             *        A node-style callback function is a function expects the first argument to be an error or a falsy value if there was no error
             *           A regular node-style callback function takes any potential success value as only the second argument and accepts no other arguments
             *           An irregular node-style callback function expects multiple success values (with the first success value as the second argument)
             *            *Note: if the callback receives multiple values (has more than a second argument passed in), it is treated as irregular and
             *                   the success values will be resolved by the Promise in the form of an array
             *  [thisArg]: An optional argument that provides the thisArg to be used as the context when running the asynchronous function
             */
            function promisify(fn, thisArg) {
                var thisArgProvided = (arguments.length >= 2);
                if (typeof fn !== 'function') {
                    throw new TypeError('A function must be provided for promisification');
                }
                function promisifiedAsyncFn() { //expects same args as fn would have accepted except without the final argument (the callback function)
                    var argsArr = Array.prototype.slice.call(arguments);
                    thisArg = thisArgProvided ? thisArg : this;
                    return new Promise(function (resolve, reject) { //call promise constructor with function that takes resolve and reject callbacks as inputs
                        argsArr.push(function (err, result) { //node-style callback that ends the node-style callback chain and instead calls resolve and reject callbacks
                            if (err) {
                                reject(err);
                            } else {
                                resolve((arguments.length > 2) ? Array.prototype.slice.call(arguments, 1) : result);
                            }
                        });
                        fn.apply(thisArg, argsArr);
                    });
                }
                return promisifiedAsyncFn;
            }
            return promisify;
        }
        return get_promisify;
    }
);

/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

define(
    "get_uglyfly_api",
    [
        "get_uglyfly",
        "defaults",
        "get_promisify"
    ],
    function (get_uglyfly, defaults, get_promisify) {
        

        function get_uglyfly_api(dependencyHooks) {
            var api,
                getSourceMapPromise,
                getFilePromise,
                Buffer,
                Promise,
                promisify,
                MOZ_SourceMap,
                getFileContentsPromise,
                warn_callback,
                croak_callback,
                noop,
                UglyflyJS;

            noop = function () {
                return;
            };

            if (!dependencyHooks) {
                throw "Dependency hooks must be provided.";
            }

            Buffer = dependencyHooks.Buffer;
            Promise = dependencyHooks.Promise;
            MOZ_SourceMap = dependencyHooks.MOZ_SourceMap;
            getFileContentsPromise = dependencyHooks.getFileContentsPromise;
            warn_callback = dependencyHooks.warn_callback || noop;
            croak_callback = dependencyHooks.croak_callback || noop;

            if (typeof Promise !== 'function') {
                throw new TypeError('Promise dependency must be a function, specifically a promise constructor. Example Promise library: bluebird (https://github.com/petkaantonov/bluebird).');
            }

            promisify = get_promisify(Promise);

            function asResolvedPromise(value) {
                var args = [null].concat((arguments.length < 2) ? [value] : Array.prototype.slice(arguments));
                return promisify(function (callback) {
                    callback.apply(null, args);
                })();
            }

            UglyflyJS = get_uglyfly(MOZ_SourceMap, warn_callback, croak_callback);

            function getFile(file, options, cb) {
                var readpath, isBuffer;

                if (typeof file === 'string') {
                    file = {
                        path: file
                    };
                }

                if (file && (typeof file.path === 'string')) {
                    if (file.contents) {
                        isBuffer = (typeof Buffer === 'function') && (file.contents instanceof Buffer);
                        if (isBuffer || (typeof file.contents === 'string')) {
                            return cb(null, {
                                path: file.path,
                                contents: isBuffer ? file.contents.toString() : file.contents
                            });
                        }
                    }
                    readpath = (typeof file.readpath === 'string') ? file.readpath : file.path;

                    if (!getFileContentsPromise) {
                        throw "Missing dependency hook. The getFileContentsPromise dependency function was not provided.";
                    }

                    return getFileContentsPromise(readpath).then(function (contents) {
                        return cb(null, {
                            path: file.path,
                            contents: contents
                        });
                    }).catch(function (err) {
                        return cb(err);
                    });
                }

                options = options || {};
                if (!options.isRequired && !file) {
                    return cb();
                }
                return cb(new Error('The ' +
                    (options.isRequired ? 'required ' : '') +
                    (options.sourceDesc || 'input file') +
                    ' was not specified in a recognized format'));
            }
            getFilePromise = promisify(getFile);

            function getSourceMap(sourceRoot, outSourceMap, inSourceMap, shouldIncludeSources, fileSources, outFilename, cb) {
                var inSourceMapPromise = null,
                    hasOwn = Object.prototype.hasOwnProperty;
                if (!outSourceMap) {
                    return cb();
                }

                if (((typeof inSourceMap === "string") && (inSourceMap.charAt("0") !== "{")) ||
                        (inSourceMap && hasOwn.call(inSourceMap, "path") && hasOwn.call(inSourceMap, "contents"))) {
                    inSourceMapPromise = getFilePromise(inSourceMap, {
                        sourceDesc: 'input source map'
                    }).then(function (file) {
                        return file.contents;
                    });
                } else {
                    inSourceMapPromise = asResolvedPromise(inSourceMap);
                }

                return inSourceMapPromise.then(function (inSourceMap) {
                    var source_map;

                    if (!MOZ_SourceMap) {
                        throw "Missing dependency hook. Mozilla's source map library must be provided. (https://github.com/mozilla/source-map/).";
                    }

                    source_map = new UglyflyJS.get_source_map({
                        file: outFilename,
                        orig: inSourceMap,
                        root: sourceRoot
                    });
                    if (shouldIncludeSources) {
                        fileSources.forEach(function (source) {
                            source_map.get().setSourceContent(source.path, source.content);
                        });
                    }

                    return cb(null, {
                        source_map: source_map
                    });
                }).catch(function (err) {
                    return cb(err);
                });
            }
            getSourceMapPromise = promisify(getSourceMap);

            function process(input, options, cb) {
                var toplevel = null,
                    fileSources = [];

                if (!Array.isArray(input)) {
                    input = [ input ];
                }
                if (options.fromString) {
                    input = input.map(function (contents, i) {
                        return {
                            path: 'fakepath' + (i + 1) + '.js',
                            contents: contents
                        };
                    });
                }
                delete options.fromString;

                if ((typeof options.sourceMapURL !== 'string') &&
                        (typeof options.outSourceMap === 'string') &&
                            (options.sourceMapURL !== false)) {
                    options.sourceMapURL = options.outSourceMap;
                }

                return promisify(function (cb) {

                    if (options.spidermonkey) {
                        toplevel = UglyflyJS.from_mozilla_ast(input);
                        return cb();
                    }

                    asResolvedPromise(input).each(
                        function (file, index) {
                            return getFilePromise(file, {isRequired: true}).then(function (source) {
                                if (options.outSourceMap && options.sourceMapIncludeSources && source.path) {
                                    fileSources[index] = source;
                                }
                                toplevel = UglyflyJS.parse(source.contents, {
                                    filename: source.path,
                                    toplevel: toplevel
                                });
                            });
                        }
                    ).then(function () {
                        return cb();
                    }).catch(function (err) {
                        return cb(err);
                    });
                })().then(function () {
                    return getSourceMapPromise(
                        options.sourceRoot,
                        options.outSourceMap,
                        options.inSourceMap,
                        !!options.sourceMapIncludeSources,
                        fileSources,
                        options.sourcemapFileProperty
                    );
                }).then(function (output) {
                    var results = UglyflyJS.process(toplevel, options, output);

                    return cb(null, {
                        code: results.js,
                        map: results.source_map
                    });
                }).catch(function (err) {
                    return cb(err);
                });
            }

            function minify(input, options, cb) {
                if (typeof options === 'function') {
                    cb = options;
                    options = null;
                }
                if (typeof cb !== 'function') {
                    return;
                }

                options = defaults(options, {
                    spidermonkey: false,

                    sourceRoot: null,
                    outSourceMap: false,
                    sourcemapFileProperty: null,
                    inSourceMap : null,
                    sourceMapIncludeSources: false,

                    sourceMapURL: null,

                    warnings: false,
                    mangle: {},
                    output: {},
                    compress: {},

                    fromString: false
                });
                return process(input, options, cb);
            }

            function beautify(input, options, cb) {
                if (typeof options === 'function') {
                    cb = options;
                    options = null;
                }
                if (typeof cb !== 'function') {
                    return;
                }

                options = defaults(options, {
                    spidermonkey: false,

                    sourceRoot: null,
                    outSourceMap: false,
                    sourcemapFileProperty: null,
                    inSourceMap : null,
                    sourceMapIncludeSources: false,

                    sourceMapURL: null,

                    warnings: false,
                    mangle: false,
                    output: {
                        beautify: true,
                        comments: true
                    },
                    compress: false,

                    fromString: false
                });
                return process(input, options, cb);
            }

            function parse($TEXT, options, cb) {
                if (typeof options === 'function') {
                    cb = options;
                    options = null;
                }
                if (typeof cb !== 'function') {
                    return;
                }
                try {
                    return cb(null, UglyflyJS.parse($TEXT, options));
                } catch (ex) {
                    return cb(ex);
                }
            }

            function compress(toplevel, compressOptions, warningOptions, cb) {
                if (typeof warningOptions === 'function') {
                    cb = warningOptions;
                    warningOptions = null;
                }
                if (typeof compressOptions === 'function') {
                    cb = compressOptions;
                    compressOptions = null;
                }
                if (typeof cb !== 'function') {
                    return;
                }
                try {
                    return cb(null, UglyflyJS.compress(toplevel, compressOptions, warningOptions));
                } catch (ex) {
                    return cb(ex);
                }
            }

            function from_mozilla_ast(mozilla_ast, cb) {
                if (typeof cb !== 'function') {
                    return;
                }
                try {
                    return cb(null, UglyflyJS.from_mozilla_ast(mozilla_ast));
                } catch (ex) {
                    return cb(ex);
                }
            }

            api = {
                beautify: beautify,
                compress: compress,
                from_mozilla_ast: from_mozilla_ast,
                minify: minify,
                parse: parse
            };
            return api;
        }
        return get_uglyfly_api;
    }
);
