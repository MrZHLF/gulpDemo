/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

((typeof define === "function") ? define :
        function () { "use strict"; require('./nd').apply(module, arguments); })(
    "add_wrap_fns_to_AST",
    [
        "TreeTransformer",
        "TreeWalker",
        "parse",
        "MAP",
        "find_if"
    ],
    function (TreeTransformer, TreeWalker, parse, MAP, find_if) {
        "use strict";
        function add_wrap_fns_to_AST(AST) {

            if (AST.has_wrap_support) {
                return;
            }

            function wrap_enclose(arg_parameter_pairs) {
                /*jshint validthis: true */
                var self = this,
                    args = [],
                    parameters = [],
                    wrapped_tl;

                arg_parameter_pairs.forEach(function (pair) {
                    var splitAt = pair.lastIndexOf(":");
                    args.push(pair.substr(0, splitAt));
                    parameters.push(pair.substr(splitAt + 1));
                });

                wrapped_tl = "(function(" + parameters.join(",") + "){ '$ORIG'; })(" + args.join(",") + ")";
                wrapped_tl = parse(wrapped_tl);
                wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node) {
                    if ((node instanceof AST.Directive) && (node.value === "$ORIG")) {
                        return MAP.splice(self.body);
                    }
                }));
                return wrapped_tl;
            }
            function wrap_commonjs(name, export_all) {
                /*jshint validthis: true */
                var self = this,
                    to_export = [],
                    wrapped_tl;
                if (export_all) {
                    self.figure_out_scope();
                    self.walk(new TreeWalker(function (node) {
                        if (node instanceof AST.SymbolDeclaration && node.definition().global) {
                            if (!find_if(function (n) {
                                    return n.name === node.name;
                                }, to_export)) {
                                to_export.push(node);
                            }
                        }
                    }));
                }
                wrapped_tl = "(function(exports, global){ global['" + name + "'] = exports; '$ORIG'; '$EXPORTS'; }({}, (function(){return this}())))";
                wrapped_tl = parse(wrapped_tl);
                wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node) {
                    if (node instanceof AST.SimpleStatement) {
                        node = node.body;
                        if (node instanceof AST.String) {
                            switch (node.getValue()) {
                            case "$ORIG":
                                return MAP.splice(self.body);
                            case "$EXPORTS":
                                var body = [];
                                to_export.forEach(function (sym) {
                                    body.push(new AST.SimpleStatement({
                                        body: new AST.Assign({
                                            left: new AST.Sub({
                                                expression: new AST.SymbolRef({ name: "exports" }),
                                                property: new AST.String({ value: sym.name })
                                            }),
                                            operator: "=",
                                            right: new AST.SymbolRef(sym)
                                        })
                                    }));
                                });
                                return MAP.splice(body);
                            }
                        }
                    }
                }));
                return wrapped_tl;
            }
            AST.Toplevel.DEFMETHOD("wrap_enclose", wrap_enclose);
            AST.Toplevel.DEFMETHOD("wrap_commonjs", wrap_commonjs);

            AST.has_wrap_support = true;
        }
        return add_wrap_fns_to_AST;
    }
);