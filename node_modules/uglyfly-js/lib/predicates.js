/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/
//Note:
//  This achieves the same effect as predicates.js but with slightly slower
//    but significantly more compact code (suitable for bundling)
//  The code for the functions in predicates.js are effectively generated
//    with this file

/*globals define, module, require */

((typeof define === "function") ? define :
        function () { "use strict"; require('./nd').apply(module, arguments); })(
    "predicates",
    [
        //no dependencies
    ],
    function () {
        "use strict";
        var predicates = {},
            WORDS = {};
        WORDS.KEYWORDS = ["break", "case", "catch", "const", "continue", "debugger", "default", "delete", "do", "else", "finally", "for", "function", "if", "in", "instanceof", "new", "return", "switch", "throw", "try", "typeof", "var", "void", "while", "with"];
        WORDS.KEYWORDS_ATOM = ["false", "null", "true"];
        WORDS.RESERVED_WORDS = WORDS.KEYWORDS.concat(WORDS.KEYWORDS_ATOM).concat(["abstract", "boolean", "byte", "char", "class", "double", "enum", "export", "extends", "final", "float", "goto", "implements", "import", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "super", "synchronized", "this", "throws", "transient", "volatile", "yield"]);
        WORDS.KEYWORDS_BEFORE_EXPRESSION = ["case", "delete", "else", "new", "return", "throw"];
        WORDS.OPERATORS = ["delete", "in", "instanceof", "new", "typeof", "void"].concat(["!", "!=", "!==", "%", "%=", "&", "&&", "&=", "*", "*=", "+", "++", "+=", "-", "--", "-=", "/", "/=", "<", "<<", "<<=", "<=", "=", "==", "===", ">", ">=", ">>", ">>=", ">>>", ">>>=", "?", "^", "^=", "|", "|=", "||", "~"]);
        WORDS.OPERATOR_CHARS = ["!", "%", "&", "*", "+", "-", "<", "=", ">", "?", "^", "|", "~"];
        WORDS.WHITESPACE_CHARS = ["\u0009", "\u000a", "\u000b", "\u000c", "\u000d", " ", "\u00a0", "\u180e", "\u2000", "\u2001", "\u2002", "\u2003", "\u2004", "\u2005", "\u2006", "\u2007", "\u2008", "\u2009", "\u200a", "\u200b", "\u202f", "\u205f", "\u3000"];
        WORDS.PUNC_BEFORE_EXPRESSION = ["(", ",", ".", ":", ";", "[", "{"];
        WORDS.PUNC_CHARS = ["(", ")", ",", ":", ";", "[", "]", "{", "}"];
        WORDS.UNARY_PREFIX = ["delete", "typeof", "void"].concat(["!", "+", "++", "-", "--", "~"]);
        WORDS.UNARY_POSTFIX = ["++", "--"];
        WORDS.ASSIGNMENT = ["%=", "&=", "*=", "+=", "-=", "/=", "<<=", "=", ">>=", ">>>=", "^=", "|="];
        WORDS.REGEXP_MODIFIERS = ["g", "i", "m", "s", "y"];

        (function () {
            var name;

            // this makePredicate function is based on code from Acorn [1], written by Marijn Haverbeke
            // [1] https://github.com/marijnh/acorn
            function makePredicate(words, name, byFirstCharCode) {
                /*jslint plusplus: true, evil: true, unparam: true*/
                /*jshint unused: true*/
                var f = "\n",
                    cats = [],
                    i,
                    j,
                    cat,
                    skipPush,
                    tab = "    ";
                if (!(words instanceof Array)) {
                    words = words.split(" ");
                }
                if (!byFirstCharCode) {
                    for (i = 0; i < words.length; ++i) {
                        skipPush = false;
                        for (j = 0; j < cats.length; ++j) {
                            if (cats[j][0].length === words[i].length) {
                                cats[j].push(words[i]);
                                skipPush = true;
                                break;
                            }
                        }
                        if (!skipPush) {
                            cats.push([words[i]]);
                        }
                    }
                }
                function compareTo(arr, tabbing, byFirstCharCode) {
                    tabbing = tabbing || "";
                    if (arr.length === 1) {
                        f += tabbing + "return str === " + JSON.stringify(arr[0]) + ";\n";
                        return f;
                    }
                    f += tabbing + "switch (str" + (byFirstCharCode ? ".charCodeAt(0)" : "") + ") {\n";
                    for (j = 0; j < arr.length; ++j) {
                        f += tabbing + "case " + (byFirstCharCode ? arr[j].charCodeAt(0) : JSON.stringify(arr[j])) + ":\n";
                    }
                    f += tabbing + "    return true;\n" + tabbing + "}\n" + tabbing + "return false;\n";
                }
                // When there are more than three length categories, an outer
                // switch first dispatches on the length,s to save on comparisons.
                if (cats.length > 3) {
                    cats.sort(function (a, b) {
                        return b.length - a.length;
                    });
                    f += tab + "switch (str.length) {\n";
                    for (i = 0; i < cats.length; ++i) {
                        cat = cats[i];
                        f += tab + "case " + cat[0].length + ":\n";
                        compareTo(cat, tab + tab);
                    }
                    f += tab + "}\n";
                    // Otherwise, simply generate a flat `switch` statement.
                } else {
                    compareTo(words, tab, byFirstCharCode);
                }

                return new Function("str", f);
            }

            for (name in WORDS) {
                if (WORDS.hasOwnProperty(name)) {
                    predicates[name] = makePredicate(WORDS[name], name, (name === "WHITESPACE_CHARS"));
                }
            }
        }());

        return predicates;
    }
);