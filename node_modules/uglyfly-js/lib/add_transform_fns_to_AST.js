/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

((typeof define === "function") ? define :
        function () { "use strict"; require('./nd').apply(module, arguments); })(
    "add_transform_fns_to_AST",
    [
        "MAP"
    ],
    function (MAP) {
        function add_transform_fns_to_AST(AST) {
            "use strict";

            /*jslint nomen: true */
            var UNDEF = (function () {
                    return;
                }());

            if (AST.has_transform_support) {
                return;
            }

            function _(node, descend) {
                node.DEFMETHOD("transform", function (tw, in_list) {
                    var x, y;
                    tw.push(this);
                    if (tw.before) {
                        x = tw.before(this, descend, in_list);
                    }
                    if (x === UNDEF) {
                        if (!tw.after) {
                            x = this;
                            descend(x, tw);
                        } else {
                            tw.stack[tw.stack.length - 1] = x = this.clone();
                            descend(x, tw);
                            y = tw.after(x, in_list);
                            if (y !== UNDEF) {
                                x = y;
                            }
                        }
                    }
                    tw.pop();
                    return x;
                });
            }

            function do_list(list, tw) {
                return MAP(list, function (node) {
                    return node.transform(tw, true);
                });
            }

            _(AST.Node, function () {
                return;
            });

            _(AST.LabeledStatement, function (self, tw) {
                self.label = self.label.transform(tw);
                self.body = self.body.transform(tw);
            });

            _(AST.SimpleStatement, function (self, tw) {
                self.body = self.body.transform(tw);
            });

            _(AST.Block, function (self, tw) {
                self.body = do_list(self.body, tw);
            });

            _(AST.DWLoop, function (self, tw) {
                self.condition = self.condition.transform(tw);
                self.body = self.body.transform(tw);
            });

            _(AST.For, function (self, tw) {
                if (self.init) {
                    self.init = self.init.transform(tw);
                }
                if (self.condition) {
                    self.condition = self.condition.transform(tw);
                }
                if (self.step) {
                    self.step = self.step.transform(tw);
                }
                self.body = self.body.transform(tw);
            });

            _(AST.ForIn, function (self, tw) {
                self.init = self.init.transform(tw);
                self.object = self.object.transform(tw);
                self.body = self.body.transform(tw);
            });

            _(AST.With, function (self, tw) {
                self.expression = self.expression.transform(tw);
                self.body = self.body.transform(tw);
            });

            _(AST.Exit, function (self, tw) {
                if (self.value) {
                    self.value = self.value.transform(tw);
                }
            });

            _(AST.LoopControl, function (self, tw) {
                if (self.label) {
                    self.label = self.label.transform(tw);
                }
            });

            _(AST.If, function (self, tw) {
                self.condition = self.condition.transform(tw);
                self.body = self.body.transform(tw);
                if (self.alternative) {
                    self.alternative = self.alternative.transform(tw);
                }
            });

            _(AST.Switch, function (self, tw) {
                self.expression = self.expression.transform(tw);
                self.body = do_list(self.body, tw);
            });

            _(AST.Case, function (self, tw) {
                self.expression = self.expression.transform(tw);
                self.body = do_list(self.body, tw);
            });

            _(AST.Try, function (self, tw) {
                self.body = do_list(self.body, tw);
                if (self.bcatch) {
                    self.bcatch = self.bcatch.transform(tw);
                }
                if (self.bfinally) {
                    self.bfinally = self.bfinally.transform(tw);
                }
            });

            _(AST.Catch, function (self, tw) {
                self.argname = self.argname.transform(tw);
                self.body = do_list(self.body, tw);
            });

            _(AST.Definitions, function (self, tw) {
                self.definitions = do_list(self.definitions, tw);
            });

            _(AST.VarDef, function (self, tw) {
                self.name = self.name.transform(tw);
                if (self.value) {
                    self.value = self.value.transform(tw);
                }
            });

            _(AST.Lambda, function (self, tw) {
                if (self.name) {
                    self.name = self.name.transform(tw);
                }
                self.argnames = do_list(self.argnames, tw);
                self.body = do_list(self.body, tw);
            });

            _(AST.Call, function (self, tw) {
                self.expression = self.expression.transform(tw);
                self.args = do_list(self.args, tw);
            });

            _(AST.Seq, function (self, tw) {
                self.car = self.car.transform(tw);
                self.cdr = self.cdr.transform(tw);
            });

            _(AST.Dot, function (self, tw) {
                self.expression = self.expression.transform(tw);
            });

            _(AST.Sub, function (self, tw) {
                self.expression = self.expression.transform(tw);
                self.property = self.property.transform(tw);
            });

            _(AST.Unary, function (self, tw) {
                self.expression = self.expression.transform(tw);
            });

            _(AST.Binary, function (self, tw) {
                self.left = self.left.transform(tw);
                self.right = self.right.transform(tw);
            });

            _(AST.Conditional, function (self, tw) {
                self.condition = self.condition.transform(tw);
                self.consequent = self.consequent.transform(tw);
                self.alternative = self.alternative.transform(tw);
            });

            _(AST.Array, function (self, tw) {
                self.elements = do_list(self.elements, tw);
            });

            _(AST.Object, function (self, tw) {
                self.properties = do_list(self.properties, tw);
            });

            _(AST.ObjectProperty, function (self, tw) {
                self.value = self.value.transform(tw);
            });

            AST.has_transform_support = true;
        }
        return add_transform_fns_to_AST;
    }
);
