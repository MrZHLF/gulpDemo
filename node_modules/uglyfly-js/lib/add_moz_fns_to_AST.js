/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

((typeof define === "function") ? define :
        function () { "use strict"; require('./nd').apply(module, arguments); })(
    "add_moz_fns_to_AST",
    [
        "is"
    ],
    function (is) {
        "use strict";

        function add_moz_fns_to_AST(AST) {
            var FROM_MOZ_STACK = null,
                MOZ_TO_ME;

            if (AST.has_moz_support) {
                return;
            }

            function my_start_token(moznode) {
                var loc = moznode.loc,
                    start = loc && loc.start,
                    range = moznode.range,
                    args = {
                        file: loc && loc.source,
                        line: start && start.line,
                        col: start && start.column,
                        pos: range ? range[0] : moznode.start,
                        endline: start && start.line,
                        endcol: start && start.column,
                        endpos: range ? range[0] : moznode.start
                    };
                return new AST.Token(args);
            }

            function my_end_token(moznode) {
                var loc = moznode.loc,
                    end = loc && loc.end,
                    range = moznode.range,
                    args = {
                        file: loc && loc.source,
                        line: end && end.line,
                        col: end && end.column,
                        pos: range ? range[1] : moznode.end,
                        endline: end && end.line,
                        endcol: end && end.column,
                        endpos: range ? range[1] : moznode.end
                    };
                return new AST.Token(args);
            }

            function from_moz(node) {
                var ret;
                FROM_MOZ_STACK.push(node);
                ret = node ? MOZ_TO_ME[node.type](node) : null;
                FROM_MOZ_STACK.pop();
                return ret;
            }

            function set_moz_loc(mynode, moznode) {
                var start = mynode.start,
                    end = mynode.end;
                if ((start.pos || (start.pos === 0)) && (end.endpos || (end.endpos === 0))) {
                    moznode.range = [start.pos, end.endpos];
                }
                if (start.line) {
                    moznode.loc = {
                        start: {
                            line: start.line,
                            column: start.col
                        },
                        end: (end.endline ? {
                            line: end.endline,
                            column: end.endcol
                        } : null)
                    };
                    if (start.file) {
                        moznode.loc.source = start.file;
                    }
                }
                return moznode;
            }

            function def_to_moz(mytype, handler) {
                mytype.DEFMETHOD("to_mozilla_ast", function () {
                    return set_moz_loc(this, handler(this));
                });
            }

            function to_moz(node) {
                return node ? node.to_mozilla_ast() : null;
            }

            function to_moz_block(node) {
                return {
                    type: "BlockStatement",
                    body: node.body.map(to_moz)
                };
            }

            AST.Node.from_mozilla_ast = function (node) {
                var save_stack = FROM_MOZ_STACK,
                    ast;
                FROM_MOZ_STACK = [];
                ast = from_moz(node);
                FROM_MOZ_STACK = save_stack;
                return ast;
            };

            function map(moztype, mytype, propmap) {
                /*jslint plusplus: true, evil: true*/
                var props,
                    prop,
                    i,
                    m,
                    moz,
                    how,
                    my,
                    moz_to_me,
                    me_to_moz,
                    re = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i;

                moz_to_me = "function From_Moz_" +
                    moztype +
                    "(M) {\nreturn new " +
                    mytype.name +
                    "({\nstart: my_start_token(M),\nend: my_end_token(M)";
                me_to_moz = "function To_Moz_" +
                    moztype +
                    "(M){\nreturn {\ntype: " +
                    JSON.stringify(moztype);

                if (propmap) {
                    props = propmap.split(",");
                    for (i = 0; i < props.length; ++i) {
                        prop = props[i];
                        m = re.exec(prop.trim());
                        if (!m) {
                            throw new Error("Can't understand property map: " + prop);
                        }
                        moz = m[1];
                        how = m[2];
                        my = m[3];
                        moz_to_me += ",\n" + my + ": ";
                        me_to_moz += ",\n" + moz + ": ";
                        switch (how) {
                        case "@":
                            moz_to_me += "M." + moz + ".map(from_moz)";
                            me_to_moz += "M." +  my + ".map(to_moz)";
                            break;
                        case ">":
                            moz_to_me += "from_moz(M." + moz + ")";
                            me_to_moz += "to_moz(M." + my + ")";
                            break;
                        case "=":
                            moz_to_me += "M." + moz;
                            me_to_moz += "M." + my;
                            break;
                        case "%":
                            moz_to_me += "from_moz(M." + moz + ").body";
                            me_to_moz += "to_moz_block(M)";
                            break;
                        default:
                            throw new Error("Can't understand operator in propmap: " + prop);
                        }
                    }
                }

                moz_to_me += "\n})\n}";
                me_to_moz += "\n}\n}";

                moz_to_me = new Function("my_start_token", "my_end_token", "from_moz", "return(" + moz_to_me + ")")(
                    my_start_token,
                    my_end_token,
                    from_moz
                );
                me_to_moz = new Function("to_moz", "to_moz_block", "return(" + me_to_moz + ")")(
                    to_moz,
                    to_moz_block
                );
                MOZ_TO_ME[moztype] = moz_to_me;
                def_to_moz(mytype, me_to_moz);
            }


            MOZ_TO_ME = {
                ExpressionStatement: function (M) {
                    var expr = M.expression;
                    if ((expr.type === "Literal") && (typeof expr.value === "string")) {
                        return new AST.Directive({
                            start: my_start_token(M),
                            end: my_end_token(M),
                            value: expr.value
                        });
                    }
                    return new AST.SimpleStatement({
                        start: my_start_token(M),
                        end: my_end_token(M),
                        body: from_moz(expr)
                    });
                },
                TryStatement: function (M) {
                    var handlers = M.handlers || [M.handler],
                        args;
                    if ((handlers.length > 1) || (M.guardedHandlers && M.guardedHandlers.length)) {
                        throw new Error("Multiple catch clauses are not supported.");
                    }
                    args = {
                        start: my_start_token(M),
                        end: my_end_token(M),
                        body: from_moz(M.block).body,
                        bcatch: from_moz(handlers[0]),
                        bfinally: M.finalizer ? new AST.Finally(from_moz(M.finalizer)) : null
                    };
                    return new AST.Try(args);
                },
                Property: function (M) {
                    var key = M.key,
                        name = (key.type === "Identifier") ? key.name : key.value,
                        args = {
                            start: my_start_token(key),
                            end: my_end_token(M.value),
                            key: name,
                            value: from_moz(M.value)
                        };
                    switch (M.kind) {
                    case "init":
                        return new AST.ObjectKeyVal(args);
                    case "set":
                        args.value.name = from_moz(key);
                        return new AST.ObjectSetter(args);
                    case "get":
                        args.value.name = from_moz(key);
                        return new AST.ObjectGetter(args);
                    }
                },
                ObjectExpression: function (M) {
                    var args = {
                            start: my_start_token(M),
                            end: my_end_token(M),
                            properties: M.properties.map(function (prop) {
                                prop.type = "Property";
                                return from_moz(prop);
                            })
                        };
                    return new AST.Object(args);
                },
                SequenceExpression: function (M) {
                    return AST.Seq.from_array(M.expressions.map(from_moz));
                },
                MemberExpression: function (M) {
                    var ConstructorType = (M.computed ? AST.Sub : AST.Dot),
                        args = {
                            start: my_start_token(M),
                            end: my_end_token(M),
                            property : (M.computed ? from_moz(M.property) : M.property.name),
                            expression : from_moz(M.object)
                        };
                    return new ConstructorType(args);
                },
                SwitchCase: function (M) {
                    var ConstructorType = (M.test ? AST.Case : AST.Default),
                        args = {
                            start: my_start_token(M),
                            end: my_end_token(M),
                            expression: from_moz(M.test),
                            body: M.consequent.map(from_moz)
                        };
                    return new ConstructorType(args);
                },
                VariableDeclaration: function (M) {
                    var ConstructorType = (M.kind === "const" ? AST.Const : AST.Var),
                        args = {
                            start: my_start_token(M),
                            end: my_end_token(M),
                            definitions: M.declarations.map(from_moz)
                        };
                    return new ConstructorType(args);
                },
                Literal: function (M) {
                    var val = M.value,
                        val_type = typeof val,
                        ConstructorType = null,
                        args = {
                            start: my_start_token(M),
                            end: my_end_token(M)
                        };
                    if (val === null) {
                        ConstructorType = AST.Null;
                    } else if (val_type === "boolean") {
                        ConstructorType = val ? AST.True : AST.False;
                    } else {
                        args.value = val;
                        switch (val_type) {
                        case "string":
                            ConstructorType = AST.String;
                            break;

                        case "number":
                            ConstructorType = AST.Number;
                            break;

                        default:
                            ConstructorType = AST.RegExp;
                            break;
                        }
                    }
                    return new ConstructorType(args);
                },
                Identifier: function (M) {
                    var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2],
                        ConstructorType = null,
                        args = {
                            start : my_start_token(M),
                            end : my_end_token(M),
                            name : M.name
                        };
                    switch (p.type) {
                    case "LabeledStatement":
                        ConstructorType = AST.Label;
                        break;

                    case "VariableDeclarator":
                        if (p.id === M) {
                            ConstructorType = (p.kind === "const") ? AST.SymbolConst : AST.SymbolVar;
                        }
                        break;

                    case "FunctionExpression":
                        ConstructorType = (p.id === M) ? AST.SymbolLambda : AST.SymbolFunarg;
                        break;

                    case "FunctionDeclaration":
                        ConstructorType = (p.id === M) ? AST.SymbolDefun : AST.SymbolFunarg;
                        break;

                    case "CatchClause":
                        ConstructorType = AST.SymbolCatch;
                        break;

                    case "BreakStatement":
                    case "ContinueStatement":
                        ConstructorType = AST.LabelRef;
                        break;
                    }
                    if (!ConstructorType) {
                        ConstructorType = AST.SymbolRef;
                    }
                    return new ConstructorType(args);
                }
            };

            MOZ_TO_ME.UpdateExpression =
                MOZ_TO_ME.UnaryExpression =
                function From_Moz_Unary(M) {
                    var prefix = M.hasOwnProperty("prefix") ? M.prefix : (M.type === "UnaryExpression"),
                        ConstructorType = prefix ? AST.UnaryPrefix : AST.UnaryPostfix,
                        args = {
                            start: my_start_token(M),
                            end: my_end_token(M),
                            operator: M.operator,
                            expression: from_moz(M.argument)
                        };

                    return new ConstructorType(args);
                };

            map("Program", AST.Toplevel, "body@body");
            map("EmptyStatement", AST.EmptyStatement);
            map("BlockStatement", AST.BlockStatement, "body@body");
            map("IfStatement", AST.If, "test>condition, consequent>body, alternate>alternative");
            map("LabeledStatement", AST.LabeledStatement, "label>label, body>body");
            map("BreakStatement", AST.Break, "label>label");
            map("ContinueStatement", AST.Continue, "label>label");
            map("WithStatement", AST.With, "object>expression, body>body");
            map("SwitchStatement", AST.Switch, "discriminant>expression, cases@body");
            map("ReturnStatement", AST.Return, "argument>value");
            map("ThrowStatement", AST.Throw, "argument>value");
            map("WhileStatement", AST.While, "test>condition, body>body");
            map("DoWhileStatement", AST.Do, "test>condition, body>body");
            map("ForStatement", AST.For, "init>init, test>condition, update>step, body>body");
            map("ForInStatement", AST.ForIn, "left>init, right>object, body>body");
            map("DebuggerStatement", AST.Debugger);
            map("FunctionDeclaration", AST.Defun, "id>name, params@argnames, body%body");
            map("VariableDeclarator", AST.VarDef, "id>name, init>value");
            map("CatchClause", AST.Catch, "param>argname, body%body");

            map("ThisExpression", AST.This);
            map("ArrayExpression", AST.Array, "elements@elements");
            map("FunctionExpression", AST.Function, "id>name, params@argnames, body%body");
            map("BinaryExpression", AST.Binary, "operator=operator, left>left, right>right");
            map("LogicalExpression", AST.Binary, "operator=operator, left>left, right>right");
            map("AssignmentExpression", AST.Assign, "operator=operator, left>left, right>right");
            map("ConditionalExpression", AST.Conditional, "test>condition, consequent>consequent, alternate>alternative");
            map("NewExpression", AST.New, "callee>expression, arguments@args");
            map("CallExpression", AST.Call, "callee>expression, arguments@args");

            def_to_moz(AST.Directive, function To_Moz_Directive(M) {
                return {
                    type: "ExpressionStatement",
                    expression: {
                        type: "Literal",
                        value: M.value
                    }
                };
            });

            def_to_moz(AST.SimpleStatement, function To_Moz_ExpressionStatement(M) {
                return {
                    type: "ExpressionStatement",
                    expression: to_moz(M.body)
                };
            });

            def_to_moz(AST.SwitchBranch, function To_Moz_SwitchCase(M) {
                return {
                    type: "SwitchCase",
                    test: to_moz(M.expression),
                    consequent: M.body.map(to_moz)
                };
            });

            def_to_moz(AST.Try, function To_Moz_TryStatement(M) {
                return {
                    type: "TryStatement",
                    block: to_moz_block(M),
                    handler: to_moz(M.bcatch),
                    guardedHandlers: [],
                    finalizer: to_moz(M.bfinally)
                };
            });

            def_to_moz(AST.Catch, function To_Moz_CatchClause(M) {
                return {
                    type: "CatchClause",
                    param: to_moz(M.argname),
                    guard: null,
                    body: to_moz_block(M)
                };
            });

            def_to_moz(AST.Definitions, function To_Moz_VariableDeclaration(M) {
                return {
                    type: "VariableDeclaration",
                    kind: M instanceof AST.Const ? "const" : "var",
                    declarations: M.definitions.map(to_moz)
                };
            });

            def_to_moz(AST.Seq, function To_Moz_SequenceExpression(M) {
                return {
                    type: "SequenceExpression",
                    expressions: M.to_array().map(to_moz)
                };
            });

            def_to_moz(AST.PropAccess, function To_Moz_MemberExpression(M) {
                var isComputed = M instanceof AST.Sub;
                return {
                    type: "MemberExpression",
                    object: to_moz(M.expression),
                    computed: isComputed,
                    property: isComputed ? to_moz(M.property) : {
                        type: "Identifier",
                        name: M.property
                    }
                };
            });

            def_to_moz(AST.Unary, function To_Moz_Unary(M) {
                return {
                    type: ((M.operator === "++") || (M.operator === "--")) ? "UpdateExpression" : "UnaryExpression",
                    operator: M.operator,
                    prefix: (M instanceof AST.UnaryPrefix),
                    argument: to_moz(M.expression)
                };
            });

            def_to_moz(AST.Binary, function To_Moz_BinaryExpression(M) {
                return {
                    type: ((M.operator === "&&") || (M.operator === "||")) ? "LogicalExpression" : "BinaryExpression",
                    left: to_moz(M.left),
                    operator: M.operator,
                    right: to_moz(M.right)
                };
            });

            def_to_moz(AST.Object, function To_Moz_ObjectExpression(M) {
                return {
                    type: "ObjectExpression",
                    properties: M.properties.map(to_moz)
                };
            });

            def_to_moz(AST.ObjectProperty, function To_Moz_Property(M) {
                var key,
                    kind;
                if (is.identifier(M.key)) {
                    key = {
                        type: "Identifier",
                        name: M.key
                    };
                } else {
                    key = {
                        type: "Literal",
                        value: M.key
                    };
                }
                if (M instanceof AST.ObjectKeyVal) {
                    kind = "init";
                } else if (M instanceof AST.ObjectGetter) {
                    kind = "get";
                } else if (M instanceof AST.ObjectSetter) {
                    kind = "set";
                }
                return {
                    type: "Property",
                    kind: kind,
                    key: key,
                    value: to_moz(M.value)
                };
            });

            def_to_moz(AST.Symbol, function To_Moz_Identifier(M) {
                var def = M.definition();
                return {
                    type: "Identifier",
                    name: def ? def.mangled_name || def.name : M.name
                };
            });

            def_to_moz(AST.Constant, function To_Moz_Literal(M) {
                var value = M.value;
                if ((typeof value === 'number') && ((value < 0) || ((value === 0) && ((1 / value) < 0)))) {
                    return {
                        type: "UnaryExpression",
                        operator: "-",
                        prefix: true,
                        argument: {
                            type: "Literal",
                            value: -value
                        }
                    };
                }
                return {
                    type: "Literal",
                    value: value
                };
            });

            def_to_moz(AST.Atom, function To_Moz_Atom(M) {
                return {
                    type: "Identifier",
                    name: String(M.value)
                };
            });

            AST.Boolean.DEFMETHOD("to_mozilla_ast", AST.Constant.prototype.to_mozilla_ast);

            AST.Null.DEFMETHOD("to_mozilla_ast", AST.Constant.prototype.to_mozilla_ast);

            AST.Hole.DEFMETHOD("to_mozilla_ast", function To_Moz_ArrayHole() {
                return null;
            });

            AST.Block.DEFMETHOD("to_mozilla_ast", AST.BlockStatement.prototype.to_mozilla_ast);

            AST.Lambda.DEFMETHOD("to_mozilla_ast", AST.Function.prototype.to_mozilla_ast);

            AST.has_moz_support = true;
        }
        return add_moz_fns_to_AST;
    }
);
