/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

((typeof define === "function") ? define :
        function () { "use strict"; require('./nd').apply(module, arguments); })(
    "add_scope_fns_to_AST",
    [
        "TreeWalker",
        "SymbolDef",
        "defaults",
        "Dictionary",
        "is",
        "merge_sort"
    ],
    function (TreeWalker, SymbolDef, defaults, Dictionary, is, merge_sort) {
        "use strict";
        function add_scope_fns_to_AST(AST, warn) {
            var FrequencyCounter, get_var_namer;

            if (AST.has_scope_support) {
                return;
            }

            (function (merge_sort) {
                /*jslint plusplus: true*/

                //varname_chars: charCodes for a-z,A-Z,$,_,0-9
                var varname_chars = [97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 36, 95, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57];


                FrequencyCounter = function FrequencyCounter(init_frequencies) {
                    this.init(init_frequencies);
                };
                FrequencyCounter.prototype = {
                    init: function (init_frequencies) {
                        var self = this, fn;
                        self.frequency = Object.create(null);
                        if (!init_frequencies) {
                            fn = function (ch) {
                                self.frequency[ch] = 0;
                            };
                        } else {
                            fn = function (ch) {
                                self.frequency[ch] = (typeof init_frequencies[ch] === "number") ? init_frequencies[ch] : 0;
                            };
                        }
                        varname_chars.forEach(fn);
                    },
                    consider: function (str) {
                        var i,
                            cc,
                            self = this;
                        for (i = str.length - 1; i >= 0; --i) {
                            cc = str.charCodeAt(i);
                            if (Object.prototype.hasOwnProperty.call(self.frequency, cc)) {
                                ++self.frequency[cc];
                            }
                        }
                    },
                    frequencies: function () {
                        return this.frequency;
                    }
                };

                get_var_namer = function get_name_var(freqs) {
                    var chars;
                    function is_digit(code) {
                        return (code >= 48) && (code <= 57);
                    }
                    chars = merge_sort(varname_chars.slice(), function (a, b) {
                        if (is_digit(a) && !is_digit(b)) {
                            return 1;
                        }
                        if (is_digit(b) && !is_digit(a)) {
                            return -1;
                        }
                        if (!freqs) {
                            return 0;
                        }
                        return (freqs[b] || 0) - (freqs[a] || 0);
                    });
                    return function name_var(num) {
                        var name = "",
                            base = 54;
                        num++;
                        do {
                            num--;
                            name += String.fromCharCode(chars[num % base]);
                            num = Math.floor(num / base);
                            base = 64;
                        } while (num > 0);
                        return name;
                    };
                };
            }(merge_sort));

            /*jslint plusplus: true*/
            AST.Toplevel.DEFMETHOD("figure_out_scope", function (options) {
                var self,
                    scope,
                    defun,
                    nesting,
                    tw,
                    func,
                    globals;
                options = defaults(options, {
                    screw_ie8: false
                });

                // pass 1: setup scope chaining and handle definitions
                self = this;
                scope = self.parent_scope = null;
                defun = null;
                nesting = 0;
                tw = new TreeWalker(function (node, descend) {
                    var save_scope,
                        save_defun,
                        s,
                        def,
                        dir,
                        val;
                    if (options.screw_ie8 && node instanceof AST.Catch) {
                        save_scope = scope;
                        scope = new AST.Scope(node);
                        scope.init_scope_vars(nesting);
                        scope.parent_scope = save_scope;
                        descend();
                        scope = save_scope;
                        return true;
                    }
                    if (node instanceof AST.Scope) {
                        node.init_scope_vars(nesting);
                        save_scope = node.parent_scope = scope;
                        save_defun = defun;
                        defun = scope = node;
                        ++nesting;
                        descend();
                        --nesting;
                        scope = save_scope;
                        defun = save_defun;
                        return true;        // don't descend again in TreeWalker
                    }
                    if (node instanceof AST.Directive) {
                        node.scope = scope;
                        dir = scope.directives;
                        val = node.value;
                        if (dir.indexOf(val) === -1) {
                            dir.push(val);
                        }
                        return true;
                    }
                    if (node instanceof AST.With) {
                        for (s = scope; s; s = s.parent_scope) {
                            s.uses_with = true;
                        }
                        return;
                    }
                    if (node instanceof AST.Symbol) {
                        node.scope = scope;
                    }
                    if (node instanceof AST.SymbolLambda) {
                        defun.def_function(node);
                    } else if (node instanceof AST.SymbolDefun) {
                        // Careful here, the scope where this should be defined is
                        // the parent scope.  The reason is that we enter a new
                        // scope when we encounter the AST.Defun node (which is
                        // instanceof AST.Scope) but we get to the symbol a bit
                        // later.
                        node.scope = defun.parent_scope;
                        node.scope.def_function(node);
                    } else if ((node instanceof AST.SymbolVar) || (node instanceof AST.SymbolConst)) {
                        def = defun.def_variable(node);
                        def.constant = node instanceof AST.SymbolConst;
                        def.init = tw.parent().value;
                    } else if (node instanceof AST.SymbolCatch) {
                        (options.screw_ie8 ? scope : defun)
                            .def_variable(node);
                    }
                });
                self.walk(tw);

                // pass 2: find back references and eval
                func = null;
                globals = self.globals = new Dictionary();
                tw = new TreeWalker(function (node, descend) {
                    var prev_func,
                        name,
                        sym,
                        g,
                        s;
                    if (node instanceof AST.Lambda) {
                        prev_func = func;
                        func = node;
                        descend();
                        func = prev_func;
                        return true;
                    }
                    if (node instanceof AST.SymbolRef) {
                        name = node.name;
                        sym = node.scope.find_variable(name);
                        if (!sym) {
                            if (globals.has(name)) {
                                g = globals.get(name);
                            } else {
                                g = new SymbolDef(self, globals.size(), node);
                                g.undeclared = true;
                                g.global = true;
                                globals.set(name, g);
                            }
                            node.thedef = g;
                            if (name === "eval" && tw.parent() instanceof AST.Call) {
                                for (s = node.scope; s && !s.uses_eval; s = s.parent_scope) {
                                    s.uses_eval = true;
                                }
                            }
                            if (func && (name === "arguments")) {
                                func.uses_arguments = true;
                            }
                        } else {
                            node.thedef = sym;
                        }
                        node.reference();
                        return true;
                    }
                });
                self.walk(tw);
            });

            AST.Scope.DEFMETHOD("init_scope_vars", function (nesting) {
                this.directives = [];     // contains the directives defined in this scope, i.e. "use strict"
                this.variables = new Dictionary(); // map name to AST.SymbolVar (variables defined in this scope; includes functions)
                this.functions = new Dictionary(); // map name to AST.SymbolDefun (functions defined in this scope)
                this.uses_with = false;   // will be set to true if this or some nested scope uses the `with` statement
                this.uses_eval = false;   // will be set to true if this or nested scope uses the global `eval`
                this.parent_scope = null; // the parent scope
                this.enclosed = [];       // a list of variables from this or outer scope(s) that are referenced from this or inner scopes
                this.cname = -1;          // the current index for mangling functions/variables
                this.nesting = nesting;   // the nesting level of this scope (0 means toplevel)
            });

            AST.Scope.DEFMETHOD("strict", function () {
                return this.has_directive("use strict");
            });

            AST.Lambda.DEFMETHOD("init_scope_vars", function () {
                AST.Scope.prototype.init_scope_vars.apply(this, arguments);
                this.uses_arguments = false;
            });

            AST.SymbolRef.DEFMETHOD("reference", function () {
                var def = this.definition(),
                    s = this.scope,
                    enc;
                def.references.push(this);
                while (s) {
                    enc = s.enclosed;
                    if (enc.indexOf(def) === -1) {
                        enc.push(def);
                    }
                    if (s === def.scope) {
                        break;
                    }
                    s = s.parent_scope;
                }
                this.frame = this.scope.nesting - def.scope.nesting;
            });

            AST.Scope.DEFMETHOD("find_variable", function (name) {
                if (name instanceof AST.Symbol) {
                    name = name.name;
                }
                return this.variables.get(name) ||
                    (this.parent_scope && this.parent_scope.find_variable(name));
            });

            AST.Scope.DEFMETHOD("has_directive", function (value) {
                return (this.parent_scope && this.parent_scope.has_directive(value)) ||
                    (this.directives.indexOf(value) >= 0 ? this : null);
            });

            AST.Scope.DEFMETHOD("def_function", function (symbol) {
                this.functions.set(symbol.name, this.def_variable(symbol));
            });

            AST.Scope.DEFMETHOD("def_variable", function (symbol) {
                var def;
                if (!this.variables.has(symbol.name)) {
                    def = new SymbolDef(this, this.variables.size(), symbol);
                    this.variables.set(symbol.name, def);
                    def.global = !this.parent_scope;
                } else {
                    def = this.variables.get(symbol.name);
                    def.orig.push(symbol);
                }
                symbol.thedef = def;
                return symbol.thedef;
            });

            AST.Scope.DEFMETHOD("next_mangled", function (options) {
                var ext = this.enclosed,
                    m,
                    i,
                    sym,
                    name,
                    notDoneYet,
                    name_var = options.name_var || get_var_namer(options.char_frequencies);
                do {
                    notDoneYet = true;
                    m = name_var(++this.cname);
                    if (is.identifier(m) && (options.except.indexOf(m) === -1)) {
                        // https://github.com/mishoo/UglifyJS2/issues/242 -- do not
                        // shadow a name excepted from mangling.

                        notDoneYet = false;
                        // we must ensure that the mangled name does not shadow a name
                        // from some parent scope that is referenced in this or in
                        // inner scopes.
                        for (i = ext.length - 1; i >= 0; --i) {
                            sym = ext[i];
                            name = (sym.mangled_name || (sym.unmangleable(options) && sym.name));
                            if (m === name) {
                                notDoneYet = true;
                                break;
                            }
                        }
                    }
                } while (notDoneYet);
                return m;
            });

            AST.Function.DEFMETHOD("next_mangled", function (options, def) {
                // #179, #326
                // in Safari strict mode, something like (function x(x){...}) is a syntax error;
                // a function expression's argument cannot shadow the function expression's name

                var tricky_def = (def.orig[0] instanceof AST.SymbolFunarg) && this.name && this.name.definition(),
                    name;
                while (true) {
                    name = AST.Lambda.prototype.next_mangled.call(this, options, def);
                    if (!(tricky_def && (tricky_def.mangled_name === name))) {
                        return name;
                    }
                }
            });

            AST.Scope.DEFMETHOD("references", function (sym) {
                if (sym instanceof AST.Symbol) {
                    sym = sym.definition();
                }
                return this.enclosed.indexOf(sym) < 0 ? null : sym;
            });

            AST.Symbol.DEFMETHOD("unmangleable", function (options) {
                return this.definition().unmangleable(options);
            });

            // property accessors are not mangleable
            AST.SymbolAccessor.DEFMETHOD("unmangleable", function () {
                return true;
            });

            // labels are always mangleable
            AST.Label.DEFMETHOD("unmangleable", function () {
                return false;
            });

            AST.Symbol.DEFMETHOD("unreferenced", function () {
                return (this.definition().references.length === 0) &&
                    !(this.scope.uses_eval || this.scope.uses_with);
            });

            AST.Symbol.DEFMETHOD("undeclared", function () {
                return this.definition().undeclared;
            });

            AST.LabelRef.DEFMETHOD("undeclared", function () {
                return false;
            });

            AST.Label.DEFMETHOD("undeclared", function () {
                return false;
            });

            AST.Symbol.DEFMETHOD("definition", function () {
                return this.thedef;
            });

            AST.Symbol.DEFMETHOD("global", function () {
                return this.definition().global;
            });

            AST.Toplevel.DEFMETHOD("_default_mangler_options", function (options) {
                return defaults(options, {
                    except: [],
                    eval: false,
                    sort: false,
                    toplevel: false,
                    screw_ie8: false,
                    init_frequencies: null,
                    char_frequencies: null,
                    name_var: null
                });
            });

            AST.Toplevel.DEFMETHOD("mangle_names", function (options) {
                /*jslint nomen: true*/
                var lname,
                    to_mangle,
                    tw,
                    name_var;
                options = this._default_mangler_options(options);
                if (typeof options.name_var !== "function") {
                    options.name_var = get_var_namer(options.char_frequencies);
                }
                name_var = options.name_var;

                // We only need to mangle declaration nodes.  Special logic wired
                // into the code generator will display the mangled name if it's
                // present (and for AST.SymbolRef-s it'll use the mangled name of
                // the AST.SymbolDeclaration that it points to).
                lname = -1;
                to_mangle = [];
                tw = new TreeWalker(function (node, descend) {
                    var save_nesting,
                        a,
                        name;
                    if (node instanceof AST.LabeledStatement) {
                        // lname is incremented when we get to the AST.Label
                        save_nesting = lname;
                        descend();
                        lname = save_nesting;
                        return true;        // don't descend again in TreeWalker
                    }
                    if (node instanceof AST.Scope) {
                        a = [];
                        node.variables.each(function (symbol) {
                            if (options.except.indexOf(symbol.name) < 0) {
                                a.push(symbol);
                            }
                        });
                        if (options.sort) {
                            a.sort(function (a, b) {
                                return b.references.length - a.references.length;
                            });
                        }
                        to_mangle.push.apply(to_mangle, a);
                        return;
                    }
                    if (node instanceof AST.Label) {
                        do {
                            name = name_var(++lname);
                        } while (!is.identifier(name));
                        node.mangled_name = name;
                        return true;
                    }
                    if (options.screw_ie8 && node instanceof AST.SymbolCatch) {
                        to_mangle.push(node.definition());
                        return;
                    }
                });
                this.walk(tw);
                to_mangle.forEach(function (def) {
                    def.mangle(options);
                });
            });

            AST.Toplevel.DEFMETHOD("compute_char_frequency", function (options) {
                /*jslint nomen: true*/
                options = this._default_mangler_options(options);
                var freq_counter = new FrequencyCounter(options.init_frequencies),
                    tw;
                tw = new TreeWalker(function (node) {
                    if (node instanceof AST.Constant) {
                        freq_counter.consider(node.print_to_string());
                    } else if (node instanceof AST.Return) {
                        freq_counter.consider("return");
                    } else if (node instanceof AST.Throw) {
                        freq_counter.consider("throw");
                    } else if (node instanceof AST.Continue) {
                        freq_counter.consider("continue");
                    } else if (node instanceof AST.Break) {
                        freq_counter.consider("break");
                    } else if (node instanceof AST.Debugger) {
                        freq_counter.consider("debugger");
                    } else if (node instanceof AST.Directive) {
                        freq_counter.consider(node.value);
                    } else if (node instanceof AST.While) {
                        freq_counter.consider("while");
                    } else if (node instanceof AST.Do) {
                        freq_counter.consider("do while");
                    } else if (node instanceof AST.If) {
                        freq_counter.consider("if");
                        if (node.alternative) {
                            freq_counter.consider("else");
                        }
                    } else if (node instanceof AST.Var) {
                        freq_counter.consider("var");
                    } else if (node instanceof AST.Const) {
                        freq_counter.consider("const");
                    } else if (node instanceof AST.Lambda) {
                        freq_counter.consider("function");
                    } else if (node instanceof AST.For) {
                        freq_counter.consider("for");
                    } else if (node instanceof AST.ForIn) {
                        freq_counter.consider("for in");
                    } else if (node instanceof AST.Switch) {
                        freq_counter.consider("switch");
                    } else if (node instanceof AST.Case) {
                        freq_counter.consider("case");
                    } else if (node instanceof AST.Default) {
                        freq_counter.consider("default");
                    } else if (node instanceof AST.With) {
                        freq_counter.consider("with");
                    } else if (node instanceof AST.ObjectSetter) {
                        freq_counter.consider("set" + node.key);
                    } else if (node instanceof AST.ObjectGetter) {
                        freq_counter.consider("get" + node.key);
                    } else if (node instanceof AST.ObjectKeyVal) {
                        freq_counter.consider(node.key);
                    } else if (node instanceof AST.New) {
                        freq_counter.consider("new");
                    } else if (node instanceof AST.This) {
                        freq_counter.consider("this");
                    } else if (node instanceof AST.Try) {
                        freq_counter.consider("try");
                    } else if (node instanceof AST.Catch) {
                        freq_counter.consider("catch");
                    } else if (node instanceof AST.Finally) {
                        freq_counter.consider("finally");
                    } else if ((node instanceof AST.Symbol) && node.unmangleable(options)) {
                        freq_counter.consider(node.name);
                    } else if ((node instanceof AST.Unary) || (node instanceof AST.Binary)) {
                        freq_counter.consider(node.operator);
                    } else if (node instanceof AST.Dot) {
                        freq_counter.consider(node.property);
                    }
                });
                this.walk(tw);
                options.char_frequencies = freq_counter.frequencies();
                return options.char_frequencies;
            });

            AST.Toplevel.DEFMETHOD("scope_warnings", function (options) {
                options = defaults(options, {
                    undeclared: false, // this makes a lot of noise
                    unreferenced: true,
                    assign_to_global: true,
                    func_arguments: true,
                    nested_defuns: true,
                    eval: true
                });
                var tw = new TreeWalker(function (node) {
                    /*jslint evil: true*/
                    if (options.undeclared &&
                            (node instanceof AST.SymbolRef) &&
                            node.undeclared()) {
                        // XXX: this also warns about JS standard names,
                        // i.e. Object, Array, parseInt etc.  Should add a list of
                        // exceptions.
                        warn("Undeclared symbol: {name} [{file}:{line},{col}]", {
                            name: node.name,
                            file: node.start.file,
                            line: node.start.line,
                            col: node.start.col
                        });
                    }
                    if (options.assign_to_global) {
                        var sym = null;
                        if ((node instanceof AST.Assign) && (node.left instanceof AST.SymbolRef)) {
                            sym = node.left;
                        } else if ((node instanceof AST.ForIn) && (node.init instanceof AST.SymbolRef)) {
                            sym = node.init;
                        }
                        if (sym && (sym.undeclared() || (sym.global() && (sym.scope !== sym.definition().scope)))) {
                            warn("{msg}: {name} [{file}:{line},{col}]", {
                                msg: sym.undeclared() ? "Accidental global?" : "Assignment to global",
                                name: sym.name,
                                file: sym.start.file,
                                line: sym.start.line,
                                col: sym.start.col
                            });
                        }
                    }
                    if (options.eval &&
                            (node instanceof AST.SymbolRef) &&
                            node.undeclared() &&
                            (node.name === "eval")) {
                        warn("Eval is used [{file}:{line},{col}]", node.start);
                    }
                    if (options.unreferenced &&
                            ((node instanceof AST.SymbolDeclaration) || (node instanceof AST.Label)) &&
                            !(node instanceof AST.SymbolCatch) &&
                            node.unreferenced()) {
                        warn("{type} {name} is declared but not referenced [{file}:{line},{col}]", {
                            type: node instanceof AST.Label ? "Label" : "Symbol",
                            name: node.name,
                            file: node.start.file,
                            line: node.start.line,
                            col: node.start.col
                        });
                    }
                    if (options.func_arguments && (node instanceof AST.Lambda) && node.uses_arguments) {
                        warn("arguments used in function {name} [{file}:{line},{col}]", {
                            name: node.name ? node.name.name : "anonymous",
                            file: node.start.file,
                            line: node.start.line,
                            col: node.start.col
                        });
                    }
                    if (options.nested_defuns && (node instanceof AST.Defun) && !(tw.parent() instanceof AST.Scope)) {
                        warn("Function {name} declared in nested statement \"{type}\" [{file}:{line},{col}]", {
                            name: node.name.name,
                            type: tw.parent().TYPE,
                            file: node.start.file,
                            line: node.start.line,
                            col: node.start.col
                        });
                    }
                });
                this.walk(tw);
            });

            AST.has_scope_support = true;
        }
        return add_scope_fns_to_AST;
    }
);