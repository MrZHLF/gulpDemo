/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

((typeof define === "function") ? define :
        function () { "use strict"; require('./nd').apply(module, arguments); })(
    "add_compress_fns_to_AST",
    [
        "TreeWalker",
        "find_if",
        "get_warn",
        "JS_Parse_Error",
        "precedence",
        "predicates",
        "is",
        "parse",
        "MAP",
        "TreeTransformer",
        "Dictionary",
        "merge_sort",
        "OutputStream",
        "Compressor"
    ],
    function (TreeWalker, find_if, get_warn, JS_Parse_Error, precedence,
        predicates, is, parse, MAP, TreeTransformer, Dictionary,
        merge_sort, OutputStream, Compressor) {
        "use strict";
        function add_compress_fns_to_AST(AST, warn_callback, croak_callback) {
            /*jslint nomen: true, plusplus: true, unparam: true */

            if (AST.has_compress_support) {
                return;
            }

            function OPT(node, optimizer) {
                node.DEFMETHOD("optimize", function (compressor) {
                    var self = this,
                        opt;
                    if (self._optimized) {
                        return self;
                    }
                    opt = optimizer(self, compressor);
                    opt._optimized = true;
                    if (opt === self) {
                        return opt;
                    }
                    return opt.transform(compressor);
                });
            }

            OPT(AST.Node, function (self) {
                return self;
            });

            AST.Node.DEFMETHOD("equivalent_to", function (node) {
                // XXX: this is a rather expensive way to test two node's equivalence:
                return this.print_to_string() === node.print_to_string();
            });

            function make_node(NodeType, orig, props) {
                if (!props) {
                    props = {};
                }
                if (orig) {
                    if (!props.start) {
                        props.start = orig.start;
                    }
                    if (!props.end) {
                        props.end = orig.end;
                    }
                }
                return new NodeType(props);
            }

            function make_node_from_constant(compressor, val, orig) {
                // XXX: WIP.
                // if (val instanceof AST.Node) {
                //     return val.transform(new TreeTransformer(null, function (node) {
                //         if (node instanceof AST.SymbolRef) {
                //             var scope = compressor.find_parent(AST.Scope);
                //             var def = scope.find_variable(node);
                //             node.thedef = def;
                //             return node;
                //         }
                //     })).transform(compressor);
                // }

                if (val instanceof AST.Node) {
                    return val.transform(compressor);
                }
                switch (typeof val) {
                case "string":
                    return make_node(AST.String, orig, {
                        value: val
                    }).optimize(compressor);
                case "number":
                    return make_node(isNaN(val) ? AST.NaN : AST.Number, orig, {
                        value: val
                    }).optimize(compressor);
                case "boolean":
                    return make_node(val ? AST.True : AST.False, orig).optimize(compressor);
                case "undefined":
                    return make_node(AST.Undefined, orig).optimize(compressor);
                default:
                    if (val === null) {
                        return make_node(AST.Null, orig, {
                            value: null
                        }).optimize(compressor);
                    }
                    if (val instanceof RegExp) {
                        return make_node(AST.RegExp, orig, {
                            value: val
                        }).optimize(compressor);
                    }
                    throw new Error("Can't handle constant of type: " + typeof val);
                }
            }

            function as_statement_array(thing) {
                if (thing === null) {
                    return [];
                }
                if (thing instanceof AST.BlockStatement) {
                    return thing.body;
                }
                if (thing instanceof AST.EmptyStatement) {
                    return [];
                }
                if (thing instanceof AST.Statement) {
                    return [ thing ];
                }
                throw new Error("Can't convert thing to statement array");
            }

            function is_empty(thing) {
                if (thing === null) {
                    return true;
                }
                if (thing instanceof AST.EmptyStatement) {
                    return true;
                }
                if (thing instanceof AST.BlockStatement) {
                    return thing.body.length === 0;
                }
                return false;
            }

            function loop_body(x) {
                if (x instanceof AST.Switch) {
                    return x;
                }
                if ((x instanceof AST.For) || (x instanceof AST.ForIn) || (x instanceof AST.DWLoop)) {
                    return ((x.body instanceof AST.BlockStatement) ? x.body : x);
                }
                return x;
            }

            // tell me if a statement aborts
            function aborts(thing) {
                return thing && thing.aborts();
            }

            function extract_declarations_from_unreachable_code(compressor, stat, target) {
                compressor.warn("Dropping unreachable code [{file}:{line},{col}]", stat.start);
                stat.walk(new TreeWalker(function (node) {
                    if (node instanceof AST.Definitions) {
                        compressor.warn("Declarations in unreachable code! [{file}:{line},{col}]", node.start);
                        node.remove_initializers();
                        target.push(node);
                        return true;
                    }
                    if (node instanceof AST.Defun) {
                        target.push(node);
                        return true;
                    }
                    if (node instanceof AST.Scope) {
                        return true;
                    }
                }));
            }

            function remove(array, el) {
                var i;
                for (i = array.length - 1; i >= 0; --i) {
                    if (array[i] === el) {
                        array.splice(i, 1);
                    }
                }
            }

            function tighten_body(statements, compressor) {
                var CHANGED;

                function process_for_angular(statements) {

                    function has_inject(comment) {
                        return (/@ngInject/).test(comment.value);
                    }

                    function make_arguments_names_list(func) {
                        return func.argnames.map(function (sym) {
                            return make_node(AST.String, sym, {
                                value: sym.name
                            });
                        });
                    }

                    function make_array(orig, elements) {
                        return make_node(AST.Array, orig, {
                            elements: elements
                        });
                    }

                    function make_injector(func, name) {
                        return make_node(AST.SimpleStatement, func, {
                            body: make_node(AST.Assign, func, {
                                operator: "=",
                                left: make_node(AST.Dot, name, {
                                    expression: make_node(AST.SymbolRef, name, name),
                                    property: "$inject"
                                }),
                                right: make_array(func, make_arguments_names_list(func))
                            })
                        });
                    }

                    function check_expression(body) {
                        if (body && body.args) {
                            // if this is a function call check all of arguments passed
                            body.args.forEach(function (argument, index, array) {
                                var comments = argument.start.comments_before;
                                // if the argument is function preceded by @ngInject
                                if ((argument instanceof AST.Lambda) && comments.length && has_inject(comments[0])) {
                                    // replace the function with an array of names of its parameters and function at the end
                                    array[index] = make_array(argument, make_arguments_names_list(argument).concat(argument));
                                }
                            });
                            // if this is chained call check previous one recursively
                            if (body.expression && body.expression.expression) {
                                check_expression(body.expression.expression);
                            }
                        }
                    }

                    return statements.reduce(function (a, stat) {
                        var token,
                            comments,
                            last;
                        a.push(stat);

                        if (stat.body && stat.body.args) {
                            check_expression(stat.body);
                        } else {
                            token = stat.start;
                            comments = token.comments_before;
                            if (comments && comments.length > 0) {
                                last = comments.pop();
                                if (has_inject(last)) {
                                    // case 1: defun
                                    if (stat instanceof AST.Defun) {
                                        a.push(make_injector(stat, stat.name));
                                    } else if (stat instanceof AST.Definitions) {
                                        stat.definitions.forEach(function (def) {
                                            if (def.value && def.value instanceof AST.Lambda) {
                                                a.push(make_injector(def.value, def.name));
                                            }
                                        });
                                    } else {
                                        compressor.warn("Unknown statement marked with @ngInject [{file}:{line},{col}]", token);
                                    }
                                }
                            }
                        }

                        return a;
                    }, []);
                }

                function eliminate_spurious_blocks(statements) {
                    var seen_dirs = [];
                    return statements.reduce(function (a, stat) {
                        if (stat instanceof AST.BlockStatement) {
                            CHANGED = true;
                            a.push.apply(a, eliminate_spurious_blocks(stat.body));
                        } else if (stat instanceof AST.EmptyStatement) {
                            CHANGED = true;
                        } else if (stat instanceof AST.Directive) {
                            if (seen_dirs.indexOf(stat.value) < 0) {
                                a.push(stat);
                                seen_dirs.push(stat.value);
                            } else {
                                CHANGED = true;
                            }
                        } else {
                            a.push(stat);
                        }
                        return a;
                    }, []);
                }

                function handle_if_return(statements, compressor) {
                    /*jslint continue:true*/
                    var self = compressor.self(),
                        in_lambda = (self instanceof AST.Lambda),
                        ret = [],
                        i,
                        stat,
                        cond,
                        ab,
                        lct,
                        body;
                    for (i = statements.length - 1; i >= 0; --i) {
                        stat = statements[i];
                        if (in_lambda && (stat instanceof AST.Return) && !stat.value && (ret.length === 0)) {
                            CHANGED = true;
                            // note, ret.length is probably always zero
                            // because we drop unreachable code before this
                            // step.  nevertheless, it's good to check.
                            continue;
                        }
                        if (stat instanceof AST.If) {
                            if (stat.body instanceof AST.Return) {
                                if (((in_lambda && (ret.length === 0)) ||
                                        ((ret[0] instanceof AST.Return) && !ret[0].value)) &&
                                            (!stat.body.value) &&
                                            (!stat.alternative)) {
                                    CHANGED = true;
                                    cond = make_node(AST.SimpleStatement, stat.condition, {
                                        body: stat.condition
                                    });
                                    ret.unshift(cond);
                                    continue;
                                }
                                if ((ret[0] instanceof AST.Return) && stat.body.value && ret[0].value && !stat.alternative) {
                                    CHANGED = true;
                                    stat = stat.clone();
                                    stat.alternative = ret[0];
                                    ret[0] = stat.transform(compressor);
                                    continue;
                                }
                                if ((ret.length === 0 || (ret[0] instanceof AST.Return)) && stat.body.value && !stat.alternative && in_lambda) {
                                    CHANGED = true;
                                    stat = stat.clone();
                                    stat.alternative = ret[0] || make_node(AST.Return, stat, {
                                        value: make_node(AST.Undefined, stat)
                                    });
                                    ret[0] = stat.transform(compressor);
                                    continue;
                                }
                                if (!stat.body.value && in_lambda) {
                                    CHANGED = true;
                                    stat = stat.clone();
                                    stat.condition = stat.condition.negate(compressor);
                                    stat.body = make_node(AST.BlockStatement, stat, {
                                        body: as_statement_array(stat.alternative).concat(ret)
                                    });
                                    stat.alternative = null;
                                    ret = [ stat.transform(compressor) ];
                                    continue;
                                }
                                if ((ret.length === 1) &&
                                        in_lambda &&
                                        (ret[0] instanceof AST.SimpleStatement) &&
                                        (!stat.alternative ||
                                            (stat.alternative instanceof AST.SimpleStatement))) {
                                    CHANGED = true;
                                    ret.push(make_node(AST.Return, ret[0], {
                                        value: make_node(AST.Undefined, ret[0])
                                    }).transform(compressor));
                                    ret = as_statement_array(stat.alternative).concat(ret);
                                    ret.unshift(stat);
                                    continue;
                                }
                            }

                            ab = aborts(stat.body);
                            lct = ab instanceof AST.LoopControl ? compressor.loopcontrol_target(ab.label) : null;
                            if (ab &&
                                    ((ab instanceof AST.Return && !ab.value && in_lambda) ||
                                        (ab instanceof AST.Continue && self === loop_body(lct)) ||
                                        (ab instanceof AST.Break && lct instanceof AST.BlockStatement && self === lct))) {
                                if (ab.label) {
                                    remove(ab.label.thedef.references, ab);
                                }
                                CHANGED = true;
                                body = as_statement_array(stat.body).slice(0, -1);
                                stat = stat.clone();
                                stat.condition = stat.condition.negate(compressor);
                                stat.body = make_node(AST.BlockStatement, stat, {
                                    body: as_statement_array(stat.alternative).concat(ret)
                                });
                                stat.alternative = make_node(AST.BlockStatement, stat, {
                                    body: body
                                });
                                ret = [ stat.transform(compressor) ];
                                continue;
                            }

                            ab = aborts(stat.alternative);
                            lct = ab instanceof AST.LoopControl ? compressor.loopcontrol_target(ab.label) : null;
                            if (ab &&
                                    ((ab instanceof AST.Return && !ab.value && in_lambda) ||
                                        (ab instanceof AST.Continue && self === loop_body(lct)) ||
                                        (ab instanceof AST.Break && lct instanceof AST.BlockStatement && self === lct))) {
                                if (ab.label) {
                                    remove(ab.label.thedef.references, ab);
                                }
                                CHANGED = true;
                                stat = stat.clone();
                                stat.body = make_node(AST.BlockStatement, stat.body, {
                                    body: as_statement_array(stat.body).concat(ret)
                                });
                                stat.alternative = make_node(AST.BlockStatement, stat.alternative, {
                                    body: as_statement_array(stat.alternative).slice(0, -1)
                                });
                                ret = [ stat.transform(compressor) ];
                                continue;
                            }

                            ret.unshift(stat);
                        } else {
                            ret.unshift(stat);
                        }
                    }
                    return ret;
                }

                function eliminate_dead_code(statements, compressor) {
                    var has_quit = false,
                        orig = statements.length,
                        self = compressor.self();
                    statements = statements.reduce(function (a, stat) {
                        var lct;
                        if (has_quit) {
                            extract_declarations_from_unreachable_code(compressor, stat, a);
                        } else {
                            if (stat instanceof AST.LoopControl) {
                                lct = compressor.loopcontrol_target(stat.label);
                                if (((stat instanceof AST.Break) &&
                                     (lct instanceof AST.BlockStatement) &&
                                     (loop_body(lct) === self)) ||
                                        ((stat instanceof AST.Continue) &&
                                            (loop_body(lct) === self))) {
                                    if (stat.label) {
                                        remove(stat.label.thedef.references, stat);
                                    }
                                } else {
                                    a.push(stat);
                                }
                            } else {
                                a.push(stat);
                            }
                            if (aborts(stat)) {
                                has_quit = true;
                            }
                        }
                        return a;
                    }, []);
                    CHANGED = statements.length !== orig;
                    return statements;
                }

                function sequencesize_2(statements, compressor) {
                    var ret = [],
                        prev = null;
                    function cons_seq(right) {
                        ret.pop();
                        var left = prev.body;
                        if (left instanceof AST.Seq) {
                            left.add(right);
                        } else {
                            left = AST.Seq.cons(left, right);
                        }
                        return left.transform(compressor);
                    }
                    statements.forEach(function (stat) {
                        var opera;
                        if (prev) {
                            if (stat instanceof AST.For) {
                                opera = {};
                                try {
                                    prev.body.walk(new TreeWalker(function (node) {
                                        if ((node instanceof AST.Binary) && (node.operator === "in")) {
                                            throw opera;
                                        }
                                    }));
                                    if (stat.init && !(stat.init instanceof AST.Definitions)) {
                                        stat.init = cons_seq(stat.init);
                                    } else if (!stat.init) {
                                        stat.init = prev.body;
                                        ret.pop();
                                    }
                                } catch (ex) {
                                    if (ex !== opera) {
                                        throw ex;
                                    }
                                }
                            } else if (stat instanceof AST.If) {
                                stat.condition = cons_seq(stat.condition);
                            } else if (stat instanceof AST.With) {
                                stat.expression = cons_seq(stat.expression);
                            } else if (stat instanceof AST.Exit && stat.value) {
                                stat.value = cons_seq(stat.value);
                            } else if (stat instanceof AST.Exit) {
                                stat.value = cons_seq(make_node(AST.Undefined, stat));
                            } else if (stat instanceof AST.Switch) {
                                stat.expression = cons_seq(stat.expression);
                            }
                        }
                        ret.push(stat);
                        prev = (stat instanceof AST.SimpleStatement) ? stat : null;
                    });
                    return ret;
                }

                function sequencesize(statements, compressor) {
                    var seq,
                        ret;
                    if (statements.length < 2) {
                        return statements;
                    }
                    seq = [];
                    ret = [];
                    function push_seq() {
                        seq = AST.Seq.from_array(seq);
                        if (seq) {
                            ret.push(make_node(AST.SimpleStatement, seq, {
                                body: seq
                            }));
                        }
                        seq = [];
                    }
                    statements.forEach(function (stat) {
                        if (stat instanceof AST.SimpleStatement) {
                            seq.push(stat.body);
                        } else {
                            push_seq();
                            ret.push(stat);
                        }
                    });
                    push_seq();
                    ret = sequencesize_2(ret, compressor);
                    CHANGED = (ret.length !== statements.length);
                    return ret;
                }

                function join_consecutive_vars(statements) {
                    var prev = null;
                    return statements.reduce(function (a, stat) {
                        if ((stat instanceof AST.Definitions) && prev && (prev.TYPE === stat.TYPE)) {
                            prev.definitions = prev.definitions.concat(stat.definitions);
                            CHANGED = true;
                        } else if ((stat instanceof AST.For) &&
                                (prev instanceof AST.Definitions) &&
                                (!stat.init || stat.init.TYPE === prev.TYPE)) {
                            CHANGED = true;
                            a.pop();
                            if (stat.init) {
                                stat.init.definitions = prev.definitions.concat(stat.init.definitions);
                            } else {
                                stat.init = prev;
                            }
                            a.push(stat);
                            prev = stat;
                        } else {
                            prev = stat;
                            a.push(stat);
                        }
                        return a;
                    }, []);
                }

                function negate_iifes(statements) {
                    statements.forEach(function (stat) {
                        if (stat instanceof AST.SimpleStatement) {
                            stat.body = (function transform(thing) {
                                return thing.transform(new TreeTransformer(function (node) {
                                    if ((node instanceof AST.Call) && (node.expression instanceof AST.Function)) {
                                        return make_node(AST.UnaryPrefix, node, {
                                            operator: "!",
                                            expression: node
                                        });
                                    }
                                    if (node instanceof AST.Call) {
                                        node.expression = transform(node.expression);
                                    } else if (node instanceof AST.Seq) {
                                        node.car = transform(node.car);
                                    } else if (node instanceof AST.Conditional) {
                                        var expr = transform(node.condition),
                                            tmp;
                                        if (expr !== node.condition) {
                                            // it has been negated, reverse
                                            node.condition = expr;
                                            tmp = node.consequent;
                                            node.consequent = node.alternative;
                                            node.alternative = tmp;
                                        }
                                    }
                                    return node;
                                }));
                            }(stat.body));
                        }
                    });
                }


                do {
                    CHANGED = false;
                    if (compressor.option("angular")) {
                        statements = process_for_angular(statements);
                    }
                    statements = eliminate_spurious_blocks(statements);
                    if (compressor.option("dead_code")) {
                        statements = eliminate_dead_code(statements, compressor);
                    }
                    if (compressor.option("if_return")) {
                        statements = handle_if_return(statements, compressor);
                    }
                    if (compressor.option("sequences")) {
                        statements = sequencesize(statements, compressor);
                    }
                    if (compressor.option("join_vars")) {
                        statements = join_consecutive_vars(statements, compressor);
                    }
                } while (CHANGED);

                if (compressor.option("negate_iife")) {
                    negate_iifes(statements, compressor);
                }

                return statements;

            }

            /* -----[ boolean/negation helpers ]----- */

            // methods to determine whether an expression has a boolean result type
            (function (def) {
                def(AST.Node, function () {
                    return false;
                });
                def(AST.UnaryPrefix, function () {
                    switch (this.operator) {
                    case "!":
                    case "delete":
                        return true;
                    default:
                        return false;
                    }
                });
                def(AST.Binary, function () {
                    switch (this.operator) {
                    case "in":
                    case "instanceof":
                    case "==":
                    case "!=":
                    case "===":
                    case "!==":
                    case "<":
                    case "<=":
                    case ">=":
                    case ">":
                        return true;
                    case "&&":
                    case "||":
                        return this.left.is_boolean() && this.right.is_boolean();
                    default:
                        return false;
                    }
                });
                def(AST.Conditional, function () {
                    return this.consequent.is_boolean() && this.alternative.is_boolean();
                });
                def(AST.Assign, function () {
                    return (this.operator === "=") && this.right.is_boolean();
                });
                def(AST.Seq, function () {
                    return this.cdr.is_boolean();
                });
                def(AST.True, function () {
                    return true;
                });
                def(AST.False, function () {
                    return true;
                });
            }(function (node, func) {
                node.DEFMETHOD("is_boolean", func);
            }));

            // methods to determine if an expression has a string result type
            (function (def) {
                def(AST.Node, function () {
                    return false;
                });
                def(AST.String, function () {
                    return true;
                });
                def(AST.UnaryPrefix, function () {
                    return (this.operator === "typeof");
                });
                def(AST.Binary, function (compressor) {
                    return (this.operator === "+") &&
                        (this.left.is_string(compressor) || this.right.is_string(compressor));
                });
                def(AST.Assign, function (compressor) {
                    return ((this.operator === "=") || (this.operator === "+=")) &&
                        this.right.is_string(compressor);
                });
                def(AST.Seq, function (compressor) {
                    return this.cdr.is_string(compressor);
                });
                def(AST.Conditional, function (compressor) {
                    return (this.consequent.is_string(compressor) &&
                        this.alternative.is_string(compressor));
                });
                def(AST.Call, function (compressor) {
                    return (compressor.option("unsafe") &&
                        (this.expression instanceof AST.SymbolRef) &&
                        (this.expression.name === "String") &&
                        this.expression.undeclared());
                });
            }(function (node, func) {
                node.DEFMETHOD("is_string", func);
            }));

            function best_of(ast1, ast2) {
                return (ast1.print_to_string().length > ast2.print_to_string().length) ? ast2 : ast1;
            }

            // methods to evaluate a constant expression
            (function (def) {
                // The evaluate method returns an array with one or two
                // elements.  If the node has been successfully reduced to a
                // constant, then the second element tells us the value;
                // otherwise the second element is missing.  The first element
                // of the array is always an AST.Node descendant; if
                // evaluation was successful it's a node that represents the
                // constant; otherwise it's the original or a replacement node.
                AST.Node.DEFMETHOD("evaluate", function (compressor) {
                    var val;
                    if (!compressor.option("evaluate")) {
                        return [ this ];
                    }
                    try {
                        val = this._eval(compressor);
                        return [ best_of(make_node_from_constant(compressor, val, this), this), val ];
                    } catch (ex) {
                        if (ex !== def) {
                            throw ex;
                        }
                        return [ this ];
                    }
                });
                def(AST.Statement, function () {
                    throw new Error("Cannot evaluate a statement [" + this.start.file + ":" + this.start.line + "," + this.start.col + "]");
                });
                def(AST.Function, function () {
                    // XXX: AST.Function inherits from AST.Scope, which itself
                    // inherits from AST.Statement; however, an AST.Function
                    // isn't really a statement.  This could bite in other
                    // places too. :-( Wish JS had multiple inheritance.
                    throw def;
                });
                function ev(node, compressor) {
                    if (!compressor) {
                        throw new Error("Compressor must be passed");
                    }

                    return node._eval(compressor);
                }
                def(AST.Node, function () {
                    throw def;          // not constant
                });
                def(AST.Constant, function () {
                    return this.getValue();
                });
                def(AST.UnaryPrefix, function (compressor) {
                    /*jslint bitwise: true*/
                    var e = this.expression;
                    switch (this.operator) {
                    case "!":
                        return !ev(e, compressor);
                    case "typeof":
                        // Function would be evaluated to an array and so typeof would
                        // incorrectly return 'object'. Hence making is a special case.
                        if (e instanceof AST.Function) {
                            return "function";
                        }

                        e = ev(e, compressor);

                        // typeof <RegExp> returns "object" or "function" on different platforms
                        // so cannot evaluate reliably
                        if (e instanceof RegExp) {
                            throw def;
                        }

                        return typeof e;
                    case "void":
                        return void ev(e, compressor);
                    case "~":
                        return ~ev(e, compressor);
                    case "-":
                        e = ev(e, compressor);
                        if (e === 0) {
                            throw def;
                        }
                        return -e;
                    case "+":
                        return +ev(e, compressor);
                    }
                    throw def;
                });
                def(AST.Binary, function (c) {
                    /*jslint bitwise: true, eqeq: true*/
                    var left = this.left,
                        right = this.right;
                    switch (this.operator) {
                    case "&&":
                        return ev(left, c) && ev(right, c);
                    case "||":
                        return ev(left, c) || ev(right, c);
                    case "|":
                        return ev(left, c) | ev(right, c);
                    case "&":
                        return ev(left, c) & ev(right, c);
                    case "^":
                        return ev(left, c) ^ ev(right, c);
                    case "+":
                        return ev(left, c) + ev(right, c);
                    case "*":
                        return ev(left, c) * ev(right, c);
                    case "/":
                        return ev(left, c) / ev(right, c);
                    case "%":
                        return ev(left, c) % ev(right, c);
                    case "-":
                        return ev(left, c) - ev(right, c);
                    case "<<":
                        return ev(left, c) << ev(right, c);
                    case ">>":
                        return ev(left, c) >> ev(right, c);
                    case ">>>":
                        return ev(left, c) >>> ev(right, c);
                    case "==":
                        return ev(left, c) == ev(right, c);
                    case "===":
                        return ev(left, c) === ev(right, c);
                    case "!=":
                        return ev(left, c) != ev(right, c);
                    case "!==":
                        return ev(left, c) !== ev(right, c);
                    case "<":
                        return ev(left, c) < ev(right, c);
                    case "<=":
                        return ev(left, c) <= ev(right, c);
                    case ">":
                        return ev(left, c) > ev(right, c);
                    case ">=":
                        return ev(left, c) >= ev(right, c);
                    case "in":
                        return ev(left, c) in ev(right, c);
                    case "instanceof":
                        return (ev(left, c) instanceof ev(right, c));
                    }
                    throw def;
                });
                def(AST.Conditional, function (compressor) {
                    return ev(this.condition, compressor) ?
                            ev(this.consequent, compressor) :
                            ev(this.alternative, compressor);
                });
                def(AST.SymbolRef, function (compressor) {
                    var d = this.definition();
                    if (d && d.constant && d.init) {
                        return ev(d.init, compressor);
                    }
                    throw def;
                });
                def(AST.Dot, function (compressor) {
                    var str;
                    if (compressor.option("unsafe") && (this.property === "length")) {
                        str = ev(this.expression, compressor);
                        if (typeof str === "string") {
                            return str.length;
                        }
                    }
                    throw def;
                });
            }(function (node, func) {
                node.DEFMETHOD("_eval", func);
            }));

            // method to negate an expression
            (function (def) {
                function basic_negation(exp) {
                    return make_node(AST.UnaryPrefix, exp, {
                        operator: "!",
                        expression: exp
                    });
                }
                def(AST.Node, function () {
                    return basic_negation(this);
                });
                def(AST.Statement, function () {
                    throw new Error("Cannot negate a statement");
                });
                def(AST.Function, function () {
                    return basic_negation(this);
                });
                def(AST.UnaryPrefix, function () {
                    if (this.operator === "!") {
                        return this.expression;
                    }
                    return basic_negation(this);
                });
                def(AST.Seq, function (compressor) {
                    var self = this.clone();
                    self.cdr = self.cdr.negate(compressor);
                    return self;
                });
                def(AST.Conditional, function (compressor) {
                    var self = this.clone();
                    self.consequent = self.consequent.negate(compressor);
                    self.alternative = self.alternative.negate(compressor);
                    return best_of(basic_negation(this), self);
                });
                def(AST.Binary, function (compressor) {
                    var self = this.clone(), op = this.operator;
                    if (compressor.option("unsafe_comps")) {
                        switch (op) {
                        case "<=":
                            self.operator = ">";
                            return self;
                        case "<":
                            self.operator = ">=";
                            return self;
                        case ">=":
                            self.operator = "<";
                            return self;
                        case ">":
                            self.operator = "<=";
                            return self;
                        }
                    }
                    switch (op) {
                    case "==":
                        self.operator = "!=";
                        return self;
                    case "!=":
                        self.operator = "==";
                        return self;
                    case "===":
                        self.operator = "!==";
                        return self;
                    case "!==":
                        self.operator = "===";
                        return self;
                    case "&&":
                        self.operator = "||";
                        self.left = self.left.negate(compressor);
                        self.right = self.right.negate(compressor);
                        return best_of(basic_negation(this), self);
                    case "||":
                        self.operator = "&&";
                        self.left = self.left.negate(compressor);
                        self.right = self.right.negate(compressor);
                        return best_of(basic_negation(this), self);
                    }
                    return basic_negation(this);
                });
            }(function (node, func) {
                node.DEFMETHOD("negate", function (compressor) {
                    return func.call(this, compressor);
                });
            }));

            // determine if expression has side effects
            (function (def) {
                def(AST.Node, function () {
                    return true;
                });

                def(AST.EmptyStatement, function () {
                    return false;
                });
                def(AST.Constant, function () {
                    return false;
                });
                def(AST.This, function () {
                    return false;
                });

                def(AST.Call, function (compressor) {
                    var pure = compressor.option("pure_funcs");
                    if (!pure) {
                        return true;
                    }
                    return pure.indexOf(this.expression.print_to_string()) < 0;
                });

                def(AST.Block, function (compressor) {
                    var i;
                    for (i = this.body.length - 1; i >= 0; --i) {
                        if (this.body[i].has_side_effects(compressor)) {
                            return true;
                        }
                    }
                    return false;
                });

                def(AST.SimpleStatement, function (compressor) {
                    return this.body.has_side_effects(compressor);
                });
                def(AST.Defun, function () {
                    return true;
                });
                def(AST.Function, function () {
                    return false;
                });
                def(AST.Binary, function (compressor) {
                    return this.left.has_side_effects(compressor) ||
                        this.right.has_side_effects(compressor);
                });
                def(AST.Assign, function () {
                    return true;
                });
                def(AST.Conditional, function (compressor) {
                    return this.condition.has_side_effects(compressor) ||
                        this.consequent.has_side_effects(compressor) ||
                        this.alternative.has_side_effects(compressor);
                });
                def(AST.Unary, function (compressor) {
                    switch (this.operator) {
                    case "delete":
                    case "++":
                    case "--":
                        return true;
                    }
                    return this.expression.has_side_effects(compressor);
                });
                def(AST.SymbolRef, function () {
                    return this.global() && this.undeclared();
                });
                def(AST.Object, function (compressor) {
                    var i;
                    for (i = this.properties.length - 1; i >= 0; --i) {
                        if (this.properties[i].has_side_effects(compressor)) {
                            return true;
                        }
                    }
                    return false;
                });
                def(AST.ObjectProperty, function (compressor) {
                    return this.value.has_side_effects(compressor);
                });
                def(AST.Array, function (compressor) {
                    var i;
                    for (i = this.elements.length - 1; i >= 0; --i) {
                        if (this.elements[i].has_side_effects(compressor)) {
                            return true;
                        }
                    }
                    return false;
                });
                def(AST.Dot, function (compressor) {
                    if (!compressor.option("pure_getters")) {
                        return true;
                    }
                    return this.expression.has_side_effects(compressor);
                });
                def(AST.Sub, function (compressor) {
                    if (!compressor.option("pure_getters")) {
                        return true;
                    }
                    return this.expression.has_side_effects(compressor) ||
                        this.property.has_side_effects(compressor);
                });
                def(AST.PropAccess, function (compressor) {
                    return !compressor.option("pure_getters");
                });
                def(AST.Seq, function (compressor) {
                    return this.car.has_side_effects(compressor) ||
                        this.cdr.has_side_effects(compressor);
                });
            }(function (node, func) {
                node.DEFMETHOD("has_side_effects", func);
            }));

            (function (def) {
                def(AST.Statement, function () {
                    return null;
                });
                def(AST.Jump, function () {
                    return this;
                });
                function block_aborts() {
                    /*jshint validthis: true */
                    var body = this.body,
                        n = body.length;
                    return n > 0 && aborts(body[n - 1]);
                }
                def(AST.BlockStatement, block_aborts);
                def(AST.SwitchBranch, block_aborts);
                def(AST.If, function () {
                    return this.alternative && aborts(this.body) && aborts(this.alternative) && this;
                });
            }(function (node, func) {
                node.DEFMETHOD("aborts", func);
            }));

            /* -----[ optimizers ]----- */

            OPT(AST.Directive, function (self) {
                if (self.scope.has_directive(self.value) !== self.scope) {
                    return make_node(AST.EmptyStatement, self);
                }
                return self;
            });

            OPT(AST.Debugger, function (self, compressor) {
                if (compressor.option("drop_debugger")) {
                    return make_node(AST.EmptyStatement, self);
                }
                return self;
            });

            OPT(AST.LabeledStatement, function (self, compressor) {
                if ((self.body instanceof AST.Break) &&
                        (compressor.loopcontrol_target(self.body.label) === self.body)) {
                    return make_node(AST.EmptyStatement, self);
                }
                return self.label.references.length === 0 ? self.body : self;
            });

            OPT(AST.Block, function (self, compressor) {
                self.body = tighten_body(self.body, compressor);
                return self;
            });

            OPT(AST.BlockStatement, function (self, compressor) {
                self.body = tighten_body(self.body, compressor);
                switch (self.body.length) {
                case 1:
                    return self.body[0];
                case 0:
                    return make_node(AST.EmptyStatement, self);
                }
                return self;
            });

            AST.Scope.DEFMETHOD("drop_unused", function (compressor) {
                var self = this,
                    in_use,
                    initializations,
                    scope,
                    tw,
                    tt;
                if (compressor.option("unused") &&
                        !(self instanceof AST.Toplevel) &&
                        !self.uses_eval) {
                    in_use = [];
                    initializations = new Dictionary();
                    // pass 1: find out which symbols are directly used in
                    // this scope (not in nested scopes).
                    scope = this;
                    tw = new TreeWalker(function (node, descend) {
                        var save_scope,
                            def;
                        if (node !== self) {
                            if (node instanceof AST.Defun) {
                                initializations.add(node.name.name, node);
                                return true; // don't go in nested scopes
                            }
                            if (node instanceof AST.Definitions && scope === self) {
                                node.definitions.forEach(function (def) {
                                    if (def.value) {
                                        initializations.add(def.name.name, def.value);
                                        if (def.value.has_side_effects(compressor)) {
                                            def.value.walk(tw);
                                        }
                                    }
                                });
                                return true;
                            }
                            if (node instanceof AST.SymbolRef) {
                                def = node.definition();
                                if (in_use.indexOf(def) === -1) {
                                    in_use.push(def);
                                }
                                return true;
                            }
                            if (node instanceof AST.Scope) {
                                save_scope = scope;
                                scope = node;
                                descend();
                                scope = save_scope;
                                return true;
                            }
                        }
                    });
                    self.walk(tw);

                    // pass 2: for every used symbol we need to walk its
                    // initialization code to figure out if it uses other
                    // symbols (that may not be in_use).
                    (function (in_use, initializations) {
                        var i,
                            j,
                            k,
                            orig,
                            inits,
                            init,
                            def;
                        function twfn(node) {
                            if (node instanceof AST.SymbolRef) {
                                def = node.definition();
                                if (in_use.indexOf(def) === -1) {
                                    in_use.push(def);
                                }
                            }
                        }
                        for (i = 0; i < in_use.length; ++i) {
                            orig = in_use[i].orig;
                            for (j = 0; j < orig.length; ++j) {
                                inits = initializations.get(orig[j].name) || [];
                                for (k = 0; k < inits.length; ++k) {
                                    init = inits[k];
                                    init.walk(new TreeWalker(twfn));
                                }
                            }
                        }
                    }(in_use, initializations));


                    // pass 3: we should drop declarations not in_use
                    tt = new TreeTransformer(function before(node, descend, in_list) {
                        var a,
                            sym,
                            def,
                            side_effects,
                            i,
                            x,
                            body;
                        if ((node instanceof AST.Lambda) && !(node instanceof AST.Accessor)) {
                            if (!compressor.option("keep_fargs")) {
                                a = node.argnames;
                                for (i = a.length - 1; i >= 0; --i) {
                                    sym = a[i];
                                    if (sym.unreferenced()) {
                                        a.pop();
                                        compressor.warn("Dropping unused function argument {name} [{file}:{line},{col}]", {
                                            name: sym.name,
                                            file: sym.start.file,
                                            line: sym.start.line,
                                            col: sym.start.col
                                        });
                                    } else {
                                        break;
                                    }
                                }
                            }
                        }
                        if (node instanceof AST.Defun && node !== self) {
                            if (in_use.indexOf(node.name.definition()) === -1) {
                                compressor.warn("Dropping unused function {name} [{file}:{line},{col}]", {
                                    name: node.name.name,
                                    file: node.name.start.file,
                                    line: node.name.start.line,
                                    col: node.name.start.col
                                });
                                return make_node(AST.EmptyStatement, node);
                            }
                            return node;
                        }
                        if ((node instanceof AST.Definitions) && !(tt.parent() instanceof AST.ForIn)) {
                            def = node.definitions.filter(function (def) {
                                var w;
                                if (in_use.indexOf(def.name.definition()) !== -1) {
                                    return true;
                                }
                                w = {
                                    name: def.name.name,
                                    file: def.name.start.file,
                                    line: def.name.start.line,
                                    col: def.name.start.col
                                };
                                if (def.value && def.value.has_side_effects(compressor)) {
                                    def._unused_side_effects = true;
                                    compressor.warn("Side effects in initialization of unused variable {name} [{file}:{line},{col}]", w);
                                    return true;
                                }
                                compressor.warn("Dropping unused variable {name} [{file}:{line},{col}]", w);
                                return false;
                            });
                            // place uninitialized names at the start
                            def = merge_sort(def, function (a, b) {
                                if (!a.value && b.value) {
                                    return -1;
                                }
                                if (!b.value && a.value) {
                                    return 1;
                                }
                                return 0;
                            });
                            // for unused names whose initialization has
                            // side effects, we can cascade the init. code
                            // into the next one, or next statement.
                            side_effects = [];
                            i = 0;
                            while (i < def.length) {
                                x = def[i];
                                if (x._unused_side_effects) {
                                    side_effects.push(x.value);
                                    def.splice(i, 1);
                                } else {
                                    if (side_effects.length > 0) {
                                        side_effects.push(x.value);
                                        x.value = AST.Seq.from_array(side_effects);
                                        side_effects = [];
                                    }
                                    ++i;
                                }
                            }
                            if (side_effects.length > 0) {
                                side_effects = make_node(AST.BlockStatement, node, {
                                    body: [ make_node(AST.SimpleStatement, node, {
                                        body: AST.Seq.from_array(side_effects)
                                    }) ]
                                });
                            } else {
                                side_effects = null;
                            }
                            if (def.length === 0 && !side_effects) {
                                return make_node(AST.EmptyStatement, node);
                            }
                            if (def.length === 0) {
                                return side_effects;
                            }
                            node.definitions = def;
                            if (side_effects) {
                                side_effects.body.unshift(node);
                                node = side_effects;
                            }
                            return node;
                        }
                        if (node instanceof AST.For) {
                            descend(node, this);

                            if (node.init instanceof AST.BlockStatement) {
                                // certain combination of unused name + side effect leads to:
                                //    https://github.com/mishoo/UglifyJS2/issues/44
                                // that's an invalid AST.
                                // We fix it at this stage by moving the `var` outside the `for`.

                                body = node.init.body.slice(0, -1);
                                node.init = node.init.body.slice(-1)[0].body;
                                body.push(node);

                                return in_list ? MAP.splice(body) : make_node(AST.BlockStatement, node, {
                                    body: body
                                });
                            }
                        }
                        if ((node instanceof AST.Scope) && (node !== self)) {
                            return node;
                        }
                    });
                    self.transform(tt);
                }
            });

            AST.Scope.DEFMETHOD("hoist_declarations", function (compressor) {
                /*jslint continue:true*/
                var hoist_funs = compressor.option("hoist_funs"),
                    hoist_vars = compressor.option("hoist_vars"),
                    self = this,
                    dirs,
                    hoisted,
                    vars,
                    vars_found,
                    var_decl,
                    tt,
                    def,
                    defs,
                    expr,
                    sym,
                    assign,
                    tmp;
                if (hoist_funs || hoist_vars) {
                    dirs = [];
                    hoisted = [];
                    vars = new Dictionary();
                    vars_found = 0;
                    var_decl = 0;
                    // let's count var_decl first, we seem to waste a lot of
                    // space if we hoist `var` when there's only one.
                    self.walk(new TreeWalker(function (node) {
                        if ((node instanceof AST.Scope) && (node !== self)) {
                            return true;
                        }
                        if (node instanceof AST.Var) {
                            ++var_decl;
                            return true;
                        }
                    }));
                    hoist_vars = hoist_vars && var_decl > 1;
                    tt = new TreeTransformer(
                        function before(node) {
                            var seq,
                                p;
                            if (node !== self) {
                                if (node instanceof AST.Directive) {
                                    dirs.push(node);
                                    return make_node(AST.EmptyStatement, node);
                                }
                                if (node instanceof AST.Defun && hoist_funs) {
                                    hoisted.push(node);
                                    return make_node(AST.EmptyStatement, node);
                                }
                                if (node instanceof AST.Var && hoist_vars) {
                                    node.definitions.forEach(function (def) {
                                        vars.set(def.name.name, def);
                                        ++vars_found;
                                    });
                                    seq = node.to_assignments();
                                    p = tt.parent();
                                    if ((p instanceof AST.ForIn) && (p.init === node)) {
                                        if (seq === null) {
                                            return node.definitions[0].name;
                                        }
                                        return seq;
                                    }
                                    if ((p instanceof AST.For) && (p.init === node)) {
                                        return seq;
                                    }
                                    if (!seq) {
                                        return make_node(AST.EmptyStatement, node);
                                    }
                                    return make_node(AST.SimpleStatement, node, {
                                        body: seq
                                    });
                                }
                                if (node instanceof AST.Scope) {
                                    return node; // to avoid descending in nested scopes
                                }
                            }
                        }
                    );
                    self = self.transform(tt);
                    if (vars_found > 0) {
                        // collect only vars which don't show up in self's arguments list
                        defs = [];
                        vars.each(function (def, name) {
                            if ((self instanceof AST.Lambda) &&
                                    find_if(function (x) {
                                        return (x.name === def.name.name);
                                    }, self.argnames)) {
                                vars.del(name);
                            } else {
                                def = def.clone();
                                def.value = null;
                                defs.push(def);
                                vars.set(name, def);
                            }
                        });
                        if (defs.length > 0) {
                            // try to merge in assignments
                            while (self.body.length) {
                                if (self.body[0] instanceof AST.SimpleStatement) {
                                    expr = self.body[0].body;
                                    if ((expr instanceof AST.Assign) && (expr.operator === "=")) {
                                        sym = expr.left;
                                        if ((sym instanceof AST.Symbol) && vars.has(sym.name)) {
                                            def = vars.get(sym.name);
                                            if (def.value) {
                                                break;
                                            }
                                            def.value = expr.right;
                                            remove(defs, def);
                                            defs.push(def);
                                            self.body.splice(0, 1);
                                            continue;
                                        }
                                    }
                                    if (expr instanceof AST.Seq) {
                                        assign = expr.car;
                                        if ((assign instanceof AST.Assign) && (assign.operator === "=")) {
                                            sym = assign.left;
                                            if ((sym instanceof AST.Symbol) && vars.has(sym.name)) {
                                                def = vars.get(sym.name);
                                                if (def.value) {
                                                    break;
                                                }
                                                def.value = assign.right;
                                                remove(defs, def);
                                                defs.push(def);
                                                self.body[0].body = expr.cdr;
                                                continue;
                                            }
                                        }
                                    }
                                }
                                if (self.body[0] instanceof AST.EmptyStatement) {
                                    self.body.splice(0, 1);
                                    continue;
                                }
                                if (self.body[0] instanceof AST.BlockStatement) {
                                    tmp = [0, 1].concat(self.body[0].body);
                                    self.body.splice.apply(self.body, tmp);
                                    continue;
                                }
                                break;
                            }
                            defs = make_node(AST.Var, self, {
                                definitions: defs
                            });
                            hoisted.push(defs);
                        }
                    }
                    self.body = dirs.concat(hoisted, self.body);
                }
                return self;
            });

            OPT(AST.SimpleStatement, function (self, compressor) {
                if (compressor.option("side_effects")) {
                    if (!self.body.has_side_effects(compressor)) {
                        compressor.warn("Dropping side-effect-free statement [{file}:{line},{col}]", self.start);
                        return make_node(AST.EmptyStatement, self);
                    }
                }
                return self;
            });

            OPT(AST.DWLoop, function (self, compressor) {
                var cond = self.condition.evaluate(compressor),
                    a;
                self.condition = cond[0];
                if (!compressor.option("loops")) {
                    return self;
                }
                if (cond.length > 1) {
                    if (cond[1]) {
                        return make_node(AST.For, self, {
                            body: self.body
                        });
                    }
                    if (self instanceof AST.While) {
                        if (compressor.option("dead_code")) {
                            a = [];
                            extract_declarations_from_unreachable_code(compressor, self.body, a);
                            return make_node(AST.BlockStatement, self, {
                                body: a
                            });
                        }
                    }
                }
                return self;
            });

            function if_break_in_loop(self, compressor) {
                var first;
                function drop_it(rest) {
                    rest = as_statement_array(rest);
                    if (self.body instanceof AST.BlockStatement) {
                        self.body = self.body.clone();
                        self.body.body = rest.concat(self.body.body.slice(1));
                        self.body = self.body.transform(compressor);
                    } else {
                        self.body = make_node(AST.BlockStatement, self.body, {
                            body: rest
                        }).transform(compressor);
                    }
                    if_break_in_loop(self, compressor);
                }
                first = (self.body instanceof AST.BlockStatement) ? self.body.body[0] : self.body;
                if (first instanceof AST.If) {
                    if ((first.body instanceof AST.Break) &&
                            compressor.loopcontrol_target(first.body.label) === self) {
                        if (self.condition) {
                            self.condition = make_node(AST.Binary, self.condition, {
                                left: self.condition,
                                operator: "&&",
                                right: first.condition.negate(compressor)
                            });
                        } else {
                            self.condition = first.condition.negate(compressor);
                        }
                        drop_it(first.alternative);
                    } else if ((first.alternative instanceof AST.Break) &&
                            (compressor.loopcontrol_target(first.alternative.label) === self)) {
                        if (self.condition) {
                            self.condition = make_node(AST.Binary, self.condition, {
                                left: self.condition,
                                operator: "&&",
                                right: first.condition
                            });
                        } else {
                            self.condition = first.condition;
                        }
                        drop_it(first.body);
                    }
                }
            }

            OPT(AST.While, function (self, compressor) {
                if (!compressor.option("loops")) {
                    return self;
                }
                self = AST.DWLoop.prototype.optimize.call(self, compressor);
                if (self instanceof AST.While) {
                    if_break_in_loop(self, compressor);
                    self = make_node(AST.For, self, self).transform(compressor);
                }
                return self;
            });

            OPT(AST.For, function (self, compressor) {
                var cond = self.condition,
                    a;
                if (cond) {
                    cond = cond.evaluate(compressor);
                    self.condition = cond[0];
                }
                if (!compressor.option("loops")) {
                    return self;
                }
                if (cond) {
                    if (cond.length > 1 && !cond[1]) {
                        if (compressor.option("dead_code")) {
                            a = [];
                            if (self.init instanceof AST.Statement) {
                                a.push(self.init);
                            } else if (self.init) {
                                a.push(make_node(AST.SimpleStatement, self.init, {
                                    body: self.init
                                }));
                            }
                            extract_declarations_from_unreachable_code(compressor, self.body, a);
                            return make_node(AST.BlockStatement, self, {
                                body: a
                            });
                        }
                    }
                }
                if_break_in_loop(self, compressor);
                return self;
            });

            OPT(AST.If, function (self, compressor) {
                var cond,
                    a,
                    negated,
                    negated_is_best,
                    tmp,
                    body,
                    alt;
                if (!compressor.option("conditionals")) {
                    return self;
                }
                // if condition can be statically determined, warn and drop
                // one of the blocks.  note, statically determined implies
                // “has no side effects”; also it doesn't work for cases like
                // `x && true`, though it probably should.
                cond = self.condition.evaluate(compressor);
                self.condition = cond[0];
                if (cond.length > 1) {
                    if (cond[1]) {
                        compressor.warn("Condition always true [{file}:{line},{col}]", self.condition.start);
                        if (compressor.option("dead_code")) {
                            a = [];
                            if (self.alternative) {
                                extract_declarations_from_unreachable_code(compressor, self.alternative, a);
                            }
                            a.push(self.body);
                            return make_node(AST.BlockStatement, self, {
                                body: a
                            }).transform(compressor);
                        }
                    } else {
                        compressor.warn("Condition always false [{file}:{line},{col}]", self.condition.start);
                        if (compressor.option("dead_code")) {
                            a = [];
                            extract_declarations_from_unreachable_code(compressor, self.body, a);
                            if (self.alternative) {
                                a.push(self.alternative);
                            }
                            return make_node(AST.BlockStatement, self, {
                                body: a
                            }).transform(compressor);
                        }
                    }
                }
                if (is_empty(self.alternative)) {
                    self.alternative = null;
                }
                negated = self.condition.negate(compressor);
                negated_is_best = best_of(self.condition, negated) === negated;
                if (self.alternative && negated_is_best) {
                    negated_is_best = false; // because we already do the switch here.
                    self.condition = negated;
                    tmp = self.body;
                    self.body = self.alternative || make_node(AST.EmptyStatement);
                    self.alternative = tmp;
                }
                if (is_empty(self.body) && is_empty(self.alternative)) {
                    return make_node(AST.SimpleStatement, self.condition, {
                        body: self.condition
                    }).transform(compressor);
                }
                if ((self.body instanceof AST.SimpleStatement) &&
                        (self.alternative instanceof AST.SimpleStatement)) {
                    return make_node(AST.SimpleStatement, self, {
                        body: make_node(AST.Conditional, self, {
                            condition: self.condition,
                            consequent: self.body.body,
                            alternative: self.alternative.body
                        })
                    }).transform(compressor);
                }
                if (is_empty(self.alternative) && self.body instanceof AST.SimpleStatement) {
                    if (negated_is_best) {
                        return make_node(AST.SimpleStatement, self, {
                            body: make_node(AST.Binary, self, {
                                operator: "||",
                                left: negated,
                                right: self.body.body
                            })
                        }).transform(compressor);
                    }
                    return make_node(AST.SimpleStatement, self, {
                        body: make_node(AST.Binary, self, {
                            operator: "&&",
                            left: self.condition,
                            right: self.body.body
                        })
                    }).transform(compressor);
                }
                if ((self.body instanceof AST.EmptyStatement) &&
                        self.alternative &&
                        (self.alternative instanceof AST.SimpleStatement)) {
                    return make_node(AST.SimpleStatement, self, {
                        body: make_node(AST.Binary, self, {
                            operator: "||",
                            left: self.condition,
                            right: self.alternative.body
                        })
                    }).transform(compressor);
                }
                if ((self.body instanceof AST.Exit) &&
                        (self.alternative instanceof AST.Exit) &&
                        (self.body.TYPE === self.alternative.TYPE)) {
                    return make_node(self.body.CTOR, self, {
                        value: make_node(AST.Conditional, self, {
                            condition: self.condition,
                            consequent: self.body.value || make_node(AST.Undefined, self.body).optimize(compressor),
                            alternative: self.alternative.value || make_node(AST.Undefined, self.alternative).optimize(compressor)
                        })
                    }).transform(compressor);
                }
                if ((self.body instanceof AST.If) &&
                        !self.body.alternative &&
                        !self.alternative) {
                    self.condition = make_node(AST.Binary, self.condition, {
                        operator: "&&",
                        left: self.condition,
                        right: self.body.condition
                    }).transform(compressor);
                    self.body = self.body.body;
                }
                if (aborts(self.body)) {
                    if (self.alternative) {
                        alt = self.alternative;
                        self.alternative = null;
                        return make_node(AST.BlockStatement, self, {
                            body: [ self, alt ]
                        }).transform(compressor);
                    }
                }
                if (aborts(self.alternative)) {
                    body = self.body;
                    self.body = self.alternative;
                    self.condition = negated_is_best ? negated : self.condition.negate(compressor);
                    self.alternative = null;
                    return make_node(AST.BlockStatement, self, {
                        body: [ self, body ]
                    }).transform(compressor);
                }
                return self;
            });

            OPT(AST.Switch, function (self, compressor) {
                var last_branch,
                    stat,
                    exp1,
                    value,
                    in_if,
                    in_block,
                    started,
                    stopped,
                    ruined,
                    tt,
                    done;
                if ((self.body.length === 0) && compressor.option("conditionals")) {
                    return make_node(AST.SimpleStatement, self, {
                        body: self.expression
                    }).transform(compressor);
                }
                done = false;
                while (!done) {
                    last_branch = self.body[self.body.length - 1];
                    if (last_branch) {
                        stat = last_branch.body[last_branch.body.length - 1]; // last statement
                        if ((stat instanceof AST.Break) && (loop_body(compressor.loopcontrol_target(stat.label)) === self)) {
                            last_branch.body.pop();
                        }
                        if ((last_branch instanceof AST.Default) && (last_branch.body.length === 0)) {
                            self.body.pop();
                        } else {
                            done = true;
                        }
                    } else {
                        done = true;
                    }
                }
                exp1 = self.expression.evaluate(compressor);

                if (exp1.length === 2) {
                    try {
                        // constant expression
                        self.expression = exp1[0];
                        if (compressor.option("dead_code")) {
                            value = exp1[1];
                            in_if = false;
                            in_block = false;
                            started = false;
                            stopped = false;
                            ruined = false;
                            tt = new TreeTransformer(function (node, descend, in_list) {
                                var save,
                                    exp;
                                if ((node instanceof AST.Lambda) || (node instanceof AST.SimpleStatement)) {
                                    // no need to descend these node types
                                    return node;
                                }
                                if (node instanceof AST.Switch && node === self) {
                                    node = node.clone();
                                    descend(node, this);
                                    return ruined ? node : make_node(AST.BlockStatement, node, {
                                        body: node.body.reduce(function (a, branch) {
                                            return a.concat(branch.body);
                                        }, [])
                                    }).transform(compressor);
                                }
                                if ((node instanceof AST.If) || (node instanceof AST.Try)) {
                                    save = in_if;
                                    in_if = !in_block;
                                    descend(node, this);
                                    in_if = save;
                                    return node;
                                }
                                if ((node instanceof AST.StatementWithBody) || (node instanceof AST.Switch)) {
                                    save = in_block;
                                    in_block = true;
                                    descend(node, this);
                                    in_block = save;
                                    return node;
                                }
                                if ((node instanceof AST.Break) && (this.loopcontrol_target(node.label) === self)) {
                                    if (in_if) {
                                        ruined = true;
                                        return node;
                                    }
                                    if (in_block) {
                                        return node;
                                    }
                                    stopped = true;
                                    return in_list ? MAP.skip : make_node(AST.EmptyStatement, node);
                                }
                                if ((node instanceof AST.SwitchBranch) && (this.parent() === self)) {
                                    if (stopped) {
                                        return MAP.skip;
                                    }
                                    if (node instanceof AST.Case) {
                                        exp = node.expression.evaluate(compressor);
                                        if (exp.length < 2) {
                                            // got a case with non-constant expression, baling out
                                            throw self;
                                        }
                                        if (exp[1] === value || started) {
                                            started = true;
                                            if (aborts(node)) {
                                                stopped = true;
                                            }
                                            descend(node, this);
                                            return node;
                                        }
                                        return MAP.skip;
                                    }
                                    descend(node, this);
                                    return node;
                                }
                            });
                            tt.stack = compressor.stack.slice(); // so that's able to see parent nodes
                            self = self.transform(tt);
                        }
                    } catch (ex) {
                        if (ex !== self) {
                            throw ex;
                        }
                    }
                }
                return self;
            });

            OPT(AST.Case, function (self, compressor) {
                self.body = tighten_body(self.body, compressor);
                return self;
            });

            OPT(AST.Try, function (self, compressor) {
                self.body = tighten_body(self.body, compressor);
                return self;
            });

            AST.Definitions.DEFMETHOD("remove_initializers", function () {
                this.definitions.forEach(function (def) {
                    def.value = null;
                });
            });

            AST.Definitions.DEFMETHOD("to_assignments", function () {
                var assignments = this.definitions.reduce(function (a, def) {
                    if (def.value) {
                        var name = make_node(AST.SymbolRef, def.name, def.name);
                        a.push(make_node(AST.Assign, def, {
                            operator: "=",
                            left: name,
                            right: def.value
                        }));
                    }
                    return a;
                }, []);
                if (assignments.length === 0) {
                    return null;
                }
                return AST.Seq.from_array(assignments);
            });

            OPT(AST.Definitions, function (self) {
                if (self.definitions.length === 0) {
                    return make_node(AST.EmptyStatement, self);
                }
                return self;
            });

            OPT(AST.Function, function (self, compressor) {
                self = AST.Lambda.prototype.optimize.call(self, compressor);
                if (compressor.option("unused") && !compressor.option("keep_fnames")) {
                    if (self.name && self.name.unreferenced()) {
                        self.name = null;
                    }
                }
                return self;
            });

            function all(array, predicate) {
                var i;
                for (i = array.length - 1; i >= 0; --i) {
                    if (!predicate(array[i])) {
                        return false;
                    }
                }
                return true;
            }

            OPT(AST.Call, function (self, compressor) {
                var exp,
                    code,
                    ast,
                    comp,
                    fun,
                    args,
                    separator,
                    elements,
                    first,
                    node;
                if (compressor.option("unsafe")) {
                    exp = self.expression;
                    if (exp instanceof AST.SymbolRef && exp.undeclared()) {
                        switch (exp.name) {
                        case "Array":
                            if (self.args.length !== 1) {
                                return make_node(AST.Array, self, {
                                    elements: self.args
                                }).transform(compressor);
                            }
                            break;
                        case "Object":
                            if (self.args.length === 0) {
                                return make_node(AST.Object, self, {
                                    properties: []
                                });
                            }
                            break;
                        case "String":
                            if (self.args.length === 0) {
                                return make_node(AST.String, self, {
                                    value: ""
                                });
                            }
                            if (self.args.length <= 1) {
                                return make_node(AST.Binary, self, {
                                    left: self.args[0],
                                    operator: "+",
                                    right: make_node(AST.String, self, {
                                        value: ""
                                    })
                                }).transform(compressor);
                            }
                            break;
                        case "Number":
                            if (self.args.length === 0) {
                                return make_node(AST.Number, self, {
                                    value: 0
                                });
                            }
                            if (self.args.length === 1) {
                                return make_node(AST.UnaryPrefix, self, {
                                    expression: self.args[0],
                                    operator: "+"
                                }).transform(compressor);
                            }
                            break;
                        case "Boolean":
                            if (self.args.length === 0) {
                                return make_node(AST.False, self);
                            }
                            if (self.args.length === 1) {
                                return make_node(AST.UnaryPrefix, self, {
                                    expression: make_node(AST.UnaryPrefix, null, {
                                        expression: self.args[0],
                                        operator: "!"
                                    }),
                                    operator: "!"
                                }).transform(compressor);
                            }
                            break;
                        case "Function":
                            // new Function() => function(){}
                            if (self.args.length === 0) {
                                return make_node(AST.Function, self, {
                                    argnames: [],
                                    body: []
                                });
                            }
                            if (all(self.args, function (x) {
                                    return x instanceof AST.String;
                                })) {
                                // quite a corner-case, but we can handle it:
                                //   https://github.com/mishoo/UglifyJS2/issues/203
                                // if the code argument is a constant, then we can minify it.
                                try {
                                    code = "(function (" + self.args.slice(0, -1).map(function (arg) {
                                        return arg.value;
                                    }).join(",") + ") {" + self.args[self.args.length - 1].value + "})()";
                                    ast = parse(code);
                                    ast.figure_out_scope({
                                        screw_ie8: compressor.option("screw_ie8")
                                    });
                                    comp = new Compressor(compressor.options, undefined, get_warn(warn_callback), croak_callback);
                                    ast = ast.transform(comp);
                                    ast.figure_out_scope({
                                        screw_ie8: compressor.option("screw_ie8")
                                    });
                                    ast.mangle_names();
                                    try {
                                        ast.walk(new TreeWalker(function (node) {
                                            if (node instanceof AST.Lambda) {
                                                fun = node;
                                                throw ast;
                                            }
                                        }));
                                    } catch (ex) {
                                        if (ex !== ast) {
                                            throw ex;
                                        }
                                    }
                                    if (!fun) {
                                        return self;
                                    }
                                    args = fun.argnames.map(function (arg, i) {
                                        return make_node(AST.String, self.args[i], {
                                            value: arg.print_to_string()
                                        });
                                    });
                                    code = new OutputStream();
                                    AST.BlockStatement.prototype._codegen.call(fun, fun, code);
                                    code = code.toString().replace(/^\{|\}$/g, "");
                                    args.push(make_node(AST.String, self.args[self.args.length - 1], {
                                        value: code
                                    }));
                                    self.args = args;
                                    return self;
                                } catch (ex) {
                                    if (ex instanceof JS_Parse_Error) {
                                        compressor.warn("Error parsing code passed to new Function [{file}:{line},{col}]", self.args[self.args.length - 1].start);
                                        compressor.warn(ex.toString());
                                    } else if (typeof warn_callback === "function") {
                                        warn_callback(ex);
                                        throw ex;
                                    }
                                }
                            }
                            break;
                        }
                    } else if ((exp instanceof AST.Dot) && (exp.property === "toString") && (self.args.length === 0)) {
                        return make_node(AST.Binary, self, {
                            left: make_node(AST.String, self, {
                                value: ""
                            }),
                            operator: "+",
                            right: exp.expression
                        }).transform(compressor);
                    }
                    if ((exp instanceof AST.Dot) && (exp.expression instanceof AST.Array) && (exp.property === "join")) {
                        separator = self.args.length === 0 ? "," : self.args[0].evaluate(compressor)[1];
                        if (separator) {
                            elements = exp.expression.elements.reduce(function (a, el) {
                                var last,
                                    val;
                                el = el.evaluate(compressor);
                                if (a.length === 0 || el.length === 1) {
                                    a.push(el);
                                } else {
                                    last = a[a.length - 1];
                                    if (last.length === 2) {
                                        // it's a constant
                                        val = String(last[1] + separator + el[1]);
                                        a[a.length - 1] = [ make_node_from_constant(compressor, val, last[0]), val ];
                                    } else {
                                        a.push(el);
                                    }
                                }
                                return a;
                            }, []);
                            if (elements.length === 0) {
                                return make_node(AST.String, self, {
                                    value: ""
                                });
                            }
                            if (elements.length === 1) {
                                return elements[0][0];
                            }
                            if (separator === "") {
                                if (elements[0][0] instanceof AST.String ||
                                        elements[1][0] instanceof AST.String) {
                                    first = elements.shift()[0];
                                } else {
                                    first = make_node(AST.String, self, {
                                        value: ""
                                    });
                                }
                                return elements.reduce(function (prev, el) {
                                    return make_node(AST.Binary, el[0], {
                                        operator: "+",
                                        left: prev,
                                        right: el[0]
                                    });
                                }, first).transform(compressor);
                            }
                            // need this awkward cloning to not affect original element
                            // best_of will decide which one to get through.
                            node = self.clone();
                            node.expression = node.expression.clone();
                            node.expression.expression = node.expression.expression.clone();
                            node.expression.expression.elements = elements.map(function (el) {
                                return el[0];
                            });
                            return best_of(self, node);
                        }

                    }
                }
                if (compressor.option("side_effects")) {
                    if ((self.expression instanceof AST.Function) &&
                            (self.args.length === 0) &&
                            !AST.Block.prototype.has_side_effects.call(self.expression, compressor)) {
                        return make_node(AST.Undefined, self).transform(compressor);
                    }
                }
                if (compressor.option("drop_console")) {
                    if (self.expression instanceof AST.PropAccess) {
                        exp = self.expression.expression;
                        while (exp.expression) {
                            exp = exp.expression;
                        }
                        if ((exp instanceof AST.SymbolRef) &&
                                (exp.name === "console") &&
                                exp.undeclared()) {
                            return make_node(AST.Undefined, self).transform(compressor);
                        }
                    }
                }
                return self.evaluate(compressor)[0];
            });

            OPT(AST.New, function (self, compressor) {
                var exp;
                if (compressor.option("unsafe")) {
                    exp = self.expression;
                    if (exp instanceof AST.SymbolRef && exp.undeclared()) {
                        switch (exp.name) {
                        case "Object":
                        case "RegExp":
                        case "Function":
                        case "Error":
                        case "Array":
                            return make_node(AST.Call, self, self).transform(compressor);
                        }
                    }
                }
                return self;
            });

            OPT(AST.Seq, function (self, compressor) {
                if (!compressor.option("side_effects")) {
                    return self;
                }
                if (!self.car.has_side_effects(compressor)) {
                    // we shouldn't compress (1,eval)(something) to
                    // eval(something) because that changes the meaning of
                    // eval (becomes lexical instead of global).
                    var p;
                    if (!(self.cdr instanceof AST.SymbolRef) ||
                            (self.cdr.name !== "eval") ||
                            !self.cdr.undeclared()) {
                        p = compressor.parent();
                        if ((p instanceof AST.Call) && (p.expression === self)) {
                            return self.cdr;
                        }
                    }
                }
                if (compressor.option("cascade")) {
                    if ((self.car instanceof AST.Assign) &&
                            !self.car.left.has_side_effects(compressor)) {
                        if (self.car.left.equivalent_to(self.cdr)) {
                            return self.car;
                        }
                        if ((self.cdr instanceof AST.Call) &&
                                self.cdr.expression.equivalent_to(self.car.left)) {
                            self.cdr.expression = self.car;
                            return self.cdr;
                        }
                    }
                    if (!self.car.has_side_effects(compressor) &&
                            !self.cdr.has_side_effects(compressor) &&
                            self.car.equivalent_to(self.cdr)) {
                        return self.car;
                    }
                }
                if ((self.cdr instanceof AST.UnaryPrefix) &&
                        (self.cdr.operator === "void") &&
                        !self.cdr.expression.has_side_effects(compressor)) {
                    self.cdr.expression = self.car;
                    return self.cdr;
                }
                if (self.cdr instanceof AST.Undefined) {
                    return make_node(AST.UnaryPrefix, self, {
                        operator: "void",
                        expression: self.car
                    });
                }
                return self;
            });

            AST.Unary.DEFMETHOD("lift_sequences", function (compressor) {
                var seq,
                    x;
                if (compressor.option("sequences")) {
                    if (this.expression instanceof AST.Seq) {
                        seq = this.expression;
                        x = seq.to_array();
                        this.expression = x.pop();
                        x.push(this);
                        seq = AST.Seq.from_array(x).transform(compressor);
                        return seq;
                    }
                }
                return this;
            });

            OPT(AST.UnaryPostfix, function (self, compressor) {
                return self.lift_sequences(compressor);
            });

            OPT(AST.UnaryPrefix, function (self, compressor) {
                var e;
                self = self.lift_sequences(compressor);
                e = self.expression;
                if (compressor.option("booleans") && compressor.in_boolean_context()) {
                    switch (self.operator) {
                    case "!":
                        if ((e instanceof AST.UnaryPrefix) && (e.operator === "!")) {
                            // !!foo ==> foo, if we're in boolean context
                            return e.expression;
                        }
                        break;
                    case "typeof":
                        // typeof always returns a non-empty string, thus it's
                        // always true in booleans
                        compressor.warn("Boolean expression always true [{file}:{line},{col}]", self.start);
                        return make_node(AST.True, self);
                    }
                    if ((e instanceof AST.Binary) && (self.operator === "!")) {
                        self = best_of(self, e.negate(compressor));
                    }
                }
                return self.evaluate(compressor)[0];
            });

            function has_side_effects_or_prop_access(node, compressor) {
                var save_pure_getters,
                    ret;
                save_pure_getters = compressor.option("pure_getters");
                compressor.options.pure_getters = false;
                ret = node.has_side_effects(compressor);
                compressor.options.pure_getters = save_pure_getters;
                return ret;
            }

            AST.Binary.DEFMETHOD("lift_sequences", function (compressor) {
                var seq,
                    x;
                if (compressor.option("sequences")) {
                    if (this.left instanceof AST.Seq) {
                        seq = this.left;
                        x = seq.to_array();
                        this.left = x.pop();
                        x.push(this);
                        seq = AST.Seq.from_array(x).transform(compressor);
                        return seq;
                    }
                    if ((this.right instanceof AST.Seq) &&
                            (this instanceof AST.Assign) &&
                            !has_side_effects_or_prop_access(this.left, compressor)) {
                        seq = this.right;
                        x = seq.to_array();
                        this.right = x.pop();
                        x.push(this);
                        seq = AST.Seq.from_array(x).transform(compressor);
                        return seq;
                    }
                }
                return this;
            });


            OPT(AST.Binary, function (self, compressor) {
                var reverse,
                    ll,
                    rr,
                    negated,
                    isCommutative;
                reverse = compressor.has_directive("use asm") ? function () {
                    return;
                } : function (op, force) {
                    var tmp;
                    if (force ||
                            !(self.left.has_side_effects(compressor) ||
                                self.right.has_side_effects(compressor))) {
                        if (op) {
                            self.operator = op;
                        }
                        tmp = self.left;
                        self.left = self.right;
                        self.right = tmp;
                    }
                };
                switch (self.operator) {
                case "==":
                case "!=":
                case "===":
                case "!==":
                case "*":
                case "&":
                case "|":
                case "^":
                    isCommutative = true;
                    break;
                }

                if (isCommutative) {
                    if ((self.right instanceof AST.Constant) &&
                            !(self.left instanceof AST.Constant)) {
                        // if right is a constant, whatever side effects the
                        // left side might have could not influence the
                        // result.  hence, force switch.

                        if (!((self.left instanceof AST.Binary) &&
                                (precedence(self.left.operator) >= precedence(self.operator)))) {
                            reverse(null, true);
                        }
                    }
                    if (/^[!=]==?$/.test(self.operator)) {
                        if (self.left instanceof AST.SymbolRef && self.right instanceof AST.Conditional) {
                            if ((self.right.consequent instanceof AST.SymbolRef) &&
                                    (self.right.consequent.definition() === self.left.definition())) {
                                if (/^==/.test(self.operator)) {
                                    return self.right.condition;
                                }
                                if (/^!=/.test(self.operator)) {
                                    return self.right.condition.negate(compressor);
                                }
                            }
                            if ((self.right.alternative instanceof AST.SymbolRef) &&
                                    (self.right.alternative.definition() === self.left.definition())) {
                                if (/^==/.test(self.operator)) {
                                    return self.right.condition.negate(compressor);
                                }
                                if (/^!=/.test(self.operator)) {
                                    return self.right.condition;
                                }
                            }
                        }
                        if (self.right instanceof AST.SymbolRef && self.left instanceof AST.Conditional) {
                            if ((self.left.consequent instanceof AST.SymbolRef) &&
                                    (self.left.consequent.definition() === self.right.definition())) {
                                if (/^==/.test(self.operator)) {
                                    return self.left.condition;
                                }
                                if (/^!=/.test(self.operator)) {
                                    return self.left.condition.negate(compressor);
                                }
                            }
                            if ((self.left.alternative instanceof AST.SymbolRef) &&
                                    (self.left.alternative.definition() === self.right.definition())) {
                                if (/^==/.test(self.operator)) {
                                    return self.left.condition.negate(compressor);
                                }
                                if (/^!=/.test(self.operator)) {
                                    return self.left.condition;
                                }
                            }
                        }
                    }
                }
                self = self.lift_sequences(compressor);
                if (compressor.option("comparisons")) {
                    /*jshint -W086: true */
                    switch (self.operator) {
                    case "===":
                    case "!==":
                        if ((self.left.is_string(compressor) && self.right.is_string(compressor)) ||
                                (self.left.is_boolean() && self.right.is_boolean())) {
                            self.operator = self.operator.substr(0, 2);
                        }
                    // XXX: intentionally falling down to the next case
                    /* falls through */
                    case "==":
                    case "!=":
                        if ((self.left instanceof AST.String) &&
                                (self.left.value === "undefined") &&
                                (self.right instanceof AST.UnaryPrefix) &&
                                (self.right.operator === "typeof") &&
                                compressor.option("unsafe")) {
                            if (!(self.right.expression instanceof AST.SymbolRef) ||
                                    !self.right.expression.undeclared()) {
                                self.right = self.right.expression;
                                self.left = make_node(AST.Undefined, self.left).optimize(compressor);
                                if (self.operator.length === 2) {
                                    self.operator += "=";
                                }
                            }
                        }
                        break;
                    }
                }
                if (compressor.option("booleans") && compressor.in_boolean_context()) {
                    switch (self.operator) {
                    case "&&":
                        ll = self.left.evaluate(compressor);
                        rr = self.right.evaluate(compressor);
                        if ((ll.length > 1 && !ll[1]) || (rr.length > 1 && !rr[1])) {
                            compressor.warn("Boolean && always false [{file}:{line},{col}]", self.start);
                            if (self.left.has_side_effects(compressor)) {
                                return make_node(AST.Seq, self, {
                                    car: self.left,
                                    cdr: make_node(AST.False)
                                }).optimize(compressor);
                            }
                            return make_node(AST.False, self);
                        }
                        if (ll.length > 1 && ll[1]) {
                            return rr[0];
                        }
                        if (rr.length > 1 && rr[1]) {
                            return ll[0];
                        }
                        break;
                    case "||":
                        ll = self.left.evaluate(compressor);
                        rr = self.right.evaluate(compressor);
                        if ((ll.length > 1 && ll[1]) || (rr.length > 1 && rr[1])) {
                            compressor.warn("Boolean || always true [{file}:{line},{col}]", self.start);
                            if (self.left.has_side_effects(compressor)) {
                                return make_node(AST.Seq, self, {
                                    car: self.left,
                                    cdr: make_node(AST.True)
                                }).optimize(compressor);
                            }
                            return make_node(AST.True, self);
                        }
                        if (ll.length > 1 && !ll[1]) {
                            return rr[0];
                        }
                        if (rr.length > 1 && !rr[1]) {
                            return ll[0];
                        }
                        break;
                    case "+":
                        ll = self.left.evaluate(compressor);
                        rr = self.right.evaluate(compressor);
                        if ((ll.length > 1 && ll[0] instanceof AST.String && ll[1]) ||
                                (rr.length > 1 && rr[0] instanceof AST.String && rr[1])) {
                            compressor.warn("+ in boolean context always true [{file}:{line},{col}]", self.start);
                            return make_node(AST.True, self);
                        }
                        break;
                    }
                }
                if (compressor.option("comparisons")) {
                    if (!(compressor.parent() instanceof AST.Binary) ||
                            compressor.parent() instanceof AST.Assign) {
                        negated = make_node(AST.UnaryPrefix, self, {
                            operator: "!",
                            expression: self.negate(compressor)
                        });
                        self = best_of(self, negated);
                    }
                    switch (self.operator) {
                    case "<":
                        reverse(">");
                        break;
                    case "<=":
                        reverse(">=");
                        break;
                    }
                }
                if ((self.operator === "+") &&
                        (self.right instanceof AST.String) &&
                        (self.right.getValue() === "") &&
                        (self.left instanceof AST.Binary) &&
                        (self.left.operator === "+") &&
                        self.left.is_string(compressor)) {
                    return self.left;
                }
                if (compressor.option("evaluate")) {
                    if (self.operator === "+") {
                        if ((self.left instanceof AST.Constant) &&
                                (self.right instanceof AST.Binary) &&
                                (self.right.operator === "+") &&
                                (self.right.left instanceof AST.Constant) &&
                                self.right.is_string(compressor)) {
                            self = make_node(AST.Binary, self, {
                                operator: "+",
                                left: make_node(AST.String, null, {
                                    value: String(self.left.getValue() + self.right.left.getValue()),
                                    start: self.left.start,
                                    end: self.right.left.end
                                }),
                                right: self.right.right
                            });
                        }
                        if ((self.right instanceof AST.Constant) &&
                                (self.left instanceof AST.Binary) &&
                                (self.left.operator === "+") &&
                                (self.left.right instanceof AST.Constant) &&
                                self.left.is_string(compressor)) {
                            self = make_node(AST.Binary, self, {
                                operator: "+",
                                left: self.left.left,
                                right: make_node(AST.String, null, {
                                    value: String(self.left.right.getValue() + self.right.getValue()),
                                    start: self.left.right.start,
                                    end: self.right.end
                                })
                            });
                        }
                        if ((self.left instanceof AST.Binary) &&
                                (self.left.operator === "+") &&
                                self.left.is_string(compressor) &&
                                (self.left.right instanceof AST.Constant) &&
                                (self.right instanceof AST.Binary) &&
                                (self.right.operator === "+") &&
                                (self.right.left instanceof AST.Constant) &&
                                self.right.is_string(compressor)) {
                            self = make_node(AST.Binary, self, {
                                operator: "+",
                                left: make_node(AST.Binary, self.left, {
                                    operator: "+",
                                    left: self.left.left,
                                    right: make_node(AST.String, null, {
                                        value: String(self.left.right.getValue() + self.right.left.getValue()),
                                        start: self.left.right.start,
                                        end: self.right.left.end
                                    })
                                }),
                                right: self.right.right
                            });
                        }
                    }
                }
                // x * (y * z)  ==>  x * y * z
                if ((self.right instanceof AST.Binary) &&
                        (self.right.operator === self.operator) &&
                        ((self.operator === "*") ||
                            (self.operator === "&&") ||
                            (self.operator === "||"))) {
                    self.left = make_node(AST.Binary, self.left, {
                        operator: self.operator,
                        left: self.left,
                        right: self.right.left
                    });
                    self.right = self.right.right;
                    return self.transform(compressor);
                }
                return self.evaluate(compressor)[0];
            });

            OPT(AST.SymbolRef, function (self, compressor) {
                var defines;
                if (self.undeclared()) {
                    defines = compressor.option("global_defs");
                    if (defines && defines.hasOwnProperty(self.name)) {
                        return make_node_from_constant(compressor, defines[self.name], self);
                    }
                    switch (self.name) {
                    case "undefined":
                        return make_node(AST.Undefined, self);
                    case "NaN":
                        return make_node(AST.NaN, self).transform(compressor);
                    case "Infinity":
                        return make_node(AST.Infinity, self).transform(compressor);
                    }
                }
                return self;
            });

            OPT(AST.Infinity, function (self, compressor) {
                return make_node(AST.Binary, self, {
                    operator: '/',
                    left: make_node(AST.Number, null, {
                        value: 1
                    }),
                    right: make_node(AST.Number, null, {
                        value: 0
                    })
                });
            });

            OPT(AST.NaN, function (self, compressor) {
                return make_node(AST.Binary, self, {
                    operator: '/',
                    left: make_node(AST.Number, null, {
                        value: 0
                    }),
                    right: make_node(AST.Number, null, {
                        value: 0
                    })
                });
            });

            OPT(AST.Undefined, function (self, compressor) {
                var scope,
                    undef,
                    ref;
                if (compressor.option("unsafe")) {
                    scope = compressor.find_parent(AST.Scope);
                    undef = scope.find_variable("undefined");
                    if (undef) {
                        ref = make_node(AST.SymbolRef, self, {
                            name: "undefined",
                            scope: scope,
                            thedef: undef
                        });
                        ref.reference();
                        return ref;
                    }
                }
                return self;
            });

            OPT(AST.Assign, function (self, compressor) {
                self = self.lift_sequences(compressor);
                if ((self.operator === "=") &&
                        (self.left instanceof AST.SymbolRef) &&
                        (self.right instanceof AST.Binary) &&
                        (self.right.left instanceof AST.SymbolRef) &&
                        (self.right.left.name === self.left.name)) {
                    switch (self.right.operator) {
                    case "+":
                    case "-":
                    case "/":
                    case "*":
                    case "%":
                    case ">>":
                    case "<<":
                    case ">>>":
                    case "|":
                    case "^":
                    case "&":
                        self.operator = self.right.operator + "=";
                        self.right = self.right.right;
                        break;
                    }
                }
                return self;
            });

            OPT(AST.Conditional, function (self, compressor) {
                var car,
                    cond,
                    negated,
                    consequent,
                    alternative;
                if (!compressor.option("conditionals")) {
                    return self;
                }
                if (self.condition instanceof AST.Seq) {
                    car = self.condition.car;
                    self.condition = self.condition.cdr;
                    return AST.Seq.cons(car, self);
                }
                cond = self.condition.evaluate(compressor);
                if (cond.length > 1) {
                    if (cond[1]) {
                        compressor.warn("Condition always true [{file}:{line},{col}]", self.start);
                        return self.consequent;
                    }
                    compressor.warn("Condition always false [{file}:{line},{col}]", self.start);
                    return self.alternative;
                }
                negated = cond[0].negate(compressor);
                if (best_of(cond[0], negated) === negated) {
                    self = make_node(AST.Conditional, self, {
                        condition: negated,
                        consequent: self.alternative,
                        alternative: self.consequent
                    });
                }
                consequent = self.consequent;
                alternative = self.alternative;
                if ((consequent instanceof AST.Assign) &&
                        (alternative instanceof AST.Assign) &&
                        (consequent.operator === alternative.operator) &&
                        (consequent.left.equivalent_to(alternative.left))) {
                    /*
                     * Stuff like this:
                     * if (foo) exp = something; else exp = something_else;
                     * ==>
                     * exp = foo ? something : something_else;
                     */
                    return make_node(AST.Assign, self, {
                        operator: consequent.operator,
                        left: consequent.left,
                        right: make_node(AST.Conditional, self, {
                            condition: self.condition,
                            consequent: consequent.right,
                            alternative: alternative.right
                        })
                    });
                }
                if ((consequent instanceof AST.Call) &&
                        (alternative.TYPE === consequent.TYPE) &&
                        (consequent.args.length === alternative.args.length) &&
                        consequent.expression.equivalent_to(alternative.expression)) {
                    if (consequent.args.length === 0) {
                        return make_node(AST.Seq, self, {
                            car: self.condition,
                            cdr: consequent
                        });
                    }
                    if (consequent.args.length === 1) {
                        consequent.args[0] = make_node(AST.Conditional, self, {
                            condition: self.condition,
                            consequent: consequent.args[0],
                            alternative: alternative.args[0]
                        });
                        return consequent;
                    }
                }
                // x?y?z:a:a --> x&&y?z:a
                if ((consequent instanceof AST.Conditional) &&
                        consequent.alternative.equivalent_to(alternative)) {
                    return make_node(AST.Conditional, self, {
                        condition: make_node(AST.Binary, self, {
                            left: self.condition,
                            operator: "&&",
                            right: consequent.condition
                        }),
                        consequent: consequent.consequent,
                        alternative: alternative
                    });
                }

                // x=y?1:1 --> x=1
                if ((consequent instanceof AST.Constant) &&
                        (alternative instanceof AST.Constant) &&
                        consequent.equivalent_to(alternative)) {
                    if (self.condition.has_side_effects(compressor)) {
                        return AST.Seq.from_array([
                            self.condition,
                            make_node_from_constant(compressor, consequent.value, self)
                        ]);
                    }
                    return make_node_from_constant(compressor, consequent.value, self);
                }

                // x=y?true:false --> x=!!y
                if ((consequent instanceof AST.True) && (alternative instanceof AST.False)) {
                    self.condition = self.condition.negate(compressor);
                    return make_node(AST.UnaryPrefix, self.condition, {
                        operator: "!",
                        expression: self.condition
                    });
                }

                // x=y?false:true --> x=!y
                if ((consequent instanceof AST.False) && (alternative instanceof AST.True)) {
                    return self.condition.negate(compressor);
                }

                return self;
            });

            OPT(AST.Boolean, function (self, compressor) {
                if (compressor.option("booleans")) {
                    var p = compressor.parent();
                    if ((p instanceof AST.Binary) &&
                            ((p.operator === "==") || (p.operator === "!="))) {
                        compressor.warn("Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]", {
                            operator: p.operator,
                            value: self.value,
                            file: p.start.file,
                            line: p.start.line,
                            col: p.start.col
                        });
                        return make_node(AST.Number, self, {
                            value: +self.value
                        });
                    }
                    return make_node(AST.UnaryPrefix, self, {
                        operator: "!",
                        expression: make_node(AST.Number, self, {
                            value: 1 - self.value
                        })
                    });
                }
                return self;
            });

            OPT(AST.Sub, function (self, compressor) {
                /*jslint eqeq:true */
                var prop = self.property,
                    cond,
                    v;
                if ((prop instanceof AST.String) && compressor.option("properties")) {
                    prop = prop.getValue();
                    cond = predicates.RESERVED_WORDS(prop) ? compressor.option("screw_ie8") : is.identifier_string(prop);
                    if (cond) {
                        return make_node(AST.Dot, self, {
                            expression: self.expression,
                            property: prop
                        }).optimize(compressor);
                    }
                    v = parseFloat(prop);
                    if (!isNaN(v) && (v.toString() == prop)) {
                        self.property = make_node(AST.Number, self.property, {
                            value: v
                        });
                    }
                }
                return self;
            });

            OPT(AST.Dot, function (self, compressor) {
                var prop = self.property;
                if (predicates.RESERVED_WORDS(prop) && !compressor.option("screw_ie8")) {
                    return make_node(AST.Sub, self, {
                        expression: self.expression,
                        property: make_node(AST.String, self, {
                            value: prop
                        })
                    }).optimize(compressor);
                }
                return self.evaluate(compressor)[0];
            });

            function literals_in_boolean_context(self, compressor) {
                if (compressor.option("booleans") && compressor.in_boolean_context()) {
                    return make_node(AST.True, self);
                }
                return self;
            }
            OPT(AST.Array, literals_in_boolean_context);
            OPT(AST.Object, literals_in_boolean_context);
            OPT(AST.RegExp, literals_in_boolean_context);

            AST.has_compress_support = true;
        }

        return add_compress_fns_to_AST;
    }
);