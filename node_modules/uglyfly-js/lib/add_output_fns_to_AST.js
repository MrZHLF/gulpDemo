/***********************************************************************
  Copyright 2014      (c) Saair Quaderi <saair.quaderi@gmail.com>
  Copyright 2012-2013 (c) Mihai Bazon <mihai.bazon@gmail.com>

  UglyflyJS sourcecode can be found here:
    https://github.com/quaderi/uglyflyjs

  UglyflyJS (by Saair) is a fork of UglifyJS2 (by Mihai Bazon)
  Both libraries are released under the BSD 2-Clause License.
 ***********************************************************************/

/*globals define, module, require */

((typeof define === "function") ? define :
        function () { "use strict"; require('./nd').apply(module, arguments); })(
    "add_output_fns_to_AST",
    [
        "TreeWalker",
        "predicates",
        "precedence",
        "is",
        "OutputStream"
    ],
    function (TreeWalker, predicates, precedence, is, OutputStream) {
        "use strict";
        function add_output_fns_to_AST(AST) {
            /*jslint nomen: true, plusplus: true, unparam: true */
            /*jshint unused: true*/

            if (AST.has_output_support) {
                return;
            }

            /* -----[ utils ]----- */

            function noop() {
                return;
            }

            function DEFPRINT(nodetype, generator) {
                nodetype.DEFMETHOD("_codegen", generator);
            }

            AST.Node.DEFMETHOD("print", function (stream, force_parens) {
                var self = this, generator = self._codegen;
                function doit() {
                    self.add_comments(stream);
                    self.add_source_map(stream);
                    generator(self, stream);
                }
                stream.push_node(self);
                if (force_parens || self.needs_parens(stream)) {
                    stream.with_parens(doit);
                } else {
                    doit();
                }
                stream.pop_node();
            });

            AST.Node.DEFMETHOD("print_to_string", function (options) {
                var s = new OutputStream(options);
                this.print(s);
                return s.get();
            });

            /* -----[ comments ]----- */

            AST.Node.DEFMETHOD("add_comments", function (output) {
                var c = output.option("comments"),
                    self = this,
                    start,
                    comments;
                if (c) {
                    start = self.start;
                    if (start && !start._comments_dumped) {
                        start._comments_dumped = true;
                        comments = start.comments_before || [];

                        // XXX: ugly fix for https://github.com/mishoo/UglifyJS2/issues/112
                        //               and https://github.com/mishoo/UglifyJS2/issues/372
                        if (self instanceof AST.Exit && self.value) {
                            self.value.walk(new TreeWalker(function (node) {
                                if (node.start && node.start.comments_before) {
                                    comments = comments.concat(node.start.comments_before);
                                    node.start.comments_before = [];
                                }
                                if ((node instanceof AST.Function) || (node instanceof AST.Array) || (node instanceof AST.Object)) {
                                    return true; // don't go inside.
                                }
                            }));
                        }

                        if (c.test) {
                            comments = comments.filter(function (comment) {
                                return c.test(comment.value);
                            });
                        } else if (typeof c === "function") {
                            comments = comments.filter(function (comment) {
                                return c(self, comment);
                            });
                        }

                        // Keep single line comments after nlb, after nlb
                        if (!output.option("beautify") && comments.length &&
                                (/comment[134]/).test(comments[0].type) &&
                                (output.col() !== 0) && comments[0].nlb) {
                            output.print("\n");
                        }

                        comments.forEach(function (c) {
                            if (/comment[134]/.test(c.type)) {
                                output.print("//" + c.value + "\n");
                                output.indent();
                            } else if (c.type === "comment2") {
                                output.print("/*" + c.value + "*/");
                                if (start.nlb) {
                                    output.print("\n");
                                    output.indent();
                                } else {
                                    output.space();
                                }
                            }
                        });
                    }
                }
            });

            /* -----[ PARENTHESES ]----- */

            function PARENS(nodetype, func) {
                if (Array.isArray(nodetype)) {
                    nodetype.forEach(function (nodetype) {
                        PARENS(nodetype, func);
                    });
                } else {
                    nodetype.DEFMETHOD("needs_parens", func);
                }
            }

            PARENS(AST.Node, function () {
                return false;
            });


            // return true if the node at the top of the stack (that means the
            // innermost node in the current output) is lexically the first in
            // a statement.
            function first_in_statement(output) {
                var a = output.stack(), i = a.length, node = a[--i], p = a[--i];
                while (i > 0) {
                    if ((p instanceof AST.Statement) && (p.body === node)) {
                        return true;
                    }
                    if (((p instanceof AST.Seq) && (p.car === node)) ||
                            ((p instanceof AST.Call) && (p.expression === node) && !(p instanceof AST.New)) ||
                            ((p instanceof AST.Dot) && (p.expression === node)) ||
                            ((p instanceof AST.Sub) && (p.expression === node)) ||
                            ((p instanceof AST.Conditional) && (p.condition === node)) ||
                            ((p instanceof AST.Binary) && (p.left === node)) ||
                            ((p instanceof AST.UnaryPostfix) && (p.expression === node))) {
                        node = p;
                        p = a[--i];
                    } else {
                        return false;
                    }
                }
            }

            // a function expression needs parens around it when it's provably
            // the first token to appear in a statement.
            PARENS(AST.Function, function (output) {
                return first_in_statement(output);
            });

            // same goes for an object literal, because otherwise it would be
            // interpreted as a block of code.
            PARENS(AST.Object, function (output) {
                return first_in_statement(output);
            });

            PARENS([AST.Unary, AST.Undefined], function (output) {
                var p = output.parent();
                return p instanceof AST.PropAccess && p.expression === this;
            });

            PARENS(AST.Seq, function (output) {
                var p = output.parent();
                return ((p instanceof AST.Call) ||          // (foo, bar)() or foo(1, (2, 3), 4)
                    (p instanceof AST.Unary) ||          // !(foo, bar, baz)
                    (p instanceof AST.Binary) ||         // 1 + (2, 3) + 4 ==> 8
                    (p instanceof AST.VarDef) ||         // var a = (1, 2), b = a + a; ==> b == 4
                    (p instanceof AST.PropAccess) ||     // (1, {foo:2}).foo or (1, {foo:2})["foo"] ==> 2
                    (p instanceof AST.Array) ||          // [ 1, (2, 3), 4 ] ==> [ 1, 3, 4 ]
                    (p instanceof AST.ObjectProperty) || // { foo: (1, 2) }.foo ==> 2
                    (p instanceof AST.Conditional));     /* (false, true) ? (a = 10, b = 20) : (c = 30)
                                                             * ==> 20 (side effect, set a := 10 and b := 20) */
            });

            PARENS(AST.Binary, function (output) {
                /*jslint eqeq: true */
                var p = output.parent(),
                    po,
                    pp,
                    so,
                    sp;
                // (foo && bar)()
                if (p instanceof AST.Call && p.expression === this) {
                    return true;
                }
                // typeof (foo && bar)
                if (p instanceof AST.Unary) {
                    return true;
                }
                // (foo && bar)["prop"], (foo && bar).prop
                if (p instanceof AST.PropAccess && p.expression === this) {
                    return true;
                }
                // this deals with precedence: 3 * (2 + 1)
                if (p instanceof AST.Binary) {
                    po = p.operator;
                    pp = precedence(po);
                    so = this.operator;
                    sp = precedence(so);
                    if ((pp > sp) || ((pp == sp) && (this === p.right))) {
                        return true;
                    }
                }
            });

            PARENS(AST.PropAccess, function (output) {
                var p = output.parent();
                if (p instanceof AST.New && p.expression === this) {
                    // i.e. new (foo.bar().baz)
                    //
                    // if there's one call into this subtree, then we need
                    // parens around it too, otherwise the call will be
                    // interpreted as passing the arguments to the upper New
                    // expression.
                    try {
                        this.walk(new TreeWalker(function (node) {
                            if (node instanceof AST.Call) {
                                throw p;
                            }
                        }));
                    } catch (ex) {
                        if (ex !== p) {
                            throw ex;
                        }
                        return true;
                    }
                }
            });

            PARENS(AST.Call, function (output) {
                var p = output.parent(), p1;
                if (p instanceof AST.New && p.expression === this) {
                    return true;
                }

                // workaround for Safari bug.
                // https://bugs.webkit.org/show_bug.cgi?id=123506
                if ((this.expression instanceof AST.Function) &&
                        (p instanceof AST.PropAccess) &&
                        (p.expression === this)) {
                    p1 = output.parent(1);
                    return (p1 instanceof AST.Assign) && (p1.left === p);
                }
                return false;
            });

            // self should be AST.New.  decide if we want to show parens or not.
            function no_constructor_parens(self, output) {
                return (self.args.length === 0) && !output.option("beautify");
            }

            PARENS(AST.New, function (output) {
                var p = output.parent();
                if (no_constructor_parens(this, output) &&
                        ((p instanceof AST.PropAccess) || // (new Date).getTime(), (new Date)["getTime"]()
                            ((p instanceof AST.Call) && (p.expression === this)))) { // (new foo)(bar)
                    return true;
                }
            });

            PARENS(AST.Number, function (output) {
                var p = output.parent();
                if ((this.getValue() < 0) && (p instanceof AST.PropAccess) && (p.expression === this)) {
                    return true;
                }
            });

            PARENS([AST.Assign, AST.Conditional], function (output) {
                /*jshint validthis:true */
                var p = output.parent();
                // !(a = false) → true
                if (p instanceof AST.Unary) {
                    return true;
                }
                // 1 + (a = 2) + 3 → 6, side effect setting a = 2
                if ((p instanceof AST.Binary) && !(p instanceof AST.Assign)) {
                    return true;
                }
                // (a = func)() —or— new (a = Object)()
                if ((p instanceof AST.Call) && (p.expression === this)) {
                    return true;
                }
                // (a = foo) ? bar : baz
                if ((p instanceof AST.Conditional) && (p.condition === this)) {
                    return true;
                }
                // (a = foo)["prop"] —or— (a = foo).prop
                if ((p instanceof AST.PropAccess) && (p.expression === this)) {
                    return true;
                }
            });

            /* -----[ PRINTERS ]----- */

            DEFPRINT(AST.Directive, function (self, output) {
                output.print_string(self.value, self.quote);
                output.semicolon();
            });
            DEFPRINT(AST.Debugger, function (self, output) {
                output.print("debugger");
                output.semicolon();
            });

            /* -----[ statements ]----- */

            function display_body(body, is_toplevel, output) {
                var last = body.length - 1;
                body.forEach(function (stmt, i) {
                    if (!(stmt instanceof AST.EmptyStatement)) {
                        output.indent();
                        stmt.print(output);
                        if (!((i === last) && is_toplevel)) {
                            output.newline();
                            if (is_toplevel) {
                                output.newline();
                            }
                        }
                    }
                });
            }

            function force_statement(stat, output) {
                if (output.option("bracketize")) {
                    if (!stat || (stat instanceof AST.EmptyStatement)) {
                        output.print("{}");
                    } else if (stat instanceof AST.BlockStatement) {
                        stat.print(output);
                    } else {
                        output.with_block(function () {
                            output.indent();
                            stat.print(output);
                            output.newline();
                        });
                    }
                } else {
                    if (!stat || (stat instanceof AST.EmptyStatement)) {
                        output.force_semicolon();
                    } else {
                        stat.print(output);
                    }
                }
            }

            AST.StatementWithBody.DEFMETHOD("_do_print_body", function (output) {
                force_statement(this.body, output);
            });

            DEFPRINT(AST.Statement, function (self, output) {
                self.body.print(output);
                output.semicolon();
            });
            DEFPRINT(AST.Toplevel, function (self, output) {
                display_body(self.body, true, output);
                output.print("");
            });
            DEFPRINT(AST.LabeledStatement, function (self, output) {
                self.label.print(output);
                output.colon();
                self.body.print(output);
            });
            DEFPRINT(AST.SimpleStatement, function (self, output) {
                self.body.print(output);
                output.semicolon();
            });
            function print_bracketed(body, output) {
                if (body.length > 0) {
                    output.with_block(function () {
                        display_body(body, false, output);
                    });
                } else {
                    output.print("{}");
                }
            }
            DEFPRINT(AST.BlockStatement, function (self, output) {
                print_bracketed(self.body, output);
            });
            DEFPRINT(AST.EmptyStatement, function (self, output) {
                output.semicolon();
            });
            DEFPRINT(AST.Do, function (self, output) {
                output.print("do");
                output.space();
                self._do_print_body(output);
                output.space();
                output.print("while");
                output.space();
                output.with_parens(function () {
                    self.condition.print(output);
                });
                output.semicolon();
            });
            DEFPRINT(AST.While, function (self, output) {
                output.print("while");
                output.space();
                output.with_parens(function () {
                    self.condition.print(output);
                });
                output.space();
                self._do_print_body(output);
            });

            function parenthesize_for_noin(node, output, noin) {
                if (!noin) {
                    node.print(output);
                } else {
                    try {
                        // need to take some precautions here:
                        //    https://github.com/mishoo/UglifyJS2/issues/60
                        node.walk(new TreeWalker(function (node) {
                            if ((node instanceof AST.Binary) && (node.operator === "in")) {
                                throw output;
                            }
                        }));
                        node.print(output);
                    } catch (ex) {
                        if (ex !== output) {
                            throw ex;
                        }
                        node.print(output, true);
                    }
                }
            }

            DEFPRINT(AST.For, function (self, output) {
                output.print("for");
                output.space();
                output.with_parens(function () {
                    if (self.init && !(self.init instanceof AST.EmptyStatement)) {
                        if (self.init instanceof AST.Definitions) {
                            self.init.print(output);
                        } else {
                            parenthesize_for_noin(self.init, output, true);
                        }
                        output.print(";");
                        output.space();
                    } else {
                        output.print(";");
                    }
                    if (self.condition) {
                        self.condition.print(output);
                        output.print(";");
                        output.space();
                    } else {
                        output.print(";");
                    }
                    if (self.step) {
                        self.step.print(output);
                    }
                });
                output.space();
                self._do_print_body(output);
            });
            DEFPRINT(AST.ForIn, function (self, output) {
                output.print("for");
                output.space();
                output.with_parens(function () {
                    self.init.print(output);
                    output.space();
                    output.print("in");
                    output.space();
                    self.object.print(output);
                });
                output.space();
                self._do_print_body(output);
            });
            DEFPRINT(AST.With, function (self, output) {
                output.print("with");
                output.space();
                output.with_parens(function () {
                    self.expression.print(output);
                });
                output.space();
                self._do_print_body(output);
            });

            /* -----[ functions ]----- */
            AST.Lambda.DEFMETHOD("_do_print", function (output, nokeyword) {
                var self = this;
                if (!nokeyword) {
                    output.print("function");
                }
                if (self.name) {
                    output.space();
                    self.name.print(output);
                }
                output.with_parens(function () {
                    self.argnames.forEach(function (arg, i) {
                        if (i) {
                            output.comma();
                        }
                        arg.print(output);
                    });
                });
                output.space();
                print_bracketed(self.body, output);
            });
            DEFPRINT(AST.Lambda, function (self, output) {
                self._do_print(output);
            });

            /* -----[ exits ]----- */
            AST.Exit.DEFMETHOD("_do_print", function (output, kind) {
                output.print(kind);
                if (this.value) {
                    output.space();
                    this.value.print(output);
                }
                output.semicolon();
            });
            DEFPRINT(AST.Return, function (self, output) {
                self._do_print(output, "return");
            });
            DEFPRINT(AST.Throw, function (self, output) {
                self._do_print(output, "throw");
            });

            /* -----[ loop control ]----- */
            AST.LoopControl.DEFMETHOD("_do_print", function (output, kind) {
                output.print(kind);
                if (this.label) {
                    output.space();
                    this.label.print(output);
                }
                output.semicolon();
            });
            DEFPRINT(AST.Break, function (self, output) {
                self._do_print(output, "break");
            });
            DEFPRINT(AST.Continue, function (self, output) {
                self._do_print(output, "continue");
            });


            function make_block(stmt, output) {
                if (stmt instanceof AST.BlockStatement) {
                    stmt.print(output);
                    return;
                }
                output.with_block(function () {
                    output.indent();
                    stmt.print(output);
                    output.newline();
                });
            }

            /* -----[ if ]----- */
            function make_then(self, output) {
                if (output.option("bracketize")) {
                    make_block(self.body, output);
                    return;
                }
                // The squeezer replaces "block"-s that contain only a single
                // statement with the statement itself; technically, the AST
                // is correct, but this can create problems when we output an
                // IF having an ELSE clause where the THEN clause ends in an
                // IF *without* an ELSE block (then the outer ELSE would refer
                // to the inner IF).  This function checks for this case and
                // adds the block brackets if needed.
                if (!self.body) {
                    return output.force_semicolon();
                }
                if ((self.body instanceof AST.Do) && !output.option("screw_ie8")) {
                    // https://github.com/mishoo/UglifyJS/issues/#issue/57 IE
                    // croaks with "syntax error" on code like this: if (foo)
                    // do ... while(cond); else ...  we need block brackets
                    // around do/while
                    make_block(self.body, output);
                    return;
                }
                var b = self.body;
                while (true) {
                    if (b instanceof AST.If) {
                        if (!b.alternative) {
                            make_block(self.body, output);
                            return;
                        }
                        b = b.alternative;
                    } else if (b instanceof AST.StatementWithBody) {
                        b = b.body;
                    } else {
                        break;
                    }
                }
                force_statement(self.body, output);
            }
            DEFPRINT(AST.If, function (self, output) {
                output.print("if");
                output.space();
                output.with_parens(function () {
                    self.condition.print(output);
                });
                output.space();
                if (self.alternative) {
                    make_then(self, output);
                    output.space();
                    output.print("else");
                    output.space();
                    force_statement(self.alternative, output);
                } else {
                    self._do_print_body(output);
                }
            });

            /* -----[ switch ]----- */
            DEFPRINT(AST.Switch, function (self, output) {
                output.print("switch");
                output.space();
                output.with_parens(function () {
                    self.expression.print(output);
                });
                output.space();
                if (self.body.length > 0) {
                    output.with_block(function () {
                        self.body.forEach(function (stmt, i) {
                            if (i) {
                                output.newline();
                            }
                            output.indent(true);
                            stmt.print(output);
                        });
                    });
                } else {
                    output.print("{}");
                }
            });
            AST.SwitchBranch.DEFMETHOD("_do_print_body", function (output) {
                if (this.body.length > 0) {
                    output.newline();
                    this.body.forEach(function (stmt) {
                        output.indent();
                        stmt.print(output);
                        output.newline();
                    });
                }
            });
            DEFPRINT(AST.Default, function (self, output) {
                output.print("default:");
                self._do_print_body(output);
            });
            DEFPRINT(AST.Case, function (self, output) {
                output.print("case");
                output.space();
                self.expression.print(output);
                output.print(":");
                self._do_print_body(output);
            });

            /* -----[ exceptions ]----- */
            DEFPRINT(AST.Try, function (self, output) {
                output.print("try");
                output.space();
                print_bracketed(self.body, output);
                if (self.bcatch) {
                    output.space();
                    self.bcatch.print(output);
                }
                if (self.bfinally) {
                    output.space();
                    self.bfinally.print(output);
                }
            });
            DEFPRINT(AST.Catch, function (self, output) {
                output.print("catch");
                output.space();
                output.with_parens(function () {
                    self.argname.print(output);
                });
                output.space();
                print_bracketed(self.body, output);
            });
            DEFPRINT(AST.Finally, function (self, output) {
                output.print("finally");
                output.space();
                print_bracketed(self.body, output);
            });

            /* -----[ var/const ]----- */
            AST.Definitions.DEFMETHOD("_do_print", function (output, kind) {
                var p,
                    in_for,
                    avoid_semicolon;
                output.print(kind);
                output.space();
                this.definitions.forEach(function (def, i) {
                    if (i) {
                        output.comma();
                    }
                    def.print(output);
                });
                p = output.parent();
                in_for = (p instanceof AST.For) || (p instanceof AST.ForIn);
                avoid_semicolon = in_for && (p.init === this);
                if (!avoid_semicolon) {
                    output.semicolon();
                }
            });
            DEFPRINT(AST.Var, function (self, output) {
                self._do_print(output, "var");
            });
            DEFPRINT(AST.Const, function (self, output) {
                self._do_print(output, "const");
            });

            DEFPRINT(AST.VarDef, function (self, output) {
                var p,
                    noin;
                self.name.print(output);
                if (self.value) {
                    output.space();
                    output.print("=");
                    output.space();
                    p = output.parent(1);
                    noin = (p instanceof AST.For) || (p instanceof AST.ForIn);
                    parenthesize_for_noin(self.value, output, noin);
                }
            });

            /* -----[ other expressions ]----- */
            DEFPRINT(AST.Call, function (self, output) {
                self.expression.print(output);
                if ((self instanceof AST.New) && no_constructor_parens(self, output)) {
                    return;
                }
                output.with_parens(function () {
                    self.args.forEach(function (expr, i) {
                        if (i) {
                            output.comma();
                        }
                        expr.print(output);
                    });
                });
            });
            DEFPRINT(AST.New, function (self, output) {
                output.print("new");
                output.space();
                AST.Call.prototype._codegen(self, output);
            });

            AST.Seq.DEFMETHOD("_do_print", function (output) {
                this.car.print(output);
                if (this.cdr) {
                    output.comma();
                    if (output.should_break()) {
                        output.newline();
                        output.indent();
                    }
                    this.cdr.print(output);
                }
            });
            DEFPRINT(AST.Seq, function (self, output) {
                self._do_print(output);
                // var p = output.parent();
                // if (p instanceof AST.Statement) {
                //     output.with_indent(output.next_indent(), function () {
                //         self._do_print(output);
                //     });
                // } else {
                //     self._do_print(output);
                // }
            });
            DEFPRINT(AST.Dot, function (self, output) {
                var expr = self.expression;
                expr.print(output);
                if (expr instanceof AST.Number && expr.getValue() >= 0) {
                    if (!/[xa-f.]/i.test(output.last())) {
                        output.print(".");
                    }
                }
                output.print(".");
                // the name after dot would be mapped about here.
                output.add_mapping(self.end);
                output.print_name(self.property);
            });
            DEFPRINT(AST.Sub, function (self, output) {
                self.expression.print(output);
                output.print("[");
                self.property.print(output);
                output.print("]");
            });
            DEFPRINT(AST.UnaryPrefix, function (self, output) {
                var op = self.operator;
                output.print(op);
                if (/^[a-z]/i.test(op) ||
                        (/[+\-]$/.test(op) &&
                            (self.expression instanceof AST.UnaryPrefix) &&
                            /^[+\-]/.test(self.expression.operator))) {
                    output.space();
                }
                self.expression.print(output);
            });
            DEFPRINT(AST.UnaryPostfix, function (self, output) {
                self.expression.print(output);
                output.print(self.operator);
            });
            DEFPRINT(AST.Binary, function (self, output) {
                self.left.print(output);
                output.space();
                output.print(self.operator);
                if ((self.operator === "<") &&
                        (self.right instanceof AST.UnaryPrefix) &&
                        (self.right.operator === "!") &&
                        (self.right.expression instanceof AST.UnaryPrefix) &&
                        (self.right.expression.operator === "--")) {
                    // space is mandatory to avoid outputting <!--
                    // http://javascript.spec.whatwg.org/#comment-syntax
                    output.print(" ");
                } else {
                    // the space is optional depending on "beautify"
                    output.space();
                }
                self.right.print(output);
            });
            DEFPRINT(AST.Conditional, function (self, output) {
                self.condition.print(output);
                output.space();
                output.print("?");
                output.space();
                self.consequent.print(output);
                output.space();
                output.colon();
                self.alternative.print(output);
            });

            /* -----[ literals ]----- */
            DEFPRINT(AST.Array, function (self, output) {
                output.with_square(function () {
                    var a = self.elements, len = a.length;
                    if (len > 0) {
                        output.space();
                    }
                    a.forEach(function (exp, i) {
                        if (i) {
                            output.comma();
                        }
                        exp.print(output);
                        // If the final element is a hole, we need to make sure it
                        // doesn't look like a trailing comma, by inserting an actual
                        // trailing comma.
                        if ((i === len - 1) && (exp instanceof AST.Hole)) {
                            output.comma();
                        }
                    });
                    if (len > 0) {
                        output.space();
                    }
                });
            });
            DEFPRINT(AST.Object, function (self, output) {
                if (self.properties.length > 0) {
                    output.with_block(function () {
                        self.properties.forEach(function (prop, i) {
                            if (i) {
                                output.print(",");
                                output.newline();
                            }
                            output.indent();
                            prop.print(output);
                        });
                        output.newline();
                    });
                } else {
                    output.print("{}");
                }
            });

            function getShortest(a) {
                var shortest = a[0],
                    len = shortest.length,
                    i;
                for (i = 1; i < a.length; ++i) {
                    if (a[i].length < len) {
                        shortest = a[i];
                        len = shortest.length;
                    }
                }
                return shortest;
            }

            function make_num(num) {
                /*jslint regexp:true */
                var str = num.toString(10),
                    a = [ str.replace(/^0\./, ".").replace('e+', 'e') ],
                    m;
                if (Math.floor(num) === num) {
                    if (num >= 0) {
                        a.push("0x" + num.toString(16).toLowerCase(), // probably pointless
                               "0" + num.toString(8)); // same.
                    } else {
                        a.push("-0x" + (-num).toString(16).toLowerCase(), // probably pointless
                               "-0" + (-num).toString(8)); // same.
                    }
                    m = /^(.*?)(0+)$/.exec(num);
                    if (m) {
                        a.push(m[1] + "e" + m[2].length);
                    }
                } else {
                    m = /^0?\.(0+)(.*)$/.exec(num);
                    if (m) {
                        a.push(m[2] + "e-" + (m[1].length + m[2].length),
                               str.substr(str.indexOf(".")));
                    }
                }
                return getShortest(a);
            }

            DEFPRINT(AST.ObjectKeyVal, function (self, output) {
                /*jslint eqeq: true */
                var key = self.key,
                    quote = self.quote,
                    shouldPrintName;
                if (output.option("quote_keys")) {
                    output.print_string(String(key));
                } else if (((typeof key === "number") || (!output.option("beautify") && (String(+key) == key))) &&
                        parseFloat(key) >= 0) {
                    output.print(make_num(key));
                } else {
                    shouldPrintName = predicates.RESERVED_WORDS(key) ? output.option("screw_ie8") : is.identifier_string(key);
                    if (shouldPrintName) {
                        output.print_name(key);
                    } else {
                        output.print_string(key, quote);
                    }
                }

                output.colon();
                self.value.print(output);
            });
            DEFPRINT(AST.ObjectSetter, function (self, output) {
                output.print("set");
                output.space();
                self.key.print(output);
                self.value._do_print(output, true);
            });
            DEFPRINT(AST.ObjectGetter, function (self, output) {
                output.print("get");
                output.space();
                self.key.print(output);
                self.value._do_print(output, true);
            });
            DEFPRINT(AST.Symbol, function (self, output) {
                var def = self.definition();
                output.print_name(def ? def.mangled_name || def.name : self.name);
            });
            DEFPRINT(AST.Undefined, function (self, output) {
                output.print("void 0");
            });
            DEFPRINT(AST.Hole, noop);
            DEFPRINT(AST.Infinity, function (self, output) {
                output.print("Infinity");
            });
            DEFPRINT(AST.NaN, function (self, output) {
                output.print("NaN");
            });
            DEFPRINT(AST.This, function (self, output) {
                output.print("this");
            });
            DEFPRINT(AST.Constant, function (self, output) {
                output.print(self.getValue());
            });
            DEFPRINT(AST.String, function (self, output) {
                output.print_string(self.getValue(), self.quote);
            });
            DEFPRINT(AST.Number, function (self, output) {
                output.print(make_num(self.getValue()));
            });

            function regexp_safe_literal(code) {
                return [
                    0x5c, // \
                    0x2f, // /
                    0x2e, // .
                    0x2b, // +
                    0x2a, // *
                    0x3f, // ?
                    0x28, // (
                    0x29, // )
                    0x5b, // [
                    0x5d, // ]
                    0x7b, // {
                    0x7d, // }
                    0x24, // $
                    0x5e, // ^
                    0x3a, // :
                    0x7c, // |
                    0x21, // !
                    0x0a, // \n
                    0x0d, // \r
                    0x00, // \0
                    0xfeff, // Unicode BOM
                    0x2028, // unicode "line separator"
                    0x2029  // unicode "paragraph separator"
                ].indexOf(code) < 0;
            }

            DEFPRINT(AST.RegExp, function (self, output) {
                var str = self.getValue().toString(),
                    p;
                if (output.option("ascii_only")) {
                    str = output.to_ascii(str);
                } else if (output.option("unescape_regexps")) {
                    str = str.split("\\\\").map(function (str) {
                        return str.replace(/\\u[0-9a-fA-F]{4}|\\x[0-9a-fA-F]{2}/g, function (s) {
                            var code = parseInt(s.substr(2), 16);
                            return regexp_safe_literal(code) ? String.fromCharCode(code) : s;
                        });
                    }).join("\\\\");
                }
                output.print(str);
                p = output.parent();
                if ((p instanceof AST.Binary) && (/^in/.test(p.operator)) && (p.left === self)) {
                    output.print(" ");
                }
            });

            /* -----[ source map generators ]----- */

            function DEFMAP(nodetype, generator) {
                nodetype.DEFMETHOD("add_source_map", function (stream) {
                    generator(this, stream);
                });
            }

            // We could easily add info for ALL nodes, but it seems to me that
            // would be quite wasteful, hence this noop in the base class.
            DEFMAP(AST.Node, noop);

            function basic_sourcemap_gen(self, output) {
                output.add_mapping(self.start);
            }

            // XXX: I'm not exactly sure if we need it for all of these nodes,
            // or if we should add even more.

            DEFMAP(AST.Directive, basic_sourcemap_gen);
            DEFMAP(AST.Debugger, basic_sourcemap_gen);
            DEFMAP(AST.Symbol, basic_sourcemap_gen);
            DEFMAP(AST.Jump, basic_sourcemap_gen);
            DEFMAP(AST.StatementWithBody, basic_sourcemap_gen);
            DEFMAP(AST.LabeledStatement, noop); // since the label symbol will mark it
            DEFMAP(AST.Lambda, basic_sourcemap_gen);
            DEFMAP(AST.Switch, basic_sourcemap_gen);
            DEFMAP(AST.SwitchBranch, basic_sourcemap_gen);
            DEFMAP(AST.BlockStatement, basic_sourcemap_gen);
            DEFMAP(AST.Toplevel, noop);
            DEFMAP(AST.New, basic_sourcemap_gen);
            DEFMAP(AST.Try, basic_sourcemap_gen);
            DEFMAP(AST.Catch, basic_sourcemap_gen);
            DEFMAP(AST.Finally, basic_sourcemap_gen);
            DEFMAP(AST.Definitions, basic_sourcemap_gen);
            DEFMAP(AST.Constant, basic_sourcemap_gen);
            DEFMAP(AST.ObjectProperty, function (self, output) {
                output.add_mapping(self.start, self.key);
            });

            AST.has_output_support = true;
        }
        return add_output_fns_to_AST;
    }
);